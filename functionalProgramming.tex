\documentclass[fsharpnotes.tex]{subfiles}

\begin{document}
\chapter{Functional programming}
\label{chap:functional}

Lists are well suited for recursive functions and pattern matching with, e.g., \keyword{match}-\keyword{with} as illustrated in the next example:
%
\fs{listPatternMatching}{Examples of list concatenation, indexing.}
%
The pattern \lstinline!l::rest! is the pattern for the first element followed by a list of the rest of the list. This pattern matches all lists except an empty list, hence \lstinline!rest! may be empty. Thus the wildcard pattern matching anything including the empty list, will be used only when \lstinline!lst! is empty.

\idx[pattern matching]{Pattern matching} with lists is quite powerful, consider the following problem:
\begin{problem}
  Given a list of pairs of course names and course grades, calculate the average grade.
\end{problem}
A list of course names and grades is \lstinline![("name1", grade1); ("name2", grade2); ...]!. Let's take a recursive solution. First problem will be to iterate through the list. For this we can use pattern matching similarly to Listing~\ref{listPatternMatching} with \lstinline!(name, grade)::rest!. The second problem will be to calculate the average. The average grade is the sum all grades and divide by the number of grades. Assume that we already have made a function, which calculates the \lstinline!sum! and \lstinline!n!, the sum and number of elements, for \lstinline!rest!, then all we need is to add \lstinline!grade! to the \lstinline!sum! and \lstinline!1! to \lstinline!n!. For an empty list, \lstinline!sum! and \lstinline!n! should be \lstinline!0!. Thus we arrive at the following solution,
% However, an elegant alternative is available as
% \fs{flowForLists}{}
% This to be preferred, since we completely can ignore list boundary conditions and hence avoid out of range indexing. For comparison see a recursive implementation of the same,
%
\fs{avgGradesRec}{Calculating a list of average grades using recursion and pattern matching.}
%
%Note how this implementation avoids the use of variables in contrast to the previous examples.

Pattern matching and appending is a useful combination, if we wish to produce new from old lists. E.g., a function returning a list of squared entries of its argument can be programmed as,
%
\fs{listSquare}{Using pattern matching and list appending elements to lists.}
%
This is a prototypical functional programming style solution, and which uses the \lexeme{::} for 2 different purposes: First the list \lstinline![1 .. 10]! is first matched with \lstinline!1 :: [2 .. 10]!, and then we assume that we have solved the problem for \lstinline!square rest!, such that all we need to do is append \lstinline!1*1! to the beginning output from \lstinline!square rest!. Hence we get, \lstinline!square [1 .. 10]! $\curvearrowright$ \lstinline!1 * 1 :: square [2 .. 10]! $\curvearrowright$ \lstinline!1 * 1 :: (2 * 2 :: square [3 .. 10])! $\curvearrowright$ \dots \lstinline!1 * 1 :: (2 * 2 :: ... 10 * 10 :: [])!, where the stopping criterium is reached, when the \lstinline!elm :: rest! does not match with a, hence it is empty, which does match the wildcard pattern \lexeme{_}. More on functional programming in Section~\ref{chap:functional}


Arrays only support direct pattern matching, e.g.,
%
\fs{arrayPatternMatching}{Only simple pattern matching is allowed for arrays.}
%
The given example is the first example of a 2-dimensional array, which can be implemented as arrays of arrays and here written as \lstinline!string array array!. Below further discussion of on 2 and higher dimensional arrays be discussed.  

\jon{In functional programming, data structures are dum. Separate behavior from data: "It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures" -- Alan Perlis. \url{https://www.infoq.com/presentations/Value-Values}}
\end{document}
%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
