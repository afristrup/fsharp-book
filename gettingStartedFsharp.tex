\documentclass[springer.tex]{subfiles}
\graphicspath{ {./figures/} }

\begin{document}
\chapter{Executing F\# Code}

\section{Source Code}
F\# is a functional first programming language, meaning that it has strong support for functional programming, but also supports imperative and object-oriented programming.
%Furthermore, it has strong support for parallel programming. It was originally developed for Microsoft's .Net platform, but is available as open source for many operating systems through Mono. In this text, we consider F\# \fsharpVersion and its Mono implementation, which is different from .Net mainly in terms of the number of libraries accessible. The complete language specification is described in \url{http://fsharp.org/specs/language-spec/}. 

F\# has two modes of execution, \idx[interactive mode]{interactive} and \idx[compile mode]{compiled}. Interactive mode allows the user to interact with F\# as a dialogue: The user writes statements, and F\# responds immediately. Interactive mode is well suited for small experiments or back-of-an-envelope calculations, but not for programming in general. In compile mode, the user writes a complete program, which is translated or compiled using the F\# compiler into a compiled file. The compiled file can be run or executed as a stand-alone program using a virtual machine called \lstinline[language=console]{mono}. In both the interactive and compile mode, F\# statements are translated into something that can be executed on the computer. A major difference is that in interactive mode, the translation is performed everytime the program is executed, while in compiled mode the translation is performed only once.

Both interactive and compile modes can be accessed via the \idx{console}, see \Cref{chap:console} for more information on the console.  The interactive system is started by calling \lstinline[language=console]{fsharpi} at the command prompt in the console, while compilation is performed with \lstinline[language=console]{fsharpc}, and execution of the compiled code is performed using the \lstinline[language=console]{mono} command. 

F\# programs come in many forms, which are identified by suffixes. The \idx{source code} is an F\# program written in human-readable form using an editor. F\# recognizes the following types of source code files:
\begin{description}
\item[\texttt{.fs}] An \idx{implementation file}, e.g., \lstinline[language=console]{myModule.fs}
\item[\texttt{.fsi}] A \idx{signature file}, e.g., \lstinline[language=console]{myModule.fsi}
\item[\texttt{.fsx}] A \idx{script file}, e.g., \lstinline[language=console]{gettingStartedStump.fsx}
\item[\texttt{.fsscript}] Same as \lstinline[language=console]{.fsx}, e.g., \lstinline[language=console]{gettingStartedStump.fsscript}
\end{description}
Compiled code is source code translated into a machine-readable language, which can be executed by a machine. Compiled F\# code is either:
\begin{description}
\item[\texttt{.dll}] A \idx{library file}, e.g., \lstinline[language=console]{myModule.dll}
\item[\texttt{.exe}] A stand-alone \idx{executable file}, e.g., \lstinline[language=console]{gettingStartedStump.exe}
\end{description}
% \begin{table}
%   \centering
%   \begin{tabular}{|l|l|}
%     \hline
%     Suffix & Description\\
%     \hline
%     \lstinline[language=console]{.fs} & An \idx{implementation file}\\
%     \lstinline[language=console]{.fsi} & A \idx{signature file}\\
%     \lstinline[language=console]{.fsx} & A \idx{script file}\\
%     \lstinline[language=console]{.fscript} & Same as \lstinline[language=console]{.fsx}\\
%     \lstinline[language=console]{.exe} & An \idx{executable file}\\
%     \hline
%   \end{tabular}
%   \caption{Source file suffixes in F\#}
%   \label{tab:suffix}
% \end{table}
The implementation, signature, and script files are all typically compiled to produce an executable file, in which case they are called \idx[script]{scripts}, but can also be entered into the interactive system, in which case these are called \idx[script-fragment]{script-fragments}. The implementation and signature files are special kinds of script files used for building libraries. Libraries in F\# are called modules, and they are collections of smaller programs used by other programs, which will be discussed in detail in \Cref{chap:modules}.

\section{Executing Programs}
Programs may either be executed by the interpreter or by compiling and executing the compiled code. In Mono the interpreter is called \lstinline[language=console]{fsharpi} and can be used in two ways: interactively, where a user enters one or more script-fragments separated by the \lexeme{;;} characters, or to execute a script file treated as a single script-fragment. \jon{Too early to introduce lexeme: ``F\# uses many characters which at times are given special meanings, e.g., the characters \lexeme{;;} is compound character denoting the end of a script-fragment. Such possibly compound characters are called %\idx[lexeme]{lexemes}
lexemes.''}

To illustrate the difference between interactive and compile mode, consider the program in \Cref{gettingStartedStump}.
%
\fsCode{gettingStartedStump}{gettingStartedStump}{A simple demonstration script.}{}
%
The code declares a value \lstinline{a} to be the decimal value 3.0 and finally prints it to the console. The \mbox{\lstinline{do printfn}} is a statement for displaying the content of a value to the screen, and \lstinline{"%g"} %
is a special notation to control how the value is printed. In this case, it is printed as a decimal number. This and more will be discussed at length in the following chapters. For now, we will concentrate on how to interact with the F\# interpreter and compiler.

An interactive session is obtained by starting the console, typing the \lstinline[language=console]{fsharpi} command, typing the lines of the program, and ending the script-fragment with \lexeme{;;}. The dialogue in \Cref{interactiveSession} demonstrates the workflow. What the user types has been highlighted by a \tikzmark{tl}box\tikzmark{br}\FrameArea{tl}{br}.
%
\begin{codeNOutput}[label=interactiveSession,
  top=-5pt,
  bottom=-5pt,
  left=-2pt,
  right=-2pt,
]{: An interactive session.}
  \begin{lstlisting}[language=console,escapechar=§]
$ §\tikzmark{lst1_5-tl}§fsharpi§\tikzmark{lst1_5-br}§

F# Interactive for F# 4.1 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

> §\tikzmark{lst1_4-tl}§let a = 3.0§\tikzmark{lst1_1-start}§
- do printfn "%g" a;;§\tikzmark{lst1_4-br}§§\tikzmark{lst1_1-end}§
3§\tikzmark{lst1_2-start}§

val a : float = 3.0 §\tikzmark{lst1_2-align}§
val it : unit = ()
§\tikzmark{lst1_2-end}§
> §\tikzmark{lst1_6-tl}§#quit;;§\tikzmark{end_3}§§\tikzmark{lst1_6-br}§
\end{lstlisting}%$
\end{codeNOutput}%
\FrameArea{lst1_4-tl}{lst1_4-br}%
\FrameArea{lst1_5-tl}{lst1_5-br}%
\FrameArea{lst1_6-tl}{lst1_6-br}%
% \tikzmark{start_1}\AddNote{lst1_1-start}{lst1_1-end}{lst1_1-end}{\tikzmark{end_1}}\DrawArrow[red,thick, out=-60, in=0]{start_1}{end_1} 
% \tikzmark{start_2}\AddNote{lst1_2-start}{lst1_2-end}{lst1_2-align}{\tikzmark{end_2}}\DrawArrow[red,thick, out=-60, in=0]{start_2}{end_2} 
% \tikzmark{start_3}\DrawArrow[red,thick, out=-60, in=0]{start_3}{end_3} 
% \begin{tikzpicture}[remember picture,overlay]
%   \draw[red,rounded corners] ([shift={(-3pt,2ex)}] lst1_4-tl)  rectangle  ([shift={(3pt,-0.65ex)}] lst1_4-br);
% \end{tikzpicture}
% \begin{tikzpicture}[remember picture,overlay]
%   \draw[red,rounded corners] ([shift={(-3pt,2ex)}] lst1_5-tl)  rectangle  ([shift={(3pt,-0.65ex)}] lst1_5-br);
% \end{tikzpicture}
% \begin{tikzpicture}[remember picture,overlay]
%   \draw[red,rounded corners] ([shift={(-3pt,2ex)}] lst1_6-tl)  rectangle  ([shift={(3pt,-0.65ex)}] lst1_6-br);
% \end{tikzpicture}
% \tikzmark{start}\AddNote{lst1_1-start}{lst1_1-end}{lst1_1-end}{You write}%
% \tikzmark{start}\AddNote{lst1_2-start}{lst1_2-end}{lst1_2-align}{Fsharp responds}%
% \tikzmark{start}\AddNote{lst1_3-start}{lst1_3-end}{lst1_3-end}{You write}%
%
We see that after typing \lstinline[language=console]{fsharpi}, the program starts by stating details about itself. Then F\# writes \lstinline{>} indicating that it is ready to receive commands. The user types \lstinline{let a = 3.0} and presses \lstinline[language=console]{enter}, to which the interpreter responds with \lstinline{-}. This indicates that the line has been received, that the script-fragment is not yet completed, and that it is ready to receive more input. When the user types \lstinline{do printfn "%g" a;;} %
followed by \lstinline[language=console]{enter}, then by \lexeme{;;} the interpreter knows that the script-fragment is completed, it interprets the script-fragment, responds with \lstinline{3} and some extra information about the entered code, and with \lstinline{>} to indicate that it is ready for more script-fragments. The interpreter is stopped when the user types \lstinline[language=console]{#quit;;}. It is also possible to stop the interpreter by typing \lstinline[language=console]{ctrl-d}.

The interactive session results in extra output on the \idx{type inference} performed. In \Cref{interactiveSession} F\# states that the name \lstinline{a} has \idx{type} \lstinline{float} and the value \lstinline{3.0}. Likewise, the \lstinline{do} statement F\# refers to by the name \lstinline{it}, and it has the type \lstinline{unit} and value \lstinline{()}. Types are very important to F\# since they define how different program pieces fit together like lego bricks. They are a key ingrediens for finding errors in programs, also known as \idx{debugging}, and much of the rest of this book is concerned with types.

Instead of running \lstinline[language=console]{fsharpi} interactively, we can write the script-fragment from \Cref{gettingStartedStump} into a file, here called \lstinline[language=console]{gettingStartedStump.fsx}. This file can be interpreted directly by \lstinline[language=console]{fsharpi} as shown in \Cref{commandlineInterpreter}.
%
\begin{codeNOutput}[label=commandlineInterpreter,
  top=-5pt,
  bottom=-5pt,
  left=-2pt,
  right=-2pt,
]{: Using the interpreter to execute a script.}
\begin{lstlisting}[language=console,escapechar=§]
$ §\tikzmark{lst2_1-tl}§fsharpi gettingStartedStump.fsx§\tikzmark{lst2_1-br}§
3
\end{lstlisting}%$
\end{codeNOutput}
\FrameArea{lst2_1-tl}{lst2_1-br}%
%
Notice that in the file, \lexeme{;;} is optional. We see that the interpreter executes the code and prints the result on screen without the extra type information as compared to \Cref{interactiveSession}.

Finally, the file containing \Cref{gettingStartedStump} may be compiled into an executable file with the program \lstinline[language=console]{fsharpc}, and run using the program \lstinline[language=console]{mono} from the console. This is demonstrated in \Cref{compiler}.
%
\begin{codeNOutput}[label=compiler,
  top=-5pt,
  bottom=-5pt,
  left=-2pt,
  right=-2pt,
]{: Compiling and executing a script.}
\begin{lstlisting}[language=console,escapechar=§]
$ §\tikzmark{lst3_1-tl}§fsharpc gettingStartedStump.fsx §\tikzmark{lst3_1-br}§
F# Compiler for F# 4.1 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License
$ §\tikzmark{lst3_2-tl}§mono gettingStartedStump.exe§\tikzmark{lst3_2-br}§
3
\end{lstlisting}
\end{codeNOutput}
\FrameArea{lst3_1-tl}{lst3_1-br}%
\FrameArea{lst3_2-tl}{lst3_2-br}%
%
The compiler reads \lstinline[language=console]{gettingStartedStump.fsx} and makes \lstinline[language=console]{gettingStartedStump.exe}, which can be run using \lstinline[language=console]{mono}.

Both the interpreter and the compiler translates the source code into a format which can be executed by the computer. While the compiler performs this translation once and stores the result in the executable file, the interpreter translates the code every time the code is executed. Thus, to run the program again with the interpreter, it must be retranslated as "\lstinline[language=console]{$fsharpi gettingStartedStump.fsx}''. %$
In contrast, compiled code does not need to be recompiled to be run again, only re-executed using "\lstinline[language=console]{$ mono gettingStartedStump.exe}". %$
On a MacBook Pro, with a 2.9 GHz Intel Core i5, the time the various stages take for this script are:
\begin{center}
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabular}{|l|l|}
    \hline
    \rowcolor{headerRowColor} Command & Time\\
    \hline
    \lstinline[language=console]|fsharpi gettingStartedStump.fsx| & 1.88s\\
    \lstinline[language=console]|fsharpc gettingStartedStump.fsx| & 1.90s\\
    \lstinline[language=console]|mono gettingStartedStump.exe| & 0.05s\\
    \hline
\end{tabular}
\end{center}
I.e., executing the script with \lstinline[language=console]|fsharpi| is slightly faster than by first compiling it with \lstinline[language=console]|fsharpc| and then executing the result with \lstinline[language=console]|mono| ($1.88\text{s} < 0.05\text{s}+1.90\text{s}$), if the script were to be executed only once, but every future execution of the script using the compiled version requires only the use of \lstinline[language=console]|mono|, which is much faster than \lstinline[language=console]|fsharpi| ($1.88\text{s}\gg 0.05\text{s}$).

Executing programs with the interpreted directly from a file and compiling and executing the program is much preferred for programming complete programs, since the starting state is well defined, and since this better supports \idx{unit testing}, which is a method for debugging programs. Thus, \advice{prefer compiling over interpretation.}% This comments corrects wrongly placed margin note: https://tex.stackexchange.com/questions/147827/why-does-marginpar-sometimes-add-an-unnecessary-newline

\section{The Printf Function}
\label{sec:printf}
A common way to output information to the console is to use one of the family of \idx[printf@\lstinline{printf}]{\lstinline{printf}} commands. These functions are special, since they take a variable number of arguments, and the number is decided by the first argument - the format string. The syntax for the \lstinline{printf} commands are as follows:
%
\begin{verbatimwrite}{\ebnf/printf.ebnf}
printf <*format-string*> {*<*ident*>*}
\end{verbatimwrite}
\syntax{\ebnf/printf.ebnf}{\lstinline{printf} statement.}
%
The \lstinline[language=ebnf]!formatString! is a string (simple or verbatim) with placeholders. The function \lstinline[language=ebnf]!printf! prints \lstinline[language=ebnf]!formatString! to the console, where all \lstinline[language=ebnf]!placeholder! have been replaced by the values of the corresponding arguments formatted as specified. For example, in \mbox{\lstinline!printfn "1 2 \%d" 3!}, the \lstinline[language=ebnf]!formatString! is \mbox{\lstinline!"1 2 \%d"!} and the placeholder is \lstinline!%d!. %
When executed, \lstinline{printf} will replace \lstinline!%d! %
with the following argument, \lstinline{3}, and print the result to the console: \mbox{\lstinline!1 2 3!}.  There are specifiers for all the basic types, and more, as elaborated in \Cref{tab:printfPlaceholder}.
% 
\begin{table}
  \centering
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \rowcolor{headerRowColor} Specifier& Type&Comment\\
    \hline
    \lstinline!\%b!&\lstinline!bool!&formatted as ``true'' or ``false''\\
    \hline
    \lstinline!\%s!&\lstinline!string!&\\
    \hline
    \lstinline!\%c!&\lstinline!char!&\\
    \hline
    \mbox{\lstinline!\%d!,} \mbox{\lstinline!\%i!}&basic integer&\\
    \hline
    \lstinline!\%u!&basic unsigned integers&\\
    \hline
    \lstinline!\%x!&basic integer&formatted as unsigned hexadecimal with lower case letters\\
    \hline
    \lstinline!\%X!&basic integer&formatted as unsigned hexadecimal with upper case letters\\
    \hline
    \lstinline!\%o!&basic integer&formatted as unsigned octal integer\\
    \hline
    \mbox{\lstinline!\%f!,} \mbox{\lstinline!\%F!,} &basic floats&formatted on decimal form\\
    \hline
    \mbox{\lstinline!\%e!,} \mbox{\lstinline!\%E!,} &basic floats&formatted on scientific form. Lower case uses "e" while upper case uses "E'' in the formatting.\\
    \hline
    \mbox{\lstinline!\%g!,} \mbox{\lstinline!\%G!,} &basic floats&formatted on the shortest of the corresponding decimal or scientific form.\\
    \hline
%    \lstinline!\%M!&decimal&\\
%    \hline
    \lstinline!\%A!, \lstinline!\%O!&any value&formatted as a basic type or using the object's \lstinline!ToString! method\\
    \hline
%    \lstinline!\%A!&any value&formatted as a basic type or using its \lstinline!ToString! method\\
%    \hline
%    \lstinline!\%a!&\lstinline[language=ebnf]!Printf.TextWriterFormat ->'a -> ()!&\\
%    \hline
%    \lstinline!\%t!&\lstinline[language=ebnf]!(Printf.TextWriterFormat -> ()!&\\
%    \hline
  \end{tabularx}
  \caption{Some printf placeholder strings.}
  \label{tab:printfPlaceholder}
\end{table}
The placeholder can be parametrized, e.g.,  the placeholder string \lstinline{%8s} %
will print a right-aligned string which that is eight characters wide and padded with spaces, as needed. For floating point numbers, \lstinline{%8f} %
will print a number that is exactly seven digits and a decimal point, making eight characters in total. Zeros are added after the decimal point, as needed. Alternatively, we may specify the number of digits after the decimal point, such that \lstinline{%8.1f} %
will print a floating point number, aligned to the right, with one digit after the decimal point padded with spaces, as needed. The default is for the value to be right justified in the field, but left justification can be specified by the \lstinline!-! character. For number types, you can specify their format by \lstinline!"0"! for padding the number with zeros to the left when right justifying the number; \lstinline!"+"! to explicitly show a plus sign for positive numbers; \lstinline!SP! to enforce a space, where there otherwise would be a plus sign for positive numbers. The placeholder parameter may also be given as an argument to \lstinline{printf} which case the placeholder should use the \lstinline!*! character instead of an integer.

Examples of placeholder parametrization are shown in \Cref{printfExample}.
%
\fs{printfExample}{Examples of printf and some of its formatting options.}
%
Not all combinations of flags and identifier types are supported, e.g., strings cannot have the number of integers after the decimal point specified.\spec{Mono seems to have a bug, \lstinline{printfn "\%.1g"   3.13;;} and \lstinline{printfn "\%.1f"   3.13;;} produces different number of digits.}\spec{Spec-4.0 \lstinline{\%s} and \lstinline{\%b} are missing in Section 3.1.16.}
The placeholder types \lstinline{"%A"}, %
\lstinline{"%a"}, %
and \lstinline{"%t"} %
are special for F\#, examples of their use are shown in \Cref{printfExampleAdvance}.
%
\fs{printfExampleAdvance}{Custom format functions may be used to specialise output.}
%
The \lstinline!%A! %
is special in that all built-in types, including tuples, lists, and arrays to be discussed in \Cref{chap:lists}, can be printed using this formatting string, but notice that the formatting performed includes the named literal string. The two formatting strings \lstinline!%t! %
and \lstinline!%a! %
are options for user-customizing the formatting and will not be discussed further.

Beware, \lstinline[language=ebnf]!formatString! is not a \lstinline!string! but a \lstinline!Printf.TextWriterFormat!, so to predefine a \lstinline[language=ebnf]!formatString! as, e.g., \mbox{\lstinline{let str = "hello \%s" in printf str "world"}}, will be a type error.

The family of \lstinline!printf! is shown in \Cref{tab:printfFamily}.\idxss{stdout@\lstinline{stdout}}\idxss{stderr@\lstinline{stderr}}\idxss{printf@\lstinline{printf}}\idxss{printfn@\lstinline{printfn}}\idxss{fprintf@\lstinline{fprintf}}\idxss{fprintfn@\lstinline{fprintfn}}\idxss{eprintf@\lstinline{eprintf}}\idxss{eprintfn@\lstinline{eprintfn}}\idxss{sprintf@\lstinline{sprintf}}\idxss{failwith@\lstinline{failwithf}}
\begin{table}
  \centering
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabularx}{\linewidth}{|l|l|X|}
    \hline
    \rowcolor{headerRowColor} Function & Example & Description\\
    \hline
    \lstinline!printf! & \lstinline!printf "\%d apples" 3! & Prints to the console, i.e., \lstinline!stdout!\\
    \lstinline!printfn! &  & As \lstinline!printf! and adds a newline.\\
    \hline
    \lstinline!fprintf! & \lstinline!fprintf stream "\%d apples" 3! & Prints to a stream, e.g., \lstinline!stderr! and \lstinline!stdout!, which would be the same as \lstinline!printf! and \lstinline!eprintf!.\\
    \lstinline!fprintfn! & & As \lstinline!fprintf! but with added newline.\\
    \hline
    \lstinline!eprintf! & \lstinline!eprintf "\%d apples" 3! & Prints to \lstinline!stderr!\\
    \lstinline!eprintfn! & & As \lstinline!eprintf! but with added newline.\\
    \hline
    \lstinline!sprintf! & \lstinline!sprintf "\%d apples" 3! & Return printed string\\
    \hline
    \lstinline!failwithf! & \lstinline!failwithf "\%d failed apples" 3! & Prints to a string and used for raising an exception.\\
    \hline
  \end{tabularx}
  \caption{The family of printf functions.}
  \label{tab:printfFamily}
\end{table}
The function \lstinline!fprintf! prints to a stream, e.g., \lstinline!stderr! and \lstinline!stdout!, of type \lstinline!System.IO.TextWriter!. For the moment it is sufficient to think of both \lstinline!stderr! and \lstinline!stdout! to be the console. Streams will be discussed in further detail in \Cref{chap:IO}. The function \lstinline!failwithf! is used with exceptions, see \Cref{chap:errors} for more details. The function has a number of possible return value types, and for testing, the \idx[ignore@\lstinline{ignore}]{\lstinline{ignore}} function ignores it all, e.g., \mbox{\lstinline!ignore (failwithf "\%d failed apples" 3)!}.
\spec{Mono: \lstinline{bprintf} and \lstinline{kprintf} are undefined.}

\section{Reading from the Console}
\label{sec:readline}
The \lstinline{printf} and \lstinline{printfn} functions allow us to write text on the screen. A program often needs to ask a user to input data, e.g., by typing text on a keyboard. Text typed on the keyboard is accessible through the \lstinline{stdin} stream, and F\# provides several library functions for capturing text typed on the keyboard. In the following section, we will briefly discuss the \lstinline{System.Console.ReadLine} function. For more details and other methods of input see \Cref{chap:IO,chap:windows}.

The function \lstinline{System.Console.ReadLine} takes a unit value as an argument and returns the string the user typed. The program will not advance until the user presses newline. An example of a program that multiplies two floating point numbers supplied by a user is given in \Cref{userDialoguePrintfCode},
%
\fsCode{userDialoguePrintf}{userDialoguePrintfCode}{Interacting with a user using \lstinline!ReadLine!.}{}
%
and an example dialogue is shown in \Cref{userDialoguePrintf}.
%
\fsOutput{userDialoguePrintf}{An example dialogue of running \Cref{userDialoguePrintfCode}. The user typed ``3.5'' and ``7.4''.}{}%
%\FrameArea{userDialoguePrintf_1-tl}{userDialoguePrintf_1-br}%
%\FrameArea{userDialoguePrintf_2-tl}{userDialoguePrintf_2-br}%
%
Note that the string is immediately cast to floats such that we can multiply the input using the float multiplication operator. This also implies that if the user inputs a non-number, then \lstinline[language=console]{mono} will halt with an error message.

\end{document}
