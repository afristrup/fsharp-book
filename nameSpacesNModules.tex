\documentclass[fsharpNotes.tex]{subfiles}
\graphicspath{ {./figures/} }

\begin{document}

\chapter{Organising Code in Libraries and Application Programs}
\label{chap:modules}
\abstract{
  Introductory text about the objectivs of this chapter
  \begin{itemize}
  \item \dots
  \end{itemize}
}

In this chapter, we will focus on a number of ways to make the code available as \idx{library} functions in F\#. A library is a collection of types, values, and functions that an application program can use. A library does not perform calculations on its own.

F\# includes several programming structures to organize code in libraries: Modules, namespaces, and classes. In this chapter, we will describe modules and namespaces. Classes will be described in detail in \Cref{chap:oop}.

\section{Dotnet projects: Libraries and applications}
\label{chap:projects}
As our programs grow in size, it can be convenient to split the program over several files, e.g., by separating functionality into something which general and specific in  nature with respect the problem being solved. Examples of this is the \lstinline{List} module which contains general functions on lists, and which you have used in your programs. In this chapter, we will write our own modules, also known as libraries, and the programs using these libraries, we will call applications. Using the \lstinline[language=console]{dotnet} command-line tool, we are able to create project files which have a \lstinline[language=console]{.fsproj} suffix, which include information about which source code and packages belongs together. The \lstinline[language=console]{dotnet} command-line tool further helps structure the files on the filesystem by use of directories. As an example
\begin{codeNOutput}[label=dotnetNew,
  top=-5pt,
  bottom=-5pt,
  left=-2pt,
  right=-2pt,
]{: Creating an initial library-application file setup.}
  \begin{lstlisting}[language=console,escapechar=§]
$ dotnet new console -lang "F#" -o app
$ dotnet new classlib -lang "F#" -o library
$ dotnet add app/app.fsproj reference library/library.fsproj
$ dotnet add app/app.fsproj package "DIKU.Canvas" --version 1.0.1
\end{lstlisting}
\end{codeNOutput}
creates the files and directories shown in \Cref{fig:dotnetNewFileSystem}.
\begin{figure} % make sure figure is printed after the countRecursive
  \centering
  \includegraphics[width=0.5\linewidth]{dotnetNew}
  \caption{Typical initial files and directories for a library and application multifile setup and as created by \lstinline[language=console]{dotnet new} and  \lstinline[language=console]{dotnet add}.}
  \label{fig:dotnetNewFileSystem}
\end{figure}
The directories \lstinline[language=console]{obj} contains additional libraries etc.\ which dotnet needs to build projects, and can safely be ignored for now. The \lstinline[language=console]{Program.fs} and \lstinline[language=console]{Library.fs} are the default filenames for the application and the library, and the \lstinline[language=console]{.fsproj} are XML-files which describes how dotnet should combine the library and the application files etc. In this case, the \lstinline[language=console]{app.fsproj} contains
\begin{codeNOutput}[label=appFsproj,
  top=-5pt,
  bottom=-5pt,
  left=-2pt,
  right=-2pt,
]{: The initial content of \texttt{app.fsproj}.}
  \begin{lstlisting}[language=console,escapechar=§]
<Project Sdk="Microsoft.NET.Sdk">
 <PropertyGroup>
  <OutputType>Exe</OutputType>
  <TargetFramework>net6.0</TargetFramework>
 </PropertyGroup>
 <ItemGroup>
  <Compile Include="Program.fs" />
 </ItemGroup>
 <ItemGroup>
  <ProjectReference Include="..\library\library.fsproj" />
 </ItemGroup>
 <ItemGroup>
  <PackageReference Include="DIKU.Canvas" Version="1.0.1" />
 </ItemGroup>
</Project>
\end{lstlisting}
\end{codeNOutput}
which we see includes references to \lstinline[language=console]{Program.fs}, \lstinline[language=console]{library.fsproj}, and \lstinline[language=console]{DIKU.Canvas}.
Likewise, the \lstinline[language=console]{library.fsproj} file
\begin{codeNOutput}[label=libraryFsproj,
  top=-5pt,
  bottom=-5pt,
  left=-2pt,
  right=-2pt,
]{: The initial content of \texttt{library.fsproj}.}
  \begin{lstlisting}[language=console,escapechar=§]
<Project Sdk="Microsoft.NET.Sdk">
 <PropertyGroup>
  <TargetFramework>net6.0</TargetFramework>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
 </PropertyGroup>
 <ItemGroup>
  <Compile Include="Library.fs" />
 </ItemGroup>
</Project>
\end{lstlisting}
\end{codeNOutput}
contains a reference to \lstinline[language=console]{Library.fs}.

These files can be edited in any text-editor, e.g., if we wish our application source file to be called \lstinline[language=console]{Program.fsx}, we rename \lstinline[language=console]{Program.fs} to \lstinline[language=console]{Program.fsx}, in the \lstinline[language=console]{app}-directory, edit \lstinline[language=console]{app.fsproj} by replacing \lstinline[language=console]{Program.fs} with \lstinline[language=console]{Program.fsx}.

As an example, change \lstinline[language=console]{Program.fs} to become what is shown in \Cref{program},
\fsImplementation{solution/app/Program}{program}{A simple application program.}{}
change \lstinline[language=console]{Library.fs} to become what is shown in \Cref{library}, 
\fsImplementation{solution/library/Library}{library}{A simple library.}{}
and run it in \idx{compile mode} by changing to the \lstinline[language=console]{app} directory and using the \lstinline[language=console]{dotnet run} command as demonstrated in \Cref{dotnetRun}.
\begin{codeNOutput}[label=dotnetRun,
  top=-5pt,
  bottom=-5pt,
  left=-2pt,
  right=-2pt,
]{: Running an application setup with one or more project files.}
  \begin{lstlisting}[language=console,escapechar=§]
$ cd solution/app
$ dotnet run
"Greetings Jon"
\end{lstlisting}%$
\end{codeNOutput}
Assuming that \lstinline[language=console]{Program.fs} was rename to \lstinline[language=console]{Program.fsx} and \lstinline[language=console]{app.fsproj} was edited appropriately, \lstinline[language=console]{dotnet run} is almost the same as
\begin{codeNOutput}[label=dotnetRun,
  top=-5pt,
  bottom=-5pt,
  left=-2pt,
  right=-2pt,
]{: Running an application setup with one or more project files.}
  \begin{lstlisting}[language=console,escapechar=§]
$ dotnet fsi ../library/Library.fs Program.fsx
"Greetings Jon"
\end{lstlisting}%$
\end{codeNOutput}
However, \lstinline[language=console]{dotnet fsi} \idx{interprets} the library and application into executable code everytime it is called, while \lstinline[language=console]{dotnet run} only \idx{compiles} the program once. On my laptop, the time these different steps take depends on what else is running on the computer, but typical timings are
\begin{center}
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabular}{|l|l|}
    \hline
    \rowcolor{headerRowColor} Command & Time\\
    \hline
    \lstinline[language=console]|dotnet fsi ../library/Library.fs Program.fsx| & 1.2s\\
    \lstinline[language=console]|dotnet run| (first time) & 4.0s\\
    \lstinline[language=console]|dotnet run| & 1.0s\\
    \hline
\end{tabular}
\end{center}
The example application, we are studying here, is tiny, but even in this case, the repeated translation by \lstinline[language=console]{dotnet fsi} is a 16\% overhead when compared to an already compiled program, and you should expect this overhead to be larger for larger programs. However, the these tiny programs the cost of the initial compilation is 400\% and not worth the effort from a time perspective.

\section{Libraries and applications}
\label{sec:modules}
A library in F\# is expressed as a \idx{module}, which is a programming structure used to organize type declarations, values, functions, etc. The libraries should have the  suffix \lstinline[language=console]{.fs}, and here will will call them \idx{implementation files} in contrast to the signature files to be discussed below, which we will call \idx{interface files}.

A module is typically a file where the module name is declared in the first liness using the \idx[module@\lstinline{module}]{\keyword{module}} with the following syntax,
%
\begin{verbatimwrite}{\ebnf/outerModule.ebnf}
module <*ident*>
<*script*>
\end{verbatimwrite}
\syntax{\ebnf/outerModule.ebnf}{Outer module.}
%
Here, the identifier \lstinline[language=syntax]{<*ident*>} is a name not necessarily related to the filename, and the script \lstinline[language=syntax]{<*script*>} is an expression.

Consider the example from \Cref{solveQuadraticEquation} in which functions are defined for solving the values of $x$ where $f(x)=0$ for a quadratic equation. In the following, we will split this into a library of functions and an application program. For this we setup a project system of files as described in \Cref{chap:projects}, where \lstinline[language=console]{Program.fs} has been replaced by \lstinline[language=console]{Program.fsx} and the \lstinline[language=console]{app.fsproj} has been edited appropriately. The content of  \lstinline[language=console]{Library.fs} has been changed to become what is shown in \Cref{quadraticModule}, 
\fsImplementation{solve/library/Library}{quadraticModule}{A library for solving quadratic equations.}{}
and \lstinline[language=console]{Program.fsx} has been changed to what is shown in \Cref{quadraticApp}.
\fsCode{solve/app/Program}{quadraticApp}{An application using the \lstinline!Solve! module.}{}

Module files can be accompanied by \idx[signature file]{signature files} which have the suffix \lstinline[language=console]{.fsi}. A signature file contains no implementation, only type definitions. Signature files offer three distinct features:
\begin{enumerate}
\item Signature files can be used as part of the documentation of code, since type information is of paramount importance for an application programmer to use a library. 
\item Signature files may be written before the implementation file. This allows for a higher-level programming design that focuses on \emph{which} functions should be included and \emph{how} they can be composed.
\item Signature files allow for access control. Most importantly, if a type definition is not available in the signature file, then it is not available to the application program. Such definitions are private and can only be used internally in the library code. More fine-grained control related to classes is available and will be discussed in \Cref{chap:oop}.
\end{enumerate}
These features help the programmer structure the process of programming and protects the user of a library from irrelevant data and functions. A signature file contains the type definitions and the types of the values and functions the is to be exposed to the user of the library. For example, for the library in \Cref{quadraticModule}, we can define a signature files which makes the \lstinline{solveQuadraticEquation} function but not the \lstinline{discriminant} function available to the user of the library as demonstrated in \Cref{librarySignature}.
\fsSignature{solve/library/Library}{librarySignature}{A signature file for \Cref{quadraticModule}.}{}
To compile the application using the signature file, we must add the created file, e.g., \lstinline[language=console]{Library.fsi}, to \lstinline[language=console]{<Compile Include="Library.fs" />} to \lstinline[language=console]{library.fsproj} as follows
\begin{codeNOutput}[label=libraryFsprojFSI,
  top=-5pt,
  bottom=-5pt,
  left=-2pt,
  right=-2pt,
]{: The \texttt{library.fsproj} with an interface file added.}
  \begin{lstlisting}[language=console,escapechar=§]
<Project Sdk="Microsoft.NET.Sdk">
 <PropertyGroup>
  <TargetFramework>net6.0</TargetFramework>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
 </PropertyGroup>
 <ItemGroup>
  <Compile Include="Library.fsi" />
  <Compile Include="Library.fs" />
 </ItemGroup>
</Project>
\end{lstlisting}
\end{codeNOutput}
It is important that the signature file is written before the implementation file.


\section{Debugging modules}


\section{Key Concepts and Terms in This Chapter}
In this chapter, we have \dots
\begin{itemize}
\item etc.
\end{itemize}

\end{document}

