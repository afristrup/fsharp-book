\documentclass[springer.tex]{subfiles}
\graphicspath{ {./figures/} }

\begin{document}
\chapter{Sequences and computation expressions}
\label{chap:sequences}\jon{possibly add maps and sets as well.}
\section{Sequences}
\label{sec:sequences}
Sequences are lists, where the elements are build as needed. Examples are\jon{Mono does not support specification Spec-4.0 Section 6.3.11, seq {comp-expr}, in the form seq {3} or seq {3; 4}.}
%
\fsOutput{seqExample}{Creating sequences by range explicitly stating elements, a range expressions, a computation expression, and an infinite computation expression}
%
Sequences are built using the following subset of the general syntax,
\begin{lstlisting}[language=ebnf]
range-exp = expr ".." expr [".." expr]
comp-expr =
  "let" pat "=" expr "in" comp-expr
  | "use" pat = expr "in" comp-expr
  | ("yield" | "yield!") expr
  | "if" expr "then" comp-expr ["else" comp-expr]
  | "match" expr "with" comp-rules
  | "try" comp-expr "with" comp-rules
  | "try" comp-expr "finally" expr
  | "while" expr "do" expr ["done"]
  | "for" ident "=" expr "to" expr "do" comp-expr ["done"]
  | "for" pat "in" expr-or-range-expr "do" comp-expr ["done"]
  | comp-expr ";" comp-expr
short-comp-expr = "for" pat "in" (expr | range-expr) "->" expr
comp-or-range-expr = comp-expr| short-comp-expr | range-expr
comp-rule = pat pattern-guardopt "->" comp-expr
comp-rules = comp-rule | comp-rule '|' comp-rules
expr = ... 
  | "seq" "{" comp-or-range-expr "}" (* computation expression *)
  | ...
\end{lstlisting}
%
Sequence may be defined using simple range expressions but most often are defined as a small program, that generates values with the \keyword{yield} keyword or \keyword{yield!} keyword. The \keyword{yield!} is called \idx{yield bang}, and appends a sequence instead of adding a sequence as an element. Thus, \lstinline!seq {3; 5}! is not permitted, but \lstinline!seq {yield 3; yield 5}! and \lstinline|seq {yield! (seq {yield 3; yield 5})}| are, both creating \lstinline!seq<int> = seq [3; 5]!, i.e., a sequence of integers. Most often computation expressions are used to produced members that are not just ranges, but more complicated expressions of ranges, e.g., \lstinline!c! in the example. Sequences may even in principle be infinitely long, e.g., \lstinline!d!. Calculating the complete sequence at the point of definition is impossible due to lack of memory, as is accessing all its elements due to lack of time. But infinite sequences are still very useful, e.g., identifier \lstinline!d! illustrates the parametrization of a circle, which is an infinite domain, and any index will be converted to the equivalent 60th degree angle in radians. F\# warns against recursive values, as defined in the example, since it will check the soundness of the value at runtime rather than at compile-time. The warning can be removed by adding \lstinline!#nowarn "40"! in the script or \lstinline!--nowarn:40! as argument to \lstinline[language=console]!fsharpi! or \lstinline[language=console]!fsharpc!.

Sequences are generalisations of lists and arrays, and functions taking sequences as argument may equally take lists and arrays as argument. Sequences do not have many built-in operators, but a rich collection of functions in the \lstinline!Collections.Seq!. E.g.,\idxss{Seq.item}\idxss{Seq.take}
%
\fsOutput{seqIndexing}{Index a sequence with \lstinline!Seq.item! and \lstinline!Seq.take!}
%
which as usual index from 0 and will cast an exception, if indexing is out of range for the sequence. 

That sequences really are programs rather than values can be seen by the following example,
%
\fsOutput{seqDelayedEval}{Sequences elements are first evaluated, when needed.}
%
In the example, we see that the \lstinline!printfn! function embedded in the definition is first executed, when the 3rd item is requested.

\jon{Mono, missing support for Spec-4.0 Chapter 6, \lstinline!do!-\lstinline!in! in sequences. E.g., \lstinline!seq {let _ = printfn "hej" in yield 3}! is ok, but \lstinline!seq {do printfn "hej" in yield 3}! not. One could argue, that computation expression is the framework and that it is the seq implementation, which does not provide full access to the framework. but this is confusing, since seq gets special attention in the specification.}

The only difference between computation expression's programming constructs and the similar regular expressions constructs is that they must return a value with the \keyword{yield} or \keyword{yield!} keywords.\jon{Mono implements if-elif-else, but this is not in the specification.} The \keyword{try}-keyword constructions will be discussed in \Cref{chap:errors}, and the \keyword{use}-keyword is a variant of \keyword{let} but used in asynchronous computations, which will not be treated here.

  % "let" pat "=" expr "in" comp-expr
  % | "use" pat = expr "in" comp-expr
  % | ("yield" | "yield!") expr
  % | "if" expr "then" comp-expr ["else" comp-expr]
  % | "match" expr "with" comp-rules
  % | "try" comp-expr "with" comp-rules
  % | "try" comp-expr "finally" expr
  % | "while" expr "do" expr ["done"]
  % | "for" ident "=" expr "to" expr "do" comp-expr ["done"]
  % | "for" pat "in" expr-or-range-expr "do" comp-expr ["done"]
  % | comp-expr ";" comp-expr

Infinite sequences is a useful concept in many programs and may be generated in a number of ways. E.g., to generate a repeated sequence, we could use recursive value definition, a computation expression, a recursive function, or the \lstinline!Seq! module. Using a recursive value definition,
%
\fs{seqInfinteValue2}{Recursive value definitions gives a warning.  Compare with Listing\ref{seqInfinteValue}, \ref{seqInfinteFunction}, and \ref{seqInitInfinite}.}
%
F\# warns against using recursive values, since it will check the soundness of the value at runtime rather than at compile-time. The warning can be removed by adding \lstinline!#nowarn "40"! in the script or \lstinline!--nowarn:40! as argument to \lstinline[language=console]!fsharpi! or \lstinline[language=console]!fsharpc!, but \advice{warnings are messages from the designers of F\# that your program is non-optimal, and you should avoid structures that throw warnings instead of relying on \lstinline{\#nowarn} and similar constructions.} Instead we may create an infinite loop using the \keyword{while}-\keyword{do} computation expression, as
%
\fs{seqInfinteValue}{Infinite value definition without recursion nor warning.  Compare with \Cref{seqInfinteValue2}, \ref{seqInfinteFunction}, and\ref{seqInitInfinite}.}
%
or alternatively define a recursive function,
%
\fs{seqInfinteFunction}{Recursive function definitions gives no a warning.  Compare with \Cref{seqInfinteValue2}, \ref{seqInfinteValue}, and \ref{seqInitInfinite}.}
%
Infinite expressions have built-in support through the \lstinline!Seq! module using \idxss{Seq.initInfinite},
%
\fs{seqInitInfinite}{Using \lstinline{Seq.initInfinte} and a function to generate an infinte sequence. Compare with \Cref{seqInfinteValue2}, \ref{seqInfinteValue}, and \ref{seqInfinteFunction}.}
%
which takes a function as argument. Here we have used currying, i.e., \lstinline!get items! is a function that takes on variable and returns a value. The use of the remainder operator makes the example rather contrived, since it might have been simpler to use the \lstinline!get! indexing function directly.

Sequences are easily converted to and from lists and arrays as,\idxss{Seq.toList}\idxss{Seq.toArray}
%
\fs{seqConversion}{Conversion between sequences and lists and arrays using the \lstinline!List! module.}
%
There are quite a number of built-in functions for sequences many which will be discussed in \Cref{chap:collection}.
 
Lists and arrays may be created from sequences through the short-hand notation called \idx[list sequence expression]{list and array sequence expressions}\idxss{array sequence expressions},
\begin{lstlisting}[language=ebnf]
expr = ... 
  | "[" (... | comp-expr | short-comp-expr | ...) "]" (* list sequence expression *)
  | "[|" (.. | comp-expr | short-comp-expr | ...) "|]" (* array sequence expression *)
  | ...
\end{lstlisting}
which implicitly creates the corresponding expression and return the result as a list or array.

% *****

% \fs{arrayJaggedCompExpr}{}
% Indexing arrays of arrays is done sequentially, in the sense that in the above example, the number of outer arrays is \lstinline|a.Length|,  \lstinline|a.[i]| is the i'th array, the length of the i'th array is \lstinline|a.[i].Length|, and the j'th element of the i'th array is thus \lstinline|a.[i].[j]|. Often 2 dimensional square arrays are used, which can be implemented as a jagged array as,
% \fs{arrayJaggedSquareCompExpr}{}
% In fact, square arrays of dimensions 2 to 4 are so common that F\# has built-in modules for their support. In the following describe Array2D. The workings of Array3D and Array4D are very similar. An example of creating the same 2 dimensional array as above but as an \texttt{Array2D} is,
% \fs{array2DCompExpr}{}
% Notice that the indexing uses a slightly different notation '\lstinline|[,]|' and the length functions are also slightly different. The statement \lstinline|A.Length| would return the total number of elements in the array, in this case 12.


\end{document}
%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
