\chapter{Numbers, Characters, and Strings}
All programs rely on processing of data, and an essential property of data is its \idx{type}. F\# contains a number of built-in types, and it designed such that it is easy to define new types. The simplest types are called \idx{primitive types}, and a table of some of the most commonly used primitive types are shown in Table~\ref{tab:primitiveTypes}.
\begin{table}
  \centering
  \begin{tabularx}{\textwidth}{|l|l|l|l|>{\raggedright\arraybackslash}X|}
    \hline
    Metatype & Type name & Suffix & Literal & Description\\
    \hline
    Boolean & bool & none & true & Boolean values true or false \\
    \hline
    Integer & \textbf{int} & none or l & 3 & Integer values from -2,147,483,648 to 2,147,483,647 \\
             &byte & uy  & 3uy &Integer values from 0 to 255\\
             &sbyte & y & 3y &Integer values from -128 to 127\\
             &int16 & s  & 3s &Integer values from -32768 to 32767\\
             &uint16 & us & 3us &Integer values from 0 to 65535\\
             &int32 & none or l  & 3 &Synonymous with int\\
             &uint32 & u or ul  & 3u & Integer values from 0 to 4,294,967,295\\
             &int64 & L  & 3L &Integer values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\\
             &uint64 & UL  & 3UL &Integer values from 0 to 18,446,744,073,709,551,615\\
             &bigint & I & 3I &Integer not limited to 64 bits\\
             &nativeint & n & 3n &A native pointer as a signed integer\\
             &unativeint & un  &3un &A native pointer as an unsigned integer\\
    \hline
    Real & \textbf{float} & none  & 3.0 & 64-bit IEEE 754 floating point value from $-\infty$ to $\infty$\\
             & double &none & 3.0 & Synonymous with float\\
             & single & F or f  & 3.0f &A 32-bit floating point type\\
             &float32 & F or f  & 3.0f &Synonymous with single\\
             &decimal &M or m & 3.0m &A floating point data type that has at least 28 significant digits\\
    \hline
    Character &\textbf{char} & none  & 'c' &Unicode character\\
             &byte & B  & 'c'B & ASCII character\\
             &\textbf{string} & none  & "abc" & Unicode sequence of characters\\
             &byte[] & B  & "abc"B & Unicode sequence of characters\\
             &string or byte[] & @  & @"\textbackslash n" & Verbatim string\\
    \hline
    None &\textbf{unit} &none & \texttt{()} & No value denoted\\
             %&void &none  &  &Indicates no type or value\\
    \hline
  \end{tabularx}
  \caption{List of primitive types and the corresponding literal. The most commonly used types are highlighted in bold. Note that string verbatim uses a prefix instead of suffix notation. For at description of floating point numbers see Appendix~\ref{sec:floatingPoint} and for ASCII and Unicode characters see Appendix~\ref{sec:characterSets}.}
  \label{tab:primitiveTypes}
\end{table}
A \idx{literal} is a fixed value such as "3", and F\# supports \idx[literal type]{literal types} which are indicated by a suffix in most cases and as shown in the table.

A name is bound to a value by the syntax,
\begin{lstlisting}[language=EBNF]
"let" [ "mutable" ] ident [":" type] "=" expr ["in" expr]
\end{lstlisting}
\begin{comment}
or alternatively
\begin{lstlisting}[language=EBNF]
"let" ["mutable"] ident [":" type] "=" expr [["in"] LF indent exp]
\end{lstlisting}
\end{comment}
That is, the \idx{\keyword{let}} keyword indicates that the following is a binding of a name with an expression, and that the type may be specified with the \idx{\token{:}} token. The binding may be mutable, which will be discussed in Section~\ref{sec:mutableValues}, and the binding may only be for the last expression as indicated by the \idx{\keyword{in}}. The simplest example of an expression is a \idx{literal}, i.e., a constant such as the number 3 or a function. Functions will be discussed in detail in Chapter~\ref{chap:functions}. Examples of let statements with \idx{literals}
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 3 
- let b = 4u 
- let c = 5.6 
- let d = 7.9f 
- let e = 'A'
- let f = 'B'B 
- let g = "ABC" 
- let h = ();;

val a : int = 3
val b : uint32 = 4u
val c : float = 5.6
val d : float32 = 7.9000001f
val e : char = 'A'
val f : byte = 66uy
val g : string = "ABC"
val h : unit = ()
\end{lstlisting}
Here \lstinline|a|, \lstinline|b|, \dots, \lstinline|h| are names that we have chosen, and which by the binding operation are made equivalent to the corresponding values. Note that we did not specify the type of the name, and that F\# interpreted the type from the literal form of the right-hand-side. Types matter, since the operations that can be performed on integers are quite different from those that can be performed on characters and strings. I.e.,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 3
- let b = 3.0 
- let c = '3' 
- let d = "3";;

val a : int = 3
val b : float = 3.0
val c : char = '3'
val d : string = "3"
\end{lstlisting}
the variables \lstinline|a|, \lstinline|b|, \lstinline|c|, and \lstinline|d| all represent the number 3, but their types are different, and hence they are quite different values. When specifying the type, then the type and the literal form must match, i.e., mixing types and literals gives an error,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
  > let a : float = 3;;

  let a : float = 3;;
  ----------------^

/Users/sporring/repositories/fsharpNotes/stdin(50,17): error FS0001: This expression was expected to have type
    float    
but here has type
    int    
\end{lstlisting}
since the left-hand-side is a name of type float while the right-hand-side is a literal of type integer.

Many primitive types are compatible and may changed to each other by \idx{type casting}. E.g.,
\begin{lstlisting}[language=fsharp,caption={fsharpi},label=upcasting]
> let a = float 3;;

val a : float = 3.0
\end{lstlisting}
where the left-hand-side is inferred to by of type float, since the integer number \lstinline|3| is casted to float resulting in a similar floating point value, in this case the float point number \lstinline|3.0|. As a particular note, the boolean values are often treated as the integer values 0 and 1, however casting can only be performed with built-in functions, e.g., \begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = System.Convert.ToBoolean 1    
- let b = System.Convert.ToBoolean 0    
- let c = System.Convert.ToInt32 true   
- let d = System.Convert.ToInt32 false;;

val a : bool = true
val b : bool = false
val c : int = 1
val d : int = 0
\end{lstlisting}
Here \lstinline|System.Convert.ToBoolean| is the name of a function \lstinline|ToBoolean|, which is a \idx{member} of the \idx{class} \lstinline|Convert| that is included in the \idx{namespace} \lstinline|System|. Namespaces, classes, and members are all part of Structured programming to be discussed in Part~\ref{part:structured}. For more on functions see Section~\ref{chap:functions}

Typecasting is often a destructive operation, e.g., typecasting a float to int removes the part after the decimal point without rounding,
%
\fs{quickStartDownCast}{Fractional part is removed by downcasting.}
%
Here we typecasted to a lesser type, in the sense that integers is a subset of floats, which is called \idx{downcasting}. The opposite is called \idx{upcasting} is often non-destructive, as Listing~\ref{upcasting} showed, where an integer was casted to a float while retaining its value. As a side note, \idx{rounding} a number $y.x$, where $y$ is the whole part and $x$ is the fractional part, is the operation of mapping numbers in the interval $y.x \in [y.0,y.5)$ to $y$ and $y.x\in [y.5,y+1)$ to $y+1$. This can be performed by downcasting as follows,
%
\fs{rounding}{The rounding function may be obtained by downcasting.}
%
since if $y.x\in [y.0, y.5)$, then $y.x+0.5\in [y.5, y+1)$, from which downcasting removes the fractional part resulting in $y$. And if $y.x\in [y.5, y+1)$, then $y.x+0.5\in [y+1,y+1.5)$, from which downcasting removes the fractional part resulting in $y+1$. Hence, the result is rounding. 

If parentheses are ommitted in Listing~\ref{rounding}, then F\# will interpret the expression as \lstinline|(int a) + 0.5|, which is erroneous, since addition of an integer with a float is undefined. This is an example of precedence, i.e., typecasting takes precedence over addition meaning that it is performed before addition. Consider the arithmetic expression, whose result is bound to \lstinline|a| by
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 3 + 4 * 5;;

val a : int = 23
\end{lstlisting}
Here, the addition and multiplication functions are shown in \idx{infix notation} with the \idx{operator} tokens \token{+} and \token{*}. To arrive at the resulting value 23, F\# has to decide in which order to perform the calculation. There are 2 possible orders, \lstinline|3 + (4 * 5)| or \lstinline|(3 + 4) * 5|, which gives different results. For integer arithmetic, the correct order is of course to multiply before addition, and we say that multiplication takes \idx{precedence} over addition. Every atomic operation that F\# can perform is ordered in terms of its precedences, and for some common built-in operators shown in Table~\ref{tab:operatorPrecedence}, the precedence is shown by the order they are given in the table.
\begin{table}
  \centering
  \begin{tabularx}{\linewidth}{|l|l|l|X|}
    \hline
    Operator & Associativity & Example & Description\\
    \hline
    \lstinline|f x| & Left & \lstinline|f 3| & Function evaluation\\
    \lstinline|+op|, \lstinline|-op| & Left & \lstinline|-3| & Unary operator\\
    {\lstinline|&&|} & Left & {\lstinline|true && true|} & Boolean and\\
    \lstinline+||+ & Left & \lstinline+true || true+ & Boolean or\\
    \lstinline|op ** op| & Right & \lstinline| 3.0 ** 2.0| & Exponent\\ 
    \lstinline|op * op|, \lstinline|op / op|, \lstinline|op \% op| 
             & Left & \lstinline| 3.0 / 2.0| & Multiplication, division and remainder\\
    \lstinline|op + op|, \lstinline|op - op| & Left & \lstinline|3.0 + 2.0| & Addition and subtraction binary operators\\
    \hline
  \end{tabularx}
  \caption{Some common operators, their precedence, and their associativity. Rows are ordered from highest to lowest precedences, such that \lstinline|op * op| has higher precedence than \lstinline|op + op|. Operators in the same row has same precedence. }
  \label{tab:operatorPrecedence}
\end{table}
Associativity implies the order in which calculations are performed for operators of same precedence. For some operators and type combinations association matters little, e.g., multiplication associates to the left and exponentiation associates to the right, e.g., in
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 3.0*4.0*5.0
- let b = (3.0*4.0)*5.0
- let c = 3.0*(4.0*5.0);;

val a : float = 60.0
val b : float = 60.0
val c : float = 60.0

> let d = 4.0 ** 3.0 ** 2.0
- let e = (4.0 ** 3.0) ** 2.0
- let f = 4.0 ** (3.0 ** 2.0);;

val d : float = 262144.0
val e : float = 4096.0
val f : float = 262144.0
\end{lstlisting}
the expression for \lstinline|a| is interpreted as \lstinline|b| but gives the same results as \lstinline|c| since association does not matter for multiplication of numbers, but the expression for \lstinline|d| is interpreted as \lstinline|f| which is quite different from \lstinline|e|.

A less common notation is to define bindings for expressions using the \idx{\keyword{in}} keyword, e.g.,
%
\fs{numbersIn}{The name \lstinline!p! is only bound in the nested scope following the keyword \keyword{in}.}
%
Here \lstinline|p| is only bound in the \idx{scope} of the expression following the \keyword{in} keyword, in this the \lstinline|printfn| statement, and \lstinline|p| is unbound in lines that follows.
\begin{comment}
  Here the use of indentation to define a sequence of expressions
  % 
  \fs{numbersInWIndentation}{The name \lstinline!p! is only bound in the nested scope following the keyword \keyword{in}.}
  % 
\end{comment}

\section{Integers and Reals}
The set of integers and reals are infinitely large, and since all computers have limited resources, it is not possible to represent these sets in their entirety. The various integer and floating point types listed in Table~\ref{tab:primitiveTypes} are finite subset where the integer types have been reduced by limiting their ranges and the floating point types have been reduced by sampling the space of reals. An in-depth description of integer and floating point implementations can be found in Appendix~\ref{app:numbers}. The \keyword{int} and \keyword{float} are the most common types. 

For integers the following arithmetic operators are defined: 
\begin{description}
\item[\texttt{+op}, \texttt{-op}:] These are unary plus and minus operators, and plus has no effect, but minus changes the sign, e.g.,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 5       
- let b = -a;;

val a : int = 5
val b : int = -5
\end{lstlisting}
\item[\lstinline|op + op|, \lstinline|op - op|, \lstinline|op * op|:] These are binary operators, where addition, subtraction and multiplication performs the usual operations, 
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 7 + 3
- let b = 7 - 3
- let c = 7 * 3;;

val a : int = 10
val b : int = 4
val c : int = 21
\end{lstlisting}
\item[\lstinline|op / op|, \lstinline|op \% op|:] These are binary operators, and division performs integer division, where the fractional part is discarded after division, and the \lstinline|\%| is the remainder operator, which calculates the remainder after integer division,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 7 / 3
- let b = 7 % 3;;

val a : int = 2
val b : int = 1
\end{lstlisting}
Together integer division and remainder is a lossless representation of the original number as,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let x = 7
- let whole = x / 3
- let remainder = x % 3
- let y = whole * 3 + remainder;;

val x : int = 7
val whole : int = 2
val remainder : int = 1
val y : int = 7
\end{lstlisting}
And we see that \lstinline|x| and \lstinline|y| is bound to the same value.
\end{description}
Integer exponentiation is not defined as an operator, but this is available the built-in function \lstinline|pown|, e.g.,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> pown 2 5;;
val it : int = 32
\end{lstlisting}
which is equal to $2^5$. Note that when no let statement is used in conjunction with an expression then F\# automatically binds the result to the \idx{\lstinline{it}} name, i.e., the above is equal to
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
  > let it = pown 2 5;;

val it : int = 32
\end{lstlisting}
Rumor has it, that the name \lstinline|it| is an abreviation for 'irrelevant'.

Performing arithmetic operations on \keyword{int} types requires extra care, since the result may cause \idx{overflow}, \idx{underflow}, and even exceptions, e.g., the range of the integer type \lstinline|sbyte| is $[-128\ldots 127]$, which causes problems in the following example,
\begin{lstlisting}[language=fsharp,caption={fsharpi},label=overflow]
  > let a = 100y - let b = 30y - let c = a+b;;

val a : sbyte = 100y
val b : sbyte = 30y
val c : sbyte = -126y
\end{lstlisting}
Here $100+30=130$, which is larger than the biggest \lstinline|sbyte|, and the result is an overflow. Similarly, we get an underflow, when the arithmetic result falls below the smallest value storable in an \lstinline|sbyte|,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = -100y  
- let b = -30y  
- let c = a+b;;

val a : sbyte = -100y
val b : sbyte = -30y
val c : sbyte = 126y
\end{lstlisting}
Notice that neither overflow nor underflow error gave rise to an error message, which is why such bugs are difficult to find. 
 Dividing any non-zero number with 0 is infinite, which is also outside the domain of any of the integer types, but in this case, F\# casts an\idx{exception},
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> 3/0;; 
System.DivideByZeroException: Attempted to divide by zero.
  at <StartupCode$FSI_0007>.$FSI_0007.main@ () <0x6b78180 + 0x0000e> in <filename unknown>:0 
  at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
  at System.Reflection.MonoMethod.Invoke (System.Object obj, BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) <0x1a55ba0 + 0x000a1> in <filename unknown>:0 
Stopped due to error
\end{lstlisting}
The output looks daunting at first sight, but the first and last line of the error message are the most important parts, which tells us what exception was cast and why the program stopped. The middle are technical details concerning which part of the program caused this, and can be ignored for the time being. Exceptions are a type of \idx{run-time error}, and are treated in Chapter~\ref{chap:exceptions}

Integers can also be written in binary, octal, or hexadecimal format using the prefixes \lstinline|0b|, \lstinline|0o|, and \lstinline|0x|, e.g.,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 0b1011
- let b = 0o13
- let c = 0xb;;

val a : int = 11
val b : int = 11
val c : int = 11
\end{lstlisting}
For a description of binary representations see Appendix~\ref{sec:binary}. The overflow error in Listing~\ref{overflow} can be understood in terms of the binary representation of integers: In binary, $130=10000010_2$, and this binary pattern is interpreted differently as \lstinline{byte} and \lstinline{sbyte},
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 0b10000010uy
- let b = 0b10000010y;;

val a : byte = 130uy
val b : sbyte = -126y
\end{lstlisting}
That is, for signed bytes, the left-most bit is used to represent the sign, and since the addition of $100=01100100_2$ and $30=00011110_b$ is $130=10000010_2$ causes the left-most bit to be used, then this is wrongly interpreted as a negative number, when stored in an \lstinline{sbyte}.

For floating point numbers the following arithmetic operators are defined: 
\begin{description}
\item[\texttt{+op}, \texttt{-op}:] These are unary plus and minus operators, and plus has no effect, but minus changes the sign, e.g.,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 5.0 
- let b = -a;;

val a : float = 5.0
val b : float = -5.0
\end{lstlisting}
\item[\lstinline|op + op|, \lstinline|op - op|, \lstinline|op * op|, \lstinline|op / op|:] These are binary operators, where addition, subtraction, multiplication, and division performs the usual operations, 
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 7.0 + 3.0
- let b = 7.0 - 3.0
- let c = 7.0 * 3.0
- let d = 7.0 / 3.0;;

val a : float = 10.0
val b : float = 4.0
val c : float = 21.0
val d : float = 2.333333333
\end{lstlisting}
\item[\lstinline|op \% op|:] The binary remainder operator, and division performs integer division, where the fractional part is discarded after division, and the \lstinline|\%| is the remainder operator, which calculates the remainder after integer division,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 7.0 / 3.0
- let b = 7.0 % 3.0;;

val a : int = 2.0
val b : int = 1.0
\end{lstlisting}
The remainder for floating point numbers can be fractional, but division, rounding, and remainder is still a lossless representation of the original number as,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let x = 7.0
- let division = x / 3.2
- let whole = float (int (division + 0.5))
- let remainder = x % 3.2
- let y = whole * 3.2 + remainder;;

val x : float = 7.0
val division : float = 2.1875
val whole : float = 2.0
val remainder : float = 0.6
val y : float = 7.0
\end{lstlisting}
And we see that \lstinline|x| and \lstinline|y| is bound to the same value.  
\item[\texttt{op ** op}:] In spite of an unusual notation, the binary exponentiation operator performs the usual calculation,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 2.0 ** 5.0;;

val a : float = 32.0
\end{lstlisting}
which is equal to $2^5$.
\end{description}

Arithmetic using \lstinline|float| will not cause over- and underflow problems, since the IEEE 754 standard includes the special numbers $\pm\infty$ and NaN. E.g.,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 1.0/0.0  
- let b = 0.0/0.0;;

val a : float = infinity
val b : float = nan
\end{lstlisting}
However, the \lstinline|float| type has limite precision, since there is only a finite number of numbers that can be stored in a float. E.g.,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let a = 357.8      
- let b = a+0.1      
- let c = b+0.1      
- let d = c - 358.0;;

val a : float = 357.8
val b : float = 357.9
val c : float = 358.0
val d : float = 5.684341886e-14
\end{lstlisting}
Hence, although \lstinline|c| appears to be correctly calculated, by the subtraction we see, that the value bound in \lstinline|c| is not exactly the same as \lstinline|358.0|, and the reason is that the neither \lstinline|357.8| nor \lstinline|0.1| are exactly representable as a \lstinline|float|, which is why the repeated addition accumulates a small representation error.

\section{Booleans}
Boolean arithmatic is the basis of almost all computers and particularly important for controling program flow, which will be discussed in Chapter~\ref{chap:flow}. Boolean values are one of 2 possible values, true or false, which is also sometimes written as 1 and 0. Two basic operations on boolean values are '\idx{and}' often also written as multiplication, and '\idx{or}' often written as addition, and '\idx{not}' often written as a bar above the value. All possible combination of input on these values can be written on tabular form, known as a \idx{truth table}, shown in Table~\ref{tab:truthTable}.
\begin{table}
  \centering
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    $a$ & $b$ & $a\cdot b$& $a + b$&$\bar{a}$\\
    \hline
    0&0&0&0&1\\
    0&1&0&1&1\\
    1&0&0&1&0\\
    1&1&1&1&0\\
    \hline
  \end{tabular}
  \caption{Truth table for boolean 'and', 'or', and 'not' operators. Value 0 is false and 1 is true.}
  \label{tab:truthTable}
\end{table}
That is, the multiplication and addition are good mnemonics for remembering the result of the 'and' and 'or' operators. In F\# the values \lstinline|true| and \lstinline|false| are used, and the operators \lstinline|&&| for 'and', \lstinline+||+ for 'or', and the function \lstinline|not| for 'not', such that the above table is reproduced by,
\begin{lstlisting}[language=fsharp,caption={fsharpi}]
> let t = true
- let f = false
- printfn "a     b     a*b   a+b   not a"                                       
- printfn "%A %A %A %A %A" f f (f && f) (f || f) (not f)
- printfn "%A %A  %A %A  %A" f t (f && t) (f || t) (not f)
- printfn "%A  %A %A %A  %A" t f (t && f) (t || f) (not t)
- printfn "%A  %A  %A  %A  %A" t t (t && t) (t || t) (not t);;
a     b     a*b   a+b   not a
false false false false true
false true  false true  true
true  false false true  false
true  true  true  true  false

val t : bool = true
val f : bool = false
val it : unit = ()
\end{lstlisting}
Careful spacing in the format string of the \lstinline|printfn| function was used to align columns. Next section will discuss more elegant formatting options.

\section{Chars and Strings}
\dots

\section{Mutable bindings}
\label{sec:mutableValues}
The \keyword{mutable} in \keyword{let} bindings means that the name may be rebound to a new value using the following syntax,
\begin{lstlisting}[language=EBNF]
ident "<-" expr
\end{lstlisting}
\idx{Mutable data} is synonymous with the term \idx{variable}. A variable an area in the computers working memory associated with a name and a type, and this area may be read from and written to during program execution. For example,
\fs{mutableAssignReassing}{}
Here a area in memory was denoted \texttt{x}, declared as type integer and assigned a default value.  Later, this value of of \texttt{x} was replaced with another integer and yet another integer. The operator '\token|<-|' is used to distinguish the statement from the mathematical concept of equality. A short-hand for the above is available as,
\fs{mutableAssignReassingShort}{}
where the assignment of the default value was skipped, and the type was inferred from the assignment operation. However, it's important to note, that when the variable is declared, then the '\token|=|' operator must be used, while later reassignments must use the '\token|<-|'  operator. Type mismatches will result in an error, 
\fs{mutableAssignReassingTypeError}{}

A typical variable is a counter of type integer, and a typical use of counters is to increment them, i.e., erasing a new value to be one more that its previous value. For example,
\fs{mutableAssignIncrement}{}
An function that elegantly implements the incrementation operation may be constructed as,
\fs{mutableAssignIncrementEncapsulation}{}
\jon{Explain why this works!} Here the output of \texttt{incr} is an anonymous function, that takes no argument, increments the variable of \texttt{incr} and returns the new value of the counter. This construction is called \idx{encapsulation}, since the variable \texttt{counter} is hidden by the function \texttt{incr} from the user, i.e., the user need not be concerned with how the increment operator is implemented and the variable name used by \texttt{incr} does not clutter the scope where it is used.

Variables cannot be returned from functions, that is,
\fs{mutableAssignReturnValue}{}
declares a function that has no arguments and returns the value 0, while the same for a variable is illegal,
\fs{mutableAssignReturnVariable}{}
There is a workaround for this by using \idx{reference cells} by the build-in function \texttt{ref} and operators \token|!| and \token|:=|,
\fs{mutableAssignReturnRefCell}{}
That is, the \texttt{ref} function creates a reference variable, the '\token|!|' and the '\token|:=|' operators reads and writes its value. Reference cells are in some language called pointers, and their use is strongly discouraged, since they may cause \idx{side-effects}, which is the effect that one function changes the state of another, such as the following example demonstrates,
\fs{mutableAssignReturnSideEffect}{}
In the example, the function \texttt{updateFactor} changes a variable in the scope of \texttt{multiplyWithFactor}, which is prone to errors, since the style of programming does not follow the usual assignment syntax. Better style of programming is,
\fs{mutableAssignReturnWithoutSideEffect}{}
Here there can be no doubt in \texttt{multiplyWithFactor} that the value of '\texttt{a}' is changing. Side-effects do have their use, but should in general be avoided at almost all costs, and in general it is advised to refrain from using ref cells.


%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
