\chapter{Using F\# as a calculator}
\label{chap:calculator}
%\chapter{Numbers, Characters, and Strings}
\section{Literals and basic types}
All programs rely on processing of data, and an essential property of data is its \idx{type}. A \idx{literal} is a fixed value such as "3", and if we type the number \lstinline!3! in an interactive session at the input prompt, then F\# responds as follows,
%
\fso{firstType}{Typing the number 3.}
%
% \begin{lstlisting}[language=fsharp,caption={fsharpi, typing the number 3.}]
% > 3;;    
% val it : int = 3
% \end{lstlisting}
What this means is that F\# has inferred the type to be \idx{\lstinline{int}} and bound it to the identifier \idx{\lstinline{it}}. Rumor has it, that the identifier \lstinline|it| is an abbreviation for 'irrelevant'. For more on binding and identifiers see Chapter~\ref{chap:let}. Types matter, since the operations that can be performed on integers are quite different from those that can be performed on, e.g., strings. I.e.,
%
\fso{typeMatters}{Many representations of the number 3 but using different types.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, many representations of the number 3 but using different types.}]
% > 3;;    
% val it : int = 3
% > 3.0;;
% val it : float = 3.0
% > '3';;
% val it : char = '3'
% > "3";;
% val it : string = "3"
% \end{lstlisting}
%
Each literal represent the number 3, but their types are different, and hence they are quite different values. The types \lstinline!int! for integer numbers, \idx{\lstinline{float}} for floating point numbers, \idx{\lstinline{char}} for characters, and \idx{\lstinline{string}} for strings of characters are the most common types of literals. A table of all \idx{basic types} predefined in F\# is given in Table~\ref{tab:primitiveTypes}.\idxss{\lstinline{unit}}\idxss{\lstinline{obj}}\idxss{\lstinline{exn}}
\begin{table}
  \centering
  \begin{tabularx}{\textwidth}{|l|l|>{\raggedright\arraybackslash}X|}
    \hline
    Metatype & Type name & Description\\
    \hline
    Boolean & bool & Boolean values true or false \\
    \hline
    Integer & \textbf{int} & Integer values from -2,147,483,648 to 2,147,483,647 \\
             & byte &Integer values from 0 to 255\\
             & sbyte &Integer values from -128 to 127\\
             %& int8 &Synonymous with byte\\
            % & uint8 &Synonymous with sbyte\\
            % & int16 &Integer values from -32768 to 32767\\
            % & uint16 &Integer values from 0 to 65535\\
             & int32 &Synonymous with int\\
             & uint32 & Integer values from 0 to 4,294,967,295\\
             %& int64 &Integer values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\\
            % & uint64 &Integer values from 0 to 18,446,744,073,709,551,615\\
             %& bignum &Integer not limited to 64 bits\\
             %& nativeint &A native pointer as a signed integer\\
            % & unativeint &A native pointer as an unsigned integer\\
    \hline
    Real &\textbf{float} & 64-bit IEEE 754 floating point value from $-\infty$ to $\infty$\\
             & double & Synonymous with float\\
             %& single &A 32-bit floating point type\\
            % & float32 &Synonymous with single\\
            % & decimal &A floating point data type that has at least 28 significant digits\\
    \hline
    Character &\textbf{char} &Unicode character\\
             &\textbf{string} & Unicode sequence of characters\\
    \hline
    None &\textbf{unit} & No value denoted\\
    \hline
    Object &\textbf{obj} & An object\\
    \hline
    Exception &\textbf{exn} & An exception\\
    \hline
  \end{tabularx}
  \caption{List of some of the basic types. The most commonly used types are highlighted in bold. For at description of integer see Appendix~\ref{sec:binary}, for floating point numbers see Appendix~\ref{sec:floatingPoint}, for ASCII and Unicode characters see Appendix~\ref{sec:characterSets}, for objects see Chapter~\ref{chap:oop}, and for exceptions see Chapter~\ref{chap:exceptions}.}
  \label{tab:primitiveTypes}
\end{table}
Besides these built-in types, F\# is designed such that it is easy to define new types. 

Humans like to use the \idx{decimal number} system for representing numbers. Decimal numbers are \idx{base} 10 means that for a number consisting of a sequence of digits separated by a \idx{decimal point}, where each \idx{digit} can have values $d \in \{0,1,2,\ldots,9\}$, and the value, which each digit represents is proportional to its position. The part befor the decimal point is called the \idx{whole part} and the part after is called the \idx{fractional part} of the number. The whole part without a decimal point and a fractional part is called an \idx{integer number}. As an example \lstinline!35.7! is a decimal number, whose value is $3\cdot 10^1+5\cdot 10^0+7\cdot 10^{-1}$. In F\# a decimal number is called a \idx{floating point number} and in this text we use \idx{Extended Backus-Naur Form} (\idx{EBNF}) to describe the grammar of F\#, the decimal number just described is given as,
%
\begin{lstlisting}[language=ebnf]
dDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
dInt = dDigit {dDigit};
dFloat = dInt "." {dDigit};
\end{lstlisting}
%
meaning that a \lstinline[language=ebnf]!dDigit! is either "0'' or "1" or \dots or "9'', an \lstinline[language=ebnf]!dInt! is 1 or more \lstinline[language=ebnf]!dDigit!, and a \lstinline[language=ebnf]!dFloat! is 1 or more digits, a dot and 0 or more digits. There is no space between the digits and between digits and the dot. So \lstinline!3!, \lstinline!049! are examples of integers, \lstinline!34.89! \lstinline!3.! are examples of floats, while \lstinline!.5! is neither.  Floating point numbers may alternatively be given using \idx{scientific notation}, such as \lstinline!3.5e-4! and \lstinline!4e2!, which means the number $3.5\cdot 10^{-4} = 0.00035$ and $4\cdot 10^2=400$. To describe this in EBNF we write
%
\begin{lstlisting}[language=ebnf]
sFloat = (dInt | dFloat) ("e" | "E" ) ["+" | "-"] dInt;
float = dFloat | sFloat;
\end{lstlisting}
%
Note that the number before the lexeme \lexeme{e} may be an \lstinline[language=ebnf]!dInt! or a \lstinline[language=ebnf]!dFloat!, but the exponent value must be an \lstinline[language=ebnf]!dInt!.

The basic unit of information in almost all computers is the binary digit or \idx{bit} for short. A \idx{binary number} consists of a sequence of binary digits separated by a decimal point, where each digit can have values $b \in \{0,1\}$, and the base is $2$. E.g., the binary number $101.01_2 = 1\cdot 2^2+0\cdot 2^1+1\cdot 2^0+0\cdot 2^{-1}+1\cdot 2^1=5.25$. Binary numbers are closely related to \idx[octal number]{octal} and \idx[hexadecimal number]{hexadecimal numbers}, where octals uses 8 as basis and can be written in binary using 3 bits, while hexadecimal numbers uses 16 as basis and can be written in binary using 4 bits. Octals and hexadecimals thus conveniently serve as shorthand for the much longer binary representation. F\# has a syntax for writing integers on binary, octal, decimal, and hexadecimal numbers as,
%
\begin{lstlisting}[language=ebnf]
bDigit = "0" | "1";
oDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7";
xDigit =  
  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
  | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f";
dInt = dDigit {dDigit};
bitInt = "0" ("b" | "B") bDigit {bDigit};
octInt = "0" ("o" | "O") oDigit {oDigit};
hexInt = "0" ("x" | "X") xDigit {xDigit};
xInt = bitInt | octInt | hexInt;
int = dInt | xInt;
\end{lstlisting}
%
For example \lstinline!367! is an \lstinline[language=ebnf]!dInt!, \lstinline!0b101101111!, \lstinline!0o557!, and \lstinline!0x16f! is a \lstinline[language=ebnf]!bitInt!, \lstinline[language=ebnf]!octInt!, and \lstinline[language=ebnf]!hexInt!, i.e., a binary, an octal, and a hexadecimal number, they are examples of an \lstinline[language=ebnf]!xInt! and representations of the same number 367. In contrast, \lstinline!0b12! and \lstinline!ff! are neither an \lstinline[language=ebnf]!dInt! nor an \lstinline[language=ebnf]!xInt!.

A \idx{character} is a \idx{Unicode} \idx{code point}, and character literals are enclosed in single quotation marks, see Appendix~\ref{sec:unicode} for a description of code points.\spec{Spec-4.0 p.28: \texttt{char-char} is missing option \texttt{unicodegraph-long} } The EBNF for characters is,
%
\begin{lstlisting}[language=ebnf]
codePoint = ?Any unicode codepoint?;
escapeChar = 
  "\" ("b" | "n" | "r" | "t" | "\" | '"' | "'" | "a" | "f" | "v")
  | "\u" xDigit xDigit xDigit xDigit
  | "\U" xDigit xDigit xDigit xDigit xDigit xDigit xDigit xDigit
  | "\" dDigit dDigit dDigit;
char = "'" codePoint | escapeChar "'";
\end{lstlisting}
% 
where \lstinline[language=ebnf]!codePoint! is a UTF8 encoding of a char. The escape characters \lstinline[language=ebnf]{escapeChar} are special sequences that are interpreted as a single code point shown in Table~\ref{tab:escapeChar}. The trigraph \lstinline|\DDD| uses decimal specification for the first 256 code points, and the hexadecimal escape codes \lstinline|\uXXXX|, \lstinline|\UXXXXXXXX| allow for the full specification of any code point.
\begin{table}
  \centering
  \begin{tabular}{|c|l|l|}
    \hline
    Character& Escape sequence & Description\\
    \hline
    BS &\lstinline|\b|& Backspace\\
    LF &\lstinline|\n|&Line feed\\
    CR &\lstinline|\r|&Carriage return\\
    HT &\lstinline|\t|&Horizontal tabulation\\
    \textbackslash &\lstinline|\\|&Backslash\\
     " &\lstinline|\"|&Quotation mark\\
    ' &\lstinline|\'|&Apostrophe\\
    BEL&\lstinline|\a|& Bell\\
    FF&\lstinline|\f|&Form feed\\
    VT &\lstinline|\v|&Vertical tabulation\\
    &\lstinline|\uXXXX|, \lstinline|\UXXXXXXXX|, \lstinline|\DDD|&Unicode character\\
    \hline
  \end{tabular}
  \caption{Escape characters. For the unicode characters 'X' are hexadecimal digits, while for tricode characters 'D' is a decimal character.}
  \label{tab:escapeChar}
\end{table}
Examples of a \lstinline[language=ebnf]!char! are \lstinline{'a'}, \lstinline{'_'}, \lstinline{'\n'}, and \lstinline{'\065'}.

A \idx{string} is a sequence of characters enclosed in double quotation marks,\spec{Spec-4.0 p. 28-29: \texttt{simple-string-char} is undefined, \texttt{string-elem} is unused.}
%
\begin{lstlisting}[language=ebnf]
stringChar = char - '"';
string = '"' { stringChar }  '"';
verbatimString = '@"' {char - ('"' | '\"' )| '""'} '"';
\end{lstlisting}
% 
Examples are \lstinline{"a"}, \lstinline{"this is a string"}, and \lstinline{"-&#\@"}. \idx[newline]{Newlines} and following \idx[whitespace]{whitespaces},
\begin{lstlisting}[language=ebnf,label=newlineNWhitespace]
whitespace = " " {" "};
newline = "\n" | "\r" "\n";
\end{lstlisting}
are taken literally, but may be ignored by a preceding \textbackslash character. Further examples of strings are,
%
\fso{stringLiterals}{Examples of string literals.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, examples of string literals.}]
% > "abcde";;
% val it : string = "abcde"
% > "abc
% - de";;
% val it : string = "abc
% de"
% > "abc\
% -  de";;
% val it : string = "abcde"
% > "abc\nde";;
% val it : string = "abc
% de"
% \end{lstlisting}
%
The response is shown in double quotation marks, which are not part of the string. 

F\# supports \idx[literal type]{literal types}, where the type of a literal is indicated as a prefix og suffix as shown in the Table~\ref{tab:literalTypes}.\idxss{\lstinline{int32}}\idxss{\lstinline{uint32}}\idxss{\lstinline{byte}}\idxss{\lstinline{uint8}}\idxss{\lstinline{byte[]}}\idxss{\lstinline{sbyte}}\idxss{\lstinline{int8}}\idxss{\lstinline{int16}}\idxss{\lstinline{uint16}}\idxss{\lstinline{int64}}\idxss{\lstinline{uint64}}\idxss{\lstinline{bignum}}\idxss{\lstinline{nativeint}}\idxss{\lstinline{unativeint}}\idxss{\lstinline{double}}\idxss{\lstinline{single}}\idxss{\lstinline{float32}}\idxss{\lstinline{decimal}}
\begin{table}
  \centering
  %\begin{tabularx}{\linewidth}{|>{\hsize=.6\hsize}X|>{\hsize=1.4\hsize}X|>{\hsize=1\hsize}X|}
  \begin{tabular}{|l|l|l|}
    \hline
    type & EBNF & Examples \\
    \hline
    \lstinline!int!, \lstinline!int32! & \lstinline[language=ebnf]!(dInt | xInt) ["l"]!  & \lstinline!3! \\
    \lstinline!uint32! & \lstinline[language=ebnf]!(dInt | xInt) ("u" | "ul")! & \lstinline!3u! \\
    \lstinline!byte!, \lstinline!uint8! & \lstinline[language=ebnf]!((dInt | xInt) "uy") | (char "B")!  & \lstinline!3uy!  \\
    \lstinline!byte[]! & \lstinline[language=ebnf]!["@"] string "B"!  & \lstinline!"abc"B! and \lstinline!"@http:\\"B!  \\
    \lstinline!sbyte!, \lstinline!int8! & \lstinline[language=ebnf]!(dInt | xInt) "y"! & \lstinline!3y!  \\
    %\lstinline!int16! & \lstinline[language=ebnf]!(dInt | xInt) "s"!  & \lstinline!3s!  \\
    %\lstinline!uint16! & \lstinline[language=ebnf]!(dInt | xInt) "us"! & \lstinline!3us!  \\
    %\lstinline!int64! & \lstinline[language=ebnf]!(dInt | xInt) "L"!  & \lstinline!3L!  \\
    %\lstinline!uint64! & \lstinline[language=ebnf]!(dInt | xInt) ("UL" | "uL")!  & \lstinline!3UL! and \lstinline!3uL!  \\
    %\lstinline!bignum!$^*$ & \lstinline[language=ebnf]!dInt "I"! & \lstinline!3I!  \\
    %\lstinline!nativeint! & \lstinline[language=ebnf]!(dInt | xInt) "n"! & \lstinline!3n!  \\
    %\lstinline!unativeint! & \lstinline[language=ebnf]!(dInt | xInt) "un"!  & \lstinline!3un!  \\
    \lstinline!float!, \lstinline!double! & \lstinline[language=ebnf]!float | (xInt "LF")!  & \lstinline!3.0!  \\
    %\lstinline!single!, \lstinline!float32! & \lstinline[language=ebnf]!(float ("F" | "f")) | (xInt "lf") !  & \lstinline!3.0f!  \\
    %\lstinline!decimal! &\lstinline[language=ebnf]!(float | dInt) ("M" | "m")! & \lstinline!3.0m! and \lstinline!3m!  \\
    \lstinline!string! & \lstinline[language=ebnf]!simpleString |! & \lstinline!"a \"quote\".\n"!  \\
         & \lstinline[language=ebnf]!'@"' {(char - ('"' | '\"' )) | '""'} '"' |!&\lstinline!@"a ""quote"".\n"! \\
        % & \lstinline[language=ebnf]!'""' {char} '""' (*no '"""' substring*)! & \lstinline!"""a "quote".\n"""!  \\
    \hline
  \end{tabular}
  % \end{tabularx}
  \caption{List of literal type. No spacing is allowed between the literal and the prefix or suffix. 
    % The \lstinline![]! notation is for lists, see Chapter~\ref{chap:lists}. $^*$\lstinline[language=ebnf]!bignum! is not a basic type and does not yet have an implementation for \lstinline[language=ebnf]!dInt ("Q"|"R"|"Z"|"N"|"G")! in Mono.
  }
  \label{tab:literalTypes}
\end{table}
Examples are,
\fso{namedLiterals}{Named and implied literals.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, Named and implied literals.}]
% > 3;;
% val it : int = 3
% > 4u;; 
% val it : uint32 = 4u
% > 5.6;;
% val it : float = 5.6
% > 7.9f;;
% val it : float32 = 7.9000001f
% > 'A';;
% val it : char = 'A'
% > 'B'B;;
% val it : byte = 66uy
% > "ABC";;
% val it : string = "ABC"
% \end{lstlisting}
%
Strings literals may be \idx{verbatim} by the @-notation% or triple double quotation marks,
meaning that the escape sequences are not converted to their code point., e.g.,
%
\fso{stringVerbatim}{Examples of a string literal.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, examples of string literals.}]
% > @"abc\nde";;
% val it : string = "abc\nde"
% \end{lstlisting}
%
%For strings containing double quotation marks, verbatim literals has 2 possible notations, either use the @-notation and escaping double quotation marks with an extra double quotation mark, or use triple double quotation marks. \advice{The triple double quotation marks notation may not contain substrings that are triple double quotation marks, and thus @-notation is preferred.}

Many basic types are compatible and the type of a literal may be changed by \idx{type casting}. E.g.,
%
\fso{upcasting}{Casting an integer to a floating point number.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, casting an integer to a floating point number.},label=upcasting]
% > float 3;;
% val it : float = 3.0
% \end{lstlisting}
which is a \lstinline!float!, since when \lstinline|float| is given an argument, then it acts as a function rather than a type, and for the integer \lstinline|3| it returns the floating point number \lstinline|3.0|.  For more on functions see Chapter~\ref{chap:let}. Boolean values are often treated as the integer values 0 and 1, but no short-hand function names exists for their conversions. Instead use,
%
\fso{castingBooleans}{Casting booleans.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, casting booleans.}]
% > System.Convert.ToBoolean 1;;
% val it : bool = true
% > System.Convert.ToBoolean 0;;
% val it : bool = false
% > System.Convert.ToInt32 true;;
% val it : int = 1
% > System.Convert.ToInt32 false;;
% val it : int = 0
% \end{lstlisting}
Here \lstinline|System.Convert.ToBoolean| is the identifier of a function \lstinline|ToBoolean|, which is a \idx{member} of the \idx{class} \lstinline|Convert| that is included in the \idx{namespace} \lstinline|System|. Namespaces, classes, and members are all part of Structured programming to be discussed in Part~\ref{part:structured}.

Type casting is often a destructive operation, e.g., type casting a \lstinline{float} to \lstinline{int} removes the fractional part without rounding,
%
\fso{downcasting}{Fractional part is removed by downcasting.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, Fractional part is removed by downcasting.}]
% > int 357.6;;
% val it : int = 357
% \end{lstlisting}
%%\fs{quickStartDownCast}{Fractional part is removed by downcasting.}
%%
Here we type casted to a lesser type, in the sense that integers is a subset of floating point numbers, and this is called \idx{downcasting}. The opposite is called \idx{upcasting} and is often non-destructive, as Listing~\ref{upcasting} showed, where an integer was casted to a float while retaining its value. As a side note, \idx{rounding} a number $y.x$, where $y$ is the \idx{whole part} and $x$ is the \idx{fractional part}, is the operation of mapping numbers in the interval $y.x \in [y.0,y.5)$ to $y$ and $y.x\in [y.5,y+1)$ to $y+1$. This can be performed by downcasting as follows,
%
\fso{rounding}{Fractional part is removed by downcasting.}
% \begin{lstlisting}[language=fsharp,label=rounding,caption={fsharpi, Fractional part is removed by downcasting.}]
% > int (357.6 + 0.5);;
% val it : int = 358
% \end{lstlisting}
% %\fs{rounding}{The rounding function may be obtained by downcasting.}
%
since if $y.x\in [y.0, y.5)$, then $y.x+0.5\in [y.5, y+1)$, from which downcasting removes the fractional part resulting in $y$. And if $y.x\in [y.5, y+1)$, then $y.x+0.5\in [y+1,y+1.5)$, from which downcasting removes the fractional part resulting in $y+1$. Hence, the result is rounding. 

\section{Operators on basic types}
Listing~\ref{rounding} is an example of an arithmetic \idx{expression} using an \idx{infix operator}. Expressions is the basic building block of all F\# programs, and its grammar has many possible options. The grammar for expressions are defined recursively, and some of it is given by, \spec{Spec-4.0 Section 4.3: const is missing uint8, int8 nativeint, unativeint.}
%
\begin{lstlisting}[language=ebnf,caption=expressionArithmetic]
const =
  byte
  | sbyte
  | int32
  | uint32 
  | int
  | ieee64 
  | char
  | string
  | verbatimString
  | "false"
  | "true"
  | "()";
sliceRange = 
  expr 
  | expr ".." (*no space between expr and ".."*)
  | ".." expr (*no space between expr and ".."*)
  | expr ".." expr (*no space between expr and ".."*)
  | "*";
expr = ...
  | const (*a const value*)
  | "(" expr ")" (*block*)
  | expr expr (*application*)
  | expr infixOp expr (*infix application*)
  | prefixOp expr (*prefix application*)
  | expr ".[" expr "]" (*index lookup, no space before "."*)
  | expr ".[" sliceRange "]" (*index lookup, no space before "."*)
\end{lstlisting}
%
Recursion means that a rule or a function is used by the rule or function itself in its definition. See Part~\ref{part:declarative} for more on recursion. Infix notation means that the \idx{operator} \lstinline[language=ebnf]!op! appears between the two \idx{operands}, and since there are 2 operands, it is a \idx{binary operator}. As the grammar shows, the operands themselves can be expressions. Examples are \lstinline!3+4! and \lstinline!4+5+6!. Some operators only takes one operand, e.g., \lstinline!-3!, where \lstinline!-! here is used to negate a postive integer. Since the operator appears before the operand it is a \idx{prefix operator}, and since it only takes one argument it is also a \idx{unary operator}. Finally, some expressions are function names, which can be applied to expressions. F\# supports a range of arithmetic infix and prefix operators on its built-in types shown in Table~\ref{tab:preNInfixOperators} and~\ref{tab:comparisonOperators} and a range of mathematical functions shown in Table~\ref{tab:arithmeticFunctions}.\idxss{\lstinline{abs}}\idxss{\lstinline{acos}}\idxss{\lstinline{asin}}\idxss{\lstinline{atan}}\idxss{\lstinline{atan2}}\idxss{\lstinline{ceil}}\idxss{\lstinline{cos}}\idxss{\lstinline{cosh}}\idxss{\lstinline{exp}}\idxss{\lstinline{floor}}\idxss{\lstinline{log}}\idxss{\lstinline{log10}}\idxss{\lstinline{max}}\idxss{\lstinline{min}}\idxss{\lstinline{pown}}\idxss{\lstinline{round}}\idxss{\lstinline{sign}}\idxss{\lstinline{sin}}\idxss{\lstinline{sinh}}\idxss{\lstinline{sqrt}}\idxss{\lstinline{tan}}\idxss{\lstinline{tanh}}
\begin{table}
  \centering
  \begin{tabularx}{\linewidth}{|l|l|l|l|l|X|}
    \hline
    Operator & \lstinline!op1! & \lstinline!op2! & Expression & Result &Description\\
    \hline
    \lstinline!op1 + op2!&ints & ints & \lstinline!5 + 2!&\lstinline!7!&Addition\\
             &floats & floats & \lstinline!5.0 + 2.0!&\lstinline!7.0!&\\
             &chars & chars & \lstinline!'a' + 'b'!&\lstinline!'\\195'!&Addition of codes\\
             &strings & strings & \lstinline!"ab" + "cd"!&\lstinline!"abcd"!&Concatenation\\
    \hline
    \lstinline!op1 - op2!&ints & ints & \lstinline!5 - 2!&\lstinline!3!&Subtraction\\
             &floats & floats & \lstinline!5.0 - 2.0!&\lstinline!3.0!&\\
    \hline
    \lstinline!op1 * op2!&ints & ints & \lstinline!5 * 2!&\lstinline!10!&Multiplication\\
             &floats & floats & \lstinline!5.0 * 2.0!&\lstinline!10.0!&\\
    \hline
    \lstinline!op1 / op2!&ints & ints & \lstinline!5 / 2!&\lstinline!2!&Integer division\\
             &floats & floats & \lstinline!5.0 / 2.0!&\lstinline!2.5!&Division\\
    \hline
    \lstinline!op1 \% op2!&ints & ints & \lstinline!5 \% 2!&\lstinline!1!&Remainder\\
             &floats & floats & \lstinline!5.0 \% 2.0!&\lstinline!1.0!&\\
    \hline
    \lstinline!op1 ** op2!&floats & floats & \lstinline!5.0 ** 2.0!&\lstinline!25.0!&Exponentiation\\
    \hline
    \lstinline!op1 \&\& op2!&bool & bool & \lstinline!true \&\& false!&\lstinline!false!&boolean and\\
    \hline
    \lstinline!op1 || op2!&bool & bool & \lstinline!true || false!&\lstinline!false!&boolean or\\
    \hline
    \lstinline!op1 \&\&\& op2!&ints & ints & \lstinline!0b1010 \&\&\& 0b1100!&\lstinline!0b1000!&bitwise bool and\\
    \hline
    \lstinline!op1 ||| op2!&ints & ints & \lstinline!0b1010 ||| 0b1100!&\lstinline!0b1110!&bitwise boolean or\\
    \hline
    \lstinline!op1 \^\^\^ op2!&ints & ints & \lstinline!0b1010 \^\^\^ 0b1101!&\lstinline!0b0111!&bitwise boolean exclusive or\\
    \hline
     \lstinline!op1 <<< op2!&ints & ints & \lstinline!0b00001100uy <<< 2!&\lstinline!0b00110000uy!&bitwise shift left\\
     \hline
     \lstinline!op1 >>> op2!&ints & ints & \lstinline!0b00001100uy >>> 2!&\lstinline!0b00000011uy!&bitwise and\\
     \hline
    \lstinline!+op1!&ints&&\lstinline!+3!&\lstinline!3!&identity\\
             &floats&&\lstinline!+3.0!&\lstinline!3.0!&\\
    \hline
    \lstinline!-op1!&ints&&\lstinline!-3!&\lstinline!-3!&negation\\
             &floats&&\lstinline!-3.0!&\lstinline!-3.0!&\\
    \hline
    \lstinline!not op1!&bool&&\lstinline!not true!&\lstinline!false!&boolean negation\\
    \hline
    \lstinline!\~\~\~op1!&ints&&\lstinline!\~\~\~0b00001100uy!&\lstinline!0b11110011uy!&bitwise boolean negation\\
    \hline
  \end{tabularx}
  \caption{Arithmetic operators on basic types. Ints, floats, chars, and strings means all built-in integer types etc.. Note that for the bitwise operations, digits \lstinline{0} and \lstinline{1} are taken to be \lstinline{true} and \lstinline{false}.}
  \label{tab:preNInfixOperators}
\end{table}
\begin{table}
  \centering
  \begin{tabularx}{\linewidth}{|l|l|l|l|l|X|}
    \hline
    Operator & \lstinline!op1! & \lstinline!op2! & Expression & Result &Description\\
    \hline
    \lstinline!op1 < op2!&bool & bool & \lstinline!true < false!&\lstinline!false!&Less than\\
             &ints & ints & \lstinline!5 < 2!&\lstinline!false!&\\
             &floats & floats & \lstinline!5.0 < 2.0!&\lstinline!false!&\\
             &chars & chars & \lstinline!'a' < 'b'!&\lstinline!true!&\\
             &strings & strings & \lstinline!"ab" < "cd"!&\lstinline!true!&\\
    \hline
    \lstinline!op1 > op2!&bool & bool & \lstinline!true > false!&\lstinline!true!&Greater than\\
             &ints & ints & \lstinline!5 > 2!&\lstinline!true!&\\
             &floats & floats & \lstinline!5.0 > 2.0!&\lstinline!true!&\\
             &chars & chars & \lstinline!'a' > 'b'!&\lstinline!false!&\\
             &strings & strings & \lstinline!"ab" > "cd"!&\lstinline!false!&\\
    \hline
    \lstinline!op1 = op2!&bool & bool & \lstinline!true = false!&\lstinline!false!&Equal\\
             &ints & ints & \lstinline!5 = 2!&\lstinline!false!&\\
             &floats & floats & \lstinline!5.0 = 2.0!&\lstinline!false!&\\
             &chars & chars & \lstinline!'a' = 'b'!&\lstinline!false!&\\
             &strings & strings & \lstinline!"ab" = "cd"!&\lstinline!false!&\\
    \hline
    \lstinline!op1 <= op2!&bool & bool & \lstinline!true <= false!&\lstinline!false!&Less than or equal\\
             &ints & ints & \lstinline!5 <= 2!&\lstinline!false!&\\
             &floats & floats & \lstinline!5.0 <= 2.0!&\lstinline!false!&\\
             &chars & chars & \lstinline!'a' <= 'b'!&\lstinline!true!&\\
             &strings & strings & \lstinline!"ab" <= "cd"!&\lstinline!true!&\\
    \hline
    \lstinline!op1 >= op2!&bool & bool & \lstinline!true >= false!&\lstinline!true!&Greater than or equal\\
             &ints & ints & \lstinline!5 >= 2!&\lstinline!true!&\\
             &floats & floats & \lstinline!5.0 >= 2.0!&\lstinline!true!&\\
             &chars & chars & \lstinline!'a' >= 'b'!&\lstinline!false!&\\
             &strings & strings & \lstinline!"ab" >= "cd"!&\lstinline!false!&\\
    \hline
    \lstinline!op1 <> op2!&bool & bool & \lstinline!true <> false!&\lstinline!true!&Not Equal\\
             &ints & ints & \lstinline!5 <> 2!&\lstinline!true!&\\
             &floats & floats & \lstinline!5.0 <> 2.0!&\lstinline!true!&\\
             &chars & chars & \lstinline!'a' <> 'b'!&\lstinline!true!&\\
             &strings & strings & \lstinline!"ab" <> "cd"!&\lstinline!true!&\\
    \hline
  \end{tabularx}
  \caption{Comparison operators on basic types. Ints, floats, chars, and strings means all built-in integer types etc..}
  \label{tab:comparisonOperators}
\end{table}
\begin{table}
  \centering
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    Type & Function name & Example & Result & Description\\
    \hline
    Ints and floats & \lstinline!abs! & \lstinline!abs -3! & \lstinline!3! & Absolute value\\
    \hline 
    Floats & \lstinline!acos! & \lstinline!acos 0.8! & \lstinline!0.6435011088! & Inverse cosine\\
    \hline 
    Floats & \lstinline!asin! & \lstinline!asin 0.8! & \lstinline!0.927295218! & Inverse sinus\\
    \hline 
    Floats & \lstinline!atan! & \lstinline!atan 0.8! & \lstinline!0.6747409422! & Inverse tangent\\
    \hline 
    Floats & \lstinline!atan2! & \lstinline!atan2 0.8 2.3! & \lstinline!0.3347368373! & Inverse tangentvariant\\
    \hline 
    Floats & \lstinline!ceil! & \lstinline!ceil 0.8! & \lstinline!1.0! & Ceiling\\
    \hline 
    Floats & \lstinline!cos! & \lstinline!cos 0.8! & \lstinline!0.6967067093! & Cosine\\
    \hline 
    Floats & \lstinline!cosh! & \lstinline!cosh 0.8! & \lstinline!1.337434946! & Hyperbolic cosine\\
    \hline 
    Floats & \lstinline!exp! & \lstinline!exp 0.8! & \lstinline!2.225540928! & Natural exponent\\
    \hline 
    Floats & \lstinline!floor! & \lstinline!floor 0.8! & \lstinline!0.0! & Floor\\
    \hline 
    Floats & \lstinline!log! & \lstinline!log 0.8! & \lstinline!-0.2231435513! & Natural logarithm\\
    \hline 
    Floats & \lstinline!log10! & \lstinline!log10 0.8! & \lstinline!-0.09691001301! & Base-10 logarithm\\
    \hline 
    \begin{minipage}[t]{0.175\linewidth}Ints, floats,\\chars, and strings\end{minipage} & \lstinline!max! & \lstinline!max 3.0 4.0! & \lstinline!4.0! & Maximum\\
    \hline 
    \begin{minipage}[t]{0.175\linewidth}Ints, floats,\\chars, and strings\end{minipage} & \lstinline!min! & \lstinline!min 3.0 4.0! & \lstinline!3.0! & Minimum\\
    \hline 
    Ints & \lstinline!pown! & \lstinline!pown 3 2! & \lstinline!9! & Integer exponent\\
    \hline 
    Floats & \lstinline!round! & \lstinline!round 0.8! & \lstinline!1.0! & Rounding\\
    \hline 
    Ints and floats & \lstinline!sign! & \lstinline!sign -3! & \lstinline!-1! & Sign\\
    \hline 
    Floats & \lstinline!sin! & \lstinline!sin 0.8! & \lstinline!0.7173560909! & Sinus\\
    \hline 
    Floats & \lstinline!sinh! & \lstinline!sinh 0.8! & \lstinline!0.8881059822! & Hyperbolic sinus\\
    \hline 
    Floats & \lstinline!sqrt! & \lstinline!sqrt 0.8! & \lstinline!0.894427191! & Square root\\
    \hline 
    Floats & \lstinline!tan! & \lstinline!tan 0.8! & \lstinline!1.029638557! & Tangent\\
    \hline 
    Floats & \lstinline!tanh! & \lstinline!tanh 0.8! & \lstinline!0.6640367703! & Hyperbolic tangent\\
    \hline 
  \end{tabular}
  \caption{Predefined functions for arithmetic operations}
  \label{tab:arithmeticFunctions}
\end{table}
Arithmetic on various types will be discussed in detail in the following sections. \jon{minor comment on indexing and slice-ranges.}

If parentheses are omitted in Listing~\ref{rounding}, then F\# will interpret the expression as \lstinline|(int 357.6) + 0.5|, which is erroneous, since addition of an integer with a float is undefined. This is an example of precedence, i.e., function evaluation takes precedence over addition meaning that it is performed before addition. Consider the arithmetic expression, whose result is bound to \lstinline|a| by
%
\fso{simpleArithmetic}{A simple arithmetic expression.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, a simple arithmetic expression.}]
% > 3 + 4 * 5;;
% val it : int = 23
% \end{lstlisting}
Here, the addition and multiplication functions are shown in \idx{infix notation} with the \idx{operator} lexemes \lexeme{+} and \lexeme{*}. To arrive at the resulting value 23, F\# has to decide in which order to perform the calculation. There are 2 possible orders, \lstinline|3 + (4 * 5)| or \lstinline|(3 + 4) * 5|, which gives different results. For integer arithmetic, the correct order is of course to multiply before addition, and we say that multiplication takes \idx{precedence} over addition. Every atomic operation that F\# can perform is ordered in terms of its precedences, and for some common built-in operators shown in Table~\ref{tab:someOperatorPrecedences}, the precedence is shown by the order they are given in the table.\idxs{boolean or}\idxs{boolean and}
\begin{table}
  \centering
  \begin{tabularx}{\linewidth}{|>{\hsize=.5\hsize\raggedright\arraybackslash}X|>{\hsize=.5\hsize}X|>{\hsize=2\hsize}X|}
    \hline
    Operator & Associativity & Description\\
    \hline
    \mbox{\lstinline|+op|,} \mbox{\lstinline|-op|,} \mbox{\lstinline|\~\~\~op|} & Left & Unary identity, negation, and bitwise negation operator\\
    \hline
    \lstinline|f x| & Left & Function application\\
    \hline
    \lstinline|op ** op| & Right & Exponent\\ 
    \hline
    \mbox{\lstinline|op * op|,} \mbox{\lstinline|op / op|,} \mbox{\lstinline|op \% op|} & Left & Multiplication, division and remainder\\
    \hline
    \mbox{\lstinline|op + op|,} \mbox{\lstinline|op - op|} & Left & Addition and subtraction binary operators\\
    \hline
    \lstinline|op \^\^\^ op| & Right & bitwise exclusive or\\
    \hline
    \mbox{\lstinline|op < op|,} \mbox{\lstinline|op <= op|,} \mbox{\lstinline|op > op|,} \mbox{\lstinline|op >= op|,} \mbox{\lstinline|op = op|,} \mbox{\lstinline|op <> op|,} \mbox{\lstinline|op <<< op|,} \mbox{\lstinline|op >>> op|,} \mbox{\lstinline|op \&\&\& op|,} \mbox{\lstinline!op ||| op!,}
             & Left & Comparison operators, bitwise shift, and bitwise 'and' and 'or'.\\
    \hline
    \lstinline|\&\&| & Left & Boolean and\\
    \hline
    \lstinline+||+ & Left & Boolean or\\
    \hline
  \end{tabularx}
  \caption{Some common operators, their precedence, and their associativity. Rows are ordered from highest to lowest precedences, such that \lstinline|op * op| has higher precedence than \lstinline|op + op|. Operators in the same row has same precedence. Full table is given in Table~\ref{tab:operatorPrecedence}.}
  \label{tab:someOperatorPrecedences}
\end{table}
Associativity implies the order in which calculations are performed for operators of same precedence. For some operators and type combinations association matters little, e.g., multiplication associates to the left and exponentiation associates to the right, e.g., in\spec{Spec-4.0, Table 18.2.1 appears to be missing boolean 'and' and 'or' operations. Section 4.4 seems to be missing \&\&\& and ||| bitwise operators.}
%
\fso{precedence}{Precedences rules define implicite parentheses.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, precedences rules define implicite parentheses.}]
% > let a = 3.0*4.0*5.0
% - let b = (3.0*4.0)*5.0
% - let c = 3.0*(4.0*5.0);;
%
% val a : float = 60.0
% val b : float = 60.0
% val c : float = 60.0
%
% > let d = 4.0 ** 3.0 ** 2.0
% - let e = (4.0 ** 3.0) ** 2.0
% - let f = 4.0 ** (3.0 ** 2.0);;
%
% val d : float = 262144.0
% val e : float = 4096.0
% val f : float = 262144.0
% \end{lstlisting}
the expression for \lstinline|3.0 * 4.0 * 5.0| associates to the left, and thus is interpreted as \mbox{\lstinline|(3.0 * 4.0) * 5.0|,} but gives the same results as \lstinline|3.0 * (4.0 * 5.0)|, since association does not matter for multiplication of numbers. However, the expression for \lstinline|4.0 ** 3.0 ** 2.0| associates to the right, and thus is interpreted as \lstinline|4.0 ** (3.0 ** 2.0)|, which is quite different from \lstinline|(4.0 ** 3.0) ** 2.0|. \advice{Whenever in doubt of association or any other basic semantic rules, it is a good idea to use parentheses as here. It is also a good idea to test your understanding of the syntax and semantic rules by simplest possible scripts, as shown here as well.}

\section{Boolean arithmetic}
Boolean arithmetic is the basis of almost all computers and particularly important for controlling program flow, which will be discussed in Chapter~\ref{chap:flow}. Boolean values are one of 2 possible values, true or false, which is also sometimes written as 1 and 0. Two basic operations on boolean values are '\idx{and}' often also written as multiplication, and '\idx{or}' often written as addition, and '\idx{not}' often written as a bar above the value. All possible combination of input on these values can be written on tabular form, known as a \idx{truth table}, shown in Table~\ref{tab:truthTable}.
\begin{table}
  \centering
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    $a$ & $b$ & $a\cdot b$& $a + b$&$\bar{a}$\\
    \hline
    0&0&0&0&1\\
    0&1&0&1&1\\
    1&0&0&1&0\\
    1&1&1&1&0\\
    \hline
  \end{tabular}
  \caption{Truth table for boolean 'and', 'or', and 'not' operators. Value 0 is false and 1 is true.}
  \label{tab:truthTable}
\end{table}
That is, the multiplication and addition are good mnemonics for remembering the result of the 'and' and 'or' operators. In F\# the values \lstinline|true| and \lstinline|false| are used, and the operators \lstinline|&&| for 'and', \lstinline+||+ for 'or', and the function \lstinline|not| for 'not', such that the above table is reproduced by,
%
\fso{truthTable}{Boolean operators and truth tables.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, boolean operators and truth tables.}]
% > let t = true
% - let f = false
% - printfn "a     b     a*b   a+b   not a"                                       
% - printfn "%A %A %A %A %A" f f (f && f) (f || f) (not f)
% - printfn "%A %A  %A %A  %A" f t (f && t) (f || t) (not f)
% - printfn "%A  %A %A %A  %A" t f (t && f) (t || f) (not t)
% - printfn "%A  %A  %A  %A  %A" t t (t && t) (t || t) (not t);;
% a     b     a*b   a+b   not a
% false false false false true
% false true  false true  true
% true  false false true  false
% true  true  true  true  false
%
% val t : bool = true
% val f : bool = false
% val it : unit = ()
% \end{lstlisting}
%
Spacing produced using the \lstinline|printfn| function is not elegant. In Section~\ref{sec:printf} we will discuss better options for producing more beautiful output. Notice, that the arguments for \lstinline|printfn| was given on the next line with indentation. Generally, F\# ignores newlines and whitespaces except when using the ligthweight syntax discussed in Chapter~\ref{chap:let}.

\section{Integer arithmetic}
The set of integers is infinitely large, but since all computers have limited resources, it is not possible to represent it in their entirety. The various integer types listed in Table~\ref{tab:primitiveTypes} are finite subset reduced by limiting their ranges. Although \lstinline!bignum! is theoretically unlimited, the biggest number representable is still limited by computer memory. An in-depth description of integer implementation can be found in Appendix~\ref{app:numbers}. The type \keyword{int} is the most common type. 

Table~\ref{tab:preNInfixOperators}, \ref{tab:comparisonOperators}, and~\ref{tab:arithmeticFunctions} gives examples operators and functions pre-defined for integer types. Notice that fewer functions are available for integers than for floating point numbers. For most addition, subtraction, multiplication, and negation the result straight forward. However, performing arithmetic operations on integers requires extra care, since the result since they may cause \idx{overflow}, \idx{underflow}, e.g., the range of the integer type \lstinline|sbyte| is $[-128\ldots 127]$, which causes problems in the following example,
%
\fso{overflow}{Adding integers may cause overflow.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, adding integers may cause overflow.},label=overflow]
% > let a = 100y 
% - let b = 30y 
% - let c = a+b;;
%
% val a : sbyte = 100y
% val b : sbyte = 30y
% val c : sbyte = -126y
% \end{lstlisting}
%
Here $100+30=130$, which is larger than the biggest \lstinline|sbyte|, and the result is an overflow. Similarly, we get an underflow, when the arithmetic result falls below the smallest value storable in an \lstinline|sbyte|,
%
\fso{underflow}{Subtracting integers may cause underflow.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, subtracting integers may cause underflow}]
% > let a = -100y  
% - let b = -30y  
% - let c = a+b;;
%
% val a : sbyte = -100y
% val b : sbyte = -30y
% val c : sbyte = 126y
% \end{lstlisting}
%
I.e., we were expecting a negative number, but got a postive number instead.
%Integers can also be written in binary, octal, or hexadecimal format using the prefixes \lstinline|0b|, \lstinline|0o|, and \lstinline|0x|, e.g.,
%
% \begin{lstlisting}[language=fsharp,caption={fsharpi, integer types may be specified as binary, octal, and hexadecimal numbers.}]
% > let a = 0b1011
% - let b = 0o13
% - let c = 0xb;;

% val a : int = 11
% val b : int = 11
% val c : int = 11
% \end{lstlisting}
% For a description of binary representations see Appendix~\ref{sec:binary}. 

The overflow error in Listing~\ref{overflow} can be understood in terms of the binary representation of integers: In binary, $130=10000010_2$, and this binary pattern is interpreted differently as \lstinline{byte} and \lstinline{sbyte},
%
\fso{overflowBits}{The left most bit is interpreted differently for signed and unsigned integers, which gives rise to potential overflow errors.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, the left most bit is interpreted differently for signed and unsigned integers, which gives rise to potential overflow errors.}]
% > let a = 0b10000010uy
% - let b = 0b10000010y;;
%
% val a : byte = 130uy
% val b : sbyte = -126y
% \end{lstlisting}
%
That is, for signed bytes, the left-most bit is used to represent the sign, and since the addition of $100=01100100_2$ and $30=00011110_b$ is $130=10000010_2$ causes the left-most bit to be used, then this is wrongly interpreted as a negative number, when stored in an \lstinline{sbyte}. Similar arguments can be made explaining underflows.

The division and remainder operators \idx{integer division}, which discards the fractional part after division, and the \idx{remainder} operator calculates the remainder after integer division, e.g.,
%
\fso{integerDivisionRemainder}{Integer division and remainder operators.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, binary integer division and remainder operators.}]
% > let a = 7 / 3
% - let b = 7 % 3;;

% val a : int = 2
% val b : int = 1
% \end{lstlisting}
%
Together integer division and remainder is a lossless representation of the original number as,
%
\fso{integerDivisionRemainderLossless}{Integer division and remainder is a lossless representation of an integer, compare with Listing~\ref{integerDivisionRemainder}.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, binary division and remainder is a lossless representation of an integer.}]
% > let x = 7
% - let whole = x / 3
% - let remainder = x % 3
% - let y = whole * 3 + remainder;;

% val x : int = 7
% val whole : int = 2
% val remainder : int = 1
% val y : int = 7
% \end{lstlisting}
%
And we see that integer division of 7 by 3 followed by multiplication by 3 is less that 7, and the difference is \lstinline!7 % 3!.

Notice that neither overflow nor underflow error gave rise to an error message, which is why such bugs are difficult to find. 
 Dividing any non-zero number with 0 is infinite, which is also outside the domain of any of the integer types, but in this case, F\# casts an \idx{exception},
%
\fso{integerDivisionByZeroError}{Integer division by zero causes an exception run-time error.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, integer division by zero causes an exception run-time error.}]
% > 3/0;; 
% System.DivideByZeroException: Attempted to divide by zero.
%   at <StartupCode$FSI_0007>.$FSI_0007.main@ () <0x6b78180 + 0x0000e> in <filename unknown>:0 
%   at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
%   at System.Reflection.MonoMethod.Invoke (System.Object obj, BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) <0x1a55ba0 + 0x000a1> in <filename unknown>:0 
% Stopped due to error
% \end{lstlisting}
%
The output looks daunting at first sight, but the first and last line of the error message are the most important parts, which tells us what exception was cast and why the program stopped. The middle are technical details concerning which part of the program caused this, and can be ignored for the time being. Exceptions are a type of \idx{run-time error}, and are treated in Chapter~\ref{chap:exceptions}

Integer exponentiation is not defined as an operator, but this is available the built-in function \lstinline|pown|, e.g.,
%
\fso{integerPown}{Integer exponent function.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, integer exponentiation function, and the irrelevant identifier.}]
% > pown 2 5;;
% val it : int = 32
% \end{lstlisting}
%
which is equal to $2^5$.

%For integers the following arithmetic operators are defined:
%\begin{description}
% \item[\texttt{+op}, \texttt{-op}:] These are unary plus and minus operators, and plus has no effect, but minus changes the sign, e.g.,
%   % 
%   \begin{lstlisting}[language=fsharp,caption={fsharpi, unary integer negation operator.}]
%     > let a = 5 - let b = -a;;
    
%     val a : int = 5 val b : int = -5
%   \end{lstlisting}
% \item[\lstinline|op + op|, \lstinline|op - op|, \lstinline|op * op|:] These are binary operators, where addition, subtraction and multiplication performs the usual operations,
%   % 
%   \begin{lstlisting}[language=fsharp,caption={fsharpi, binary integer addition, subtraction, and multiplication operators.}]
%     > let a = 7 + 3 - let b = 7 - 3 - let c = 7 * 3;;
    
%     val a : int = 10 val b : int = 4 val c : int = 21
%   \end{lstlisting}

For binary arithmetic on integers, the following operators are available:
\lstinline{op1 <<< op2}, which shifts the bit pattern of \lstinline|op1| \lstinline|op2| positions to the left insert 0's to right;
\lstinline{op1 >>> op2}, which shifts the bit pattern of \lstinline|op1| \lstinline|op2| positions to the right insert 0's to left;
\lstinline{op1 &&& op2}, Bitwise 'and', returns the result of taking the boolean 'and' operator position-wise;
\lstinline{op ||| op}, Bitwise 'or', as 'and' but using the boolean 'or' operator; and
\lstinline{op1 ~~~ op1}, Bitwise xor, which is returns the result of the boolean 'xor' operator defined by the truth table in Table~\ref{tab:xor}.\idxs{xor}\idxs{exclusive or}
\begin{table}
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    a&b& a xor b\\
    \hline
    0 & 0 & 0\\
    0 & 1 & 1\\
    1 & 0 & 1\\
    0 & 1 & 0\\
    \hline
  \end{tabular}
  \caption{Boolean exclusive or truth table.}
  \label{tab:xor}
\end{table}
% Unfortunately, there are no built-ind functions to output integers on binary form, so to understand the output of the following program,
% \begin{lstlisting}[language=fsharp,caption={fsharpi, the left most bit is interpreted differently for signed and unsigned integers, which gives rise to potential overflow errors.}]
% > let a = 0b11000011uy  
% - let b = a <<< 1
% - let c = a >>> 1
% - let d = ~~~a
% - let e = a ^^^0b11111111uy;;
%
% val a : byte = 195uy
% val b : byte = 134uy
% val c : byte = 97uy
% val d : byte = 60uy
% val e : byte = 60uy
% \end{lstlisting}
% we must consider the 8-bit binary form of the unsigned integers: $195 = 11000011_2$, $134 = 10000110_2$, $97 = 01100001_2$, and $60 = 00111100_2$, which agrees with the definitions. 

\section{Floating point arithmetic}
The set of reals is infinitely large, and since all computers have limited resources, it is not possible to represent it in their entirety. The various floating point types listed in Table~\ref{tab:primitiveTypes} are finite subset reduced by sampling the space of reals. An in-depth description of floating point implementations can be found in Appendix~\ref{app:numbers}. The type \keyword{float} is the most common type. 


Table~\ref{tab:preNInfixOperators}, \ref{tab:comparisonOperators}, and~\ref{tab:arithmeticFunctions} gives examples operators and functions pre-defined for floating point types. For most addition, subtraction, multiplication, divisions, and negation the result straight forward. 

The remainder operator for floats calculates the remainder after division and discarding the fractional part,
%
\fso{floatDivisionRemainder}{Floating point division and remainder operators.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, binary floating point division and remainder operators.}]
% > let a = 7.0 / 3.0
% - let b = 7.0 % 3.0;;

% val a : int = 2.0
% val b : int = 1.0
% \end{lstlisting}
The remainder for floating point numbers can be fractional, but division, discarding fractional part, and remainder is still a lossless representation of the original number as,
%
\fso{floatDivisionRemainderLossless}{Floating point division, truncation, and remainder is a lossless representation of a number.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, floating point division, truncation, and remainder is a lossless representation of a number.}]
% > let x = 7.0
% - let division = x / 3.2
% - let whole = float (int division)
% - let remainder = x % 3.2
% - let y = whole * 3.2 + remainder;;
%
% val x : float = 7.0
% val division : float = 2.1875
% val whole : float = 2.0
% val remainder : float = 0.6
% val y : float = 7.0
% \end{lstlisting}
%And we see that \lstinline|x| and \lstinline|y| is bound to the same value.  



% For floating point numbers the following arithmetic operators are defined: 
% \begin{description}
% \item[\texttt{+op}, \texttt{-op}:] These are unary plus and minus operators, and plus has no effect, but minus changes the sign, e.g.,
% %
% \begin{lstlisting}[language=fsharp,caption={fsharpi, unary floating point negation operator.}]
% > let a = 5.0 
% - let b = -a;;

% val a : float = 5.0
% val b : float = -5.0
% \end{lstlisting}
% \item[\lstinline|op + op|, \lstinline|op - op|, \lstinline|op * op|, \lstinline|op / op|:] These are binary operators, where addition, subtraction, multiplication, and division performs the usual operations, 
% %
% \begin{lstlisting}[language=fsharp,caption={fsharpi, binary floating point addition, subtraction, multiplication, and division operators.}]
% > let a = 7.0 + 3.0
% - let b = 7.0 - 3.0
% - let c = 7.0 * 3.0
% - let d = 7.0 / 3.0;;

% val a : float = 10.0
% val b : float = 4.0
% val c : float = 21.0
% val d : float = 2.333333333
% \end{lstlisting}
% \item[\lstinline|op \% op|:] 

% \item[\texttt{op ** op}:] In spite of an unusual notation, the binary exponentiation operator performs the usual calculation,
% %
% \begin{lstlisting}[language=fsharp,caption={fsharpi, binary floating point exponentiation.}]
% > let a = 2.0 ** 5.0;;

% val a : float = 32.0
% \end{lstlisting}
% which is equal to $2^5$.
% \end{description}

Arithmetic using \lstinline|float| will not cause over- and underflow problems, since the IEEE 754 standard includes the special numbers $\pm\infty$ and NaN. E.g.,
%
\fso{floatDivisionByZero}{Floating point numbers include infinity and Not-a-Number.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, floating point numbers include infinity and Not-a-Number}]
% > let a = 1.0/0.0  
% - let b = 0.0/0.0;;
%
% val a : float = infinity
% val b : float = nan
% \end{lstlisting}
%
However, the \lstinline|float| type has limite precision, since there is only a finite number of numbers that can be stored in a float. E.g.,
%
\fso{floatImprecission}{Floating point arithmetic has finite precision.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, floating point arithmetic has finite precision.}]
% > let a = 357.8      
% - let b = a+0.1      
% - let c = b+0.1      
% - let d = c - 358.0;;
%
% val a : float = 357.8
% val b : float = 357.9
% val c : float = 358.0
% val d : float = 5.684341886e-14
% \end{lstlisting}
%
That is, addition and subtraction associates to the left, hence the expression is interpreted as \lstinline!(357.8 + 0.1) - 357.9!, and we see that we do not get the expected 0, since only a limited number of floating point values are available, and the numbers \lstinline!357.8 + 0.1!  and \lstinline!357.9! do not result in the same floating point representation. Such errors tend to accumulate and comparing the result of expressions of floating point values should therefore be treated with care. Thus, \advice{equivalence of two floating point expressions should only be considered up to sufficient precision, e.g., comparing \lstinline!357.8 + 0.1! and \lstinline!357.9! up to \lstinline!1e-10! precision should be tested as, \lstinline!abs ((357.8 + 0.1) - 357.9) < 1e-10!.}

\section{Char and string arithmetic}
Addition is the only operator defined for characters, nevertheless, character arithmetic is often done by casting to integer. A typical example is conversion of case, e.g., to convert the lowercase character 'z' to uppercase, we use the \idx{ASCIIbetical order} and add the difference between any Basic Latin Block letters in upper- and lowercase as \lstinline{integers} and cast back to \lstinline{char}, e.g.,
%
\fso{upcaseChar}{Converting case by casting and integer arithmetic.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, converting case by casting and integer arithmetic.}]
% > char (int 'z' - int 'a' + int 'A');; 
% val it : char = 'Z'
% \end{lstlisting}
%
I.e., the code point difference between upper and lower case for any alphabetical character 'a' to 'z' is constant, hence we can change case by adding or subtracting the difference between any corresponding character. Unfortunately, this does not generalize to characters from other languages.

A large collection of operators and functions exist for \lstinline{string}. The most simple is concatenation using, e.g.,
%
\fso{stringConcatenation}{Example of string concatenation.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, example of string concatenation.}]
% > let a = "hello"      
% - let b = "world"      
% - let c = a + " " + b;;
%
% val a : string = "hello"
% val b : string = "world"
% val c : string = "hello world"
% \end{lstlisting}
%
Characters and strings cannot be concatenated, which is why the above example used the string of  a space \lstinline|" "| instead of the space character \lstinline|' '|. The characters of a string may be indexed as using the \idx{\lstinline{.[]}} notation,
%
\fso{stringIndexing}{String indexing using square brackets.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, example of string indexing.}]
% > let a = "abcdefg"
% - let b = a.[0]
% - let c = a.[3]
% - ;;
%
% val a : string = "abcdefg"
% val b : char = 'a'
% val c : char = 'd'
% \end{lstlisting}
%
Notice, that the first character has index 0, and to get the last character in a string, we use the string's length property as,
%
\fso{stringIndexingLength}{String length attribute and string indexing.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, string length attribute and string indexing.}]
% > let a = "abcdefg"                                                                             
% - let l = a.Length                                                       
% - let first = a.[0]
% - let last = a.[l-1];;
%
% val a : string = "abcdefg"
% val l : int = 7
% val first : char = 'a'
% val last : char = 'g'
% \end{lstlisting}
%
Notice, since index counting starts at 0, and the string length is 7, then the index of the last character is 6. An alternative notation for indexing is to use the property \lstinline|Char|, and in the example \lstinline|''abcdefg''.[3]| is the same as \lstinline|a.Char 3|. The is a long list of built-in functions in \lstinline|System.String| for working with strings, some of which will be discussed in Chapter~\ref{sec:system.string}.
 
The \idx{dot notation} is an example of Structured programming, where technically speaking, the string \lstinline|"abcdefg"| is an immutable \idx{object} of \idx{class} \lstinline|string|, and \lstinline|[]| is an object \idx{method} and \lstinline|Length| is a property. For more on object, classes, and methods see Chapter~\ref{chap:oop}.  

Strings are compared letter by letter. For two strings to be equal, they must have the same length and all the letters must be identical. E.g., \lstinline!"abs" = "absalon"! is false, while \lstinline!"abs" = "abs"! is true. The \lexeme{<>} operator is the boolean negation of the \lexeme{=} operator, e.g., \lstinline!"abs" <> "absalon"! is true, while \lstinline!"abs" <> "abs"! is false. For the \lexeme{<} , \lexeme{<=}, \lexeme{>}, and \lexeme{>=} operators, the strings are ordered alphabetically, such that \lstinline!"abs" < "absalon" && "absalon" < "milk"! is true, that is, the \lexeme{<} operator on two strings is true, if the left operand should come before the right, when sorting alphabetically. The algorithm for deciding the boolean value of \lstinline!lOp < rOp! is as follows: we start by examining the first character, and if \lstinline!lOp.[0]! and \lstinline!rOp.[0]! are different, then the \lstinline!lOp < rOp! is equal to \lstinline!lOp.[0] < rOp.[0]!. E.g., \lstinline!"milk" < "abs"! is the same as \lstinline!'m' < 'a'! is false, since the letter 'm' does not come before the letter 'a' in the alphabet, or more precisely, the codepoint of 'm' is not less than the codepoint of 'a'. If \lstinline!lOp.[0]! and \lstinline!rOp.[0]! are equal, then we move onto the next letter and repeat the investigation, e.g., \lstinline!"abe" < "abs"! is true, since \lstinline!"ab" = "ab"! is true and \lstinline!'e' < 's'! is true. If we reach the end of either of the two strings, then the short is smaller than the larger, e.g., \lstinline!"abs" < "absalon"! is true, while lstinline!"abs" < "abs"! is false. The \lexeme{<=}, \lexeme{>}, and \lexeme{>=} operators are defined similarly.

%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
