\chapter{Using F\# as a calculator}
\label{chap:calculator}
%\chapter{Numbers, Characters, and Strings}
\section{Literals and basic types}
All programs rely on processing of data, and an essential property of data is its \idx{type}. A \idx{literal} is a fixed value such as the number 3, and if we type the number \lstinline!3! in an interactive session at the input prompt, then F\# responds as follows,
%
\fsOutput{firstType}{Typing the number 3.}
%
What this means is that F\# has inferred the type to be \idx{\lstinline{int}} and bound it to the identifier \idx{\lstinline{it}}. Rumor has it, that the identifier \lstinline|it| is an abbreviation for 'irrelevant'. For more on binding and identifiers see Chapter~\ref{chap:let}. Types matter, since the operations that can be performed on integers are quite different from those that can be performed on, e.g., strings. I.e.,
%
\fsOutput{typeMatters}{Many representations of the number 3 but using different types.}
%
Each literal represent the number 3, but their types are different, and hence they are quite different values. The types \lstinline!int! for integer numbers, \idx{\lstinline{float}} for floating point numbers, \idx{\lstinline{bool}} for boolean values, \idx{\lstinline{char}} for characters, and \idx{\lstinline{string}} for strings of characters are the most common types of literals. A table of all \idx{basic types} predefined in F\# is given in Table~\ref{tab:primitiveTypes}.\idxss{\lstinline{unit}}\idxss{\lstinline{obj}}\idxss{\lstinline{exn}}
\begin{table}
  \centering
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabularx}{\textwidth}{|l|l|>{\raggedright\arraybackslash}X|}
    \hline
    \rowcolor{headerRowColor} Metatype & Type name & Description\\
    \hline
    Boolean & \textbf{bool} & Boolean values true or false \\
    \hline
    Integer & \textbf{int} & Integer values from -2,147,483,648 to 2,147,483,647 \\
             & byte &Integer values from 0 to 255\\
             & sbyte &Integer values from -128 to 127\\
             %& int8 &Synonymous with byte\\
            % & uint8 &Synonymous with sbyte\\
            % & int16 &Integer values from -32768 to 32767\\
            % & uint16 &Integer values from 0 to 65535\\
             & int32 &Synonymous with int\\
             & uint32 & Integer values from 0 to 4,294,967,295\\
             %& int64 &Integer values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\\
            % & uint64 &Integer values from 0 to 18,446,744,073,709,551,615\\
             %& bignum &Integer not limited to 64 bits\\
             %& nativeint &A native pointer as a signed integer\\
            % & unativeint &A native pointer as an unsigned integer\\
    \hline
    Real &\textbf{float} & 64-bit IEEE 754 floating point value from $-\infty$ to $\infty$\\
             & double & Synonymous with float\\
             %& single &A 32-bit floating point type\\
            % & float32 &Synonymous with single\\
            % & decimal &A floating point data type that has at least 28 significant digits\\
    \hline
    Character &\textbf{char} &Unicode character\\
             &\textbf{string} & Unicode sequence of characters\\
    \hline
    None &\textbf{unit} & No value denoted\\
    \hline
    Object &\textbf{obj} & An object\\
    \hline
    Exception &\textbf{exn} & An exception\\
    \hline
  \end{tabularx}
  \caption{List of some of the basic types. The most commonly used types are highlighted in bold. For at description of integer see Appendix~\ref{sec:binary}, for floating point numbers see Appendix~\ref{sec:floatingPoint}, for ASCII and Unicode characters see Appendix~\ref{sec:characterSets}, for objects see Chapter~\ref{chap:oop}, and for exceptions see Chapter~\ref{chap:exceptions}.}
  \label{tab:primitiveTypes}
\end{table}
Besides these built-in types, F\# is designed such that it is easy to define new types. 

Humans like to use the \idx{decimal number} system for representing numbers. Decimal numbers are \idx{base}~10, which that a value is represented as two sequences of decimal digits separated by a \idx{decimal point}, where each \idx{digit} can have values $d \in \{0,1,2,\ldots,9\}$, and the value, which each digit represents is proportional to its position. The part before the decimal point is called the \idx{whole part} and the part after is called the \idx{fractional part} of the number. The whole part without a decimal point and a fractional part is called an \idx{integer}. As an example \lstinline!35.7! is a decimal number, whose value is $3\cdot 10^1+5\cdot 10^0+7\cdot 10^{-1}$, and \lstinline!128! is an integer, whose value is $1\cdot 10^2+2\cdot 10^1+8\cdot 10^{0}$. In F\# a decimal number is called a \idx{floating point number} and in this text we use \idx{Extended Backus-Naur Form} (\idx{EBNF}) to describe the grammar of F\#. In EBNF, the grammar describing a decimal number is,
%
\begin{verbatimwrite}{tmp.ebnf}
dDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
dInt = dDigit {dDigit}; (*no spaces*)
dFloat = dInt "." {dDigit}; (*no spaces*)
\end{verbatimwrite}
\ebnf{tmp.ebnf}{Decimal numbers.}
%
In EBNF \lstinline[language=ebnf]!dDigit!, \lstinline[language=ebnf]!dInt!, and \lstinline[language=ebnf]!dFloat! are names of tokens, while \lstinline[language=ebnf]!"0"!, \lstinline[language=ebnf]!"1"!, \ldots, \lstinline[language=ebnf]!"9"!, and \lstinline[language=ebnf]!"."! are terminals. Tokens and terminals together with formatting  rules describe possible sequences, which are valid. E.g., a \lstinline[language=ebnf]!dDigit! is defined by the \lstinline[language=ebnf]!=! notation to be either \lstinline!0! or \lstinline!1!  or \dots or \lstinline!9!, as signified by the \lstinline[language=ebnf]!|! syntax. The definition of a token is ended by a \lstinline[language=ebnf]!;!. The \lstinline[language=ebnf]!"{ }"! in EBNF signfies zero or more repetitions of its content, such that a \lstinline[language=ebnf]!dInt! is, e.g., \lstinline[language=ebnf]!dDigit!, \lstinline[language=ebnf]!dDigit dDigit!, \lstinline[language=ebnf]!dDigit dDigit dDigit dDigit! and so on. Since a \lstinline[language=ebnf]!dDigit! is any decimal digit, we conclude that \lstinline!3!, \lstinline!45!, and \lstinline!0124972930485738! are examples of \lstinline[language=ebnf]!dInt!.   A \lstinline[language=ebnf]!dFloat! is the concatenation of one or more digits, a dot, and zero or more digits, such as \lstinline!0.4235!, \lstinline!3.!, but not \lstinline!.5! nor \lstinline!.!. Sometimes EBNF implicitly allows for spaces between tokens and terminals, so here we have used the comments notation\lstinline[language=ebnf]!(* *)! to explicitly remind ourselves, that no spaces are allowed between the whole part, decimal point, and the fractional part. A complete description of EBNF is given in Appendix~\ref{sec:ebnf}.

Floating point numbers may alternatively be given using \idx{scientific notation}, such as \lstinline!3.5e-4! and \lstinline!4e2!, where the \lstinline!e!-notation is translated to a value as \lstinline!3.5e-4!~$=3.5\cdot 10^{-4} = 0.00035$, and \lstinline!4e2!~$=4\cdot 10^2=400$. To describe this in EBNF we write
%
\begin{verbatimwrite}{tmp.ebnf}
sFloat = (dInt | dFloat) ("e" | "E" ) ["+" | "-"] dInt; (*no spaces*)
float = dFloat | sFloat;
\end{verbatimwrite}
\ebnf{tmp.ebnf}{Scientific notation.}
%
Note that the number before the lexeme \lexeme{e} may be an \lstinline[language=ebnf]!dInt! or a \lstinline[language=ebnf]!dFloat!, but the exponent value must be an \lstinline[language=ebnf]!dInt!.

The basic unit of information in almost all computers is the binary digit or \idx{bit} for short. Internally, programs and data is all represented as bits, hence F\# has a strong support for binary numbers. A \idx{binary number} consists of a sequence of binary digits separated by a decimal point, where each digit can have values $b \in \{0,1\}$, and the base is $2$. E.g., the binary number $101.01_2 = 1\cdot 2^2+0\cdot 2^1+1\cdot 2^0+0\cdot 2^{-1}+1\cdot 2^{-2}=5.25$. Binary numbers are closely related to \idx[octal number]{octal} and \idx[hexadecimal number]{hexadecimal numbers}, where octals uses 8 as basis, and where each octal digit can be represented by exactly 3 bits, while hexadecimal numbers uses 16 as basis, and where each hexadecimal digit can be written in binary using exactly 4 bits. The hexadecimal digits uses \lstinline!0!--\lstinline!9! to represent the values 0--9 and \lstinline!a!--\lstinline!f! in lower or alternatively upper case to represent the values 10-15.  Octals and hexadecimals thus conveniently serve as shorthand for the much longer binary representation. F\# has a syntax for writing integers on binary, octal, decimal, and hexadecimal numbers as,
%
\begin{verbatimwrite}{tmp.ebnf}
bDigit = "0" | "1";
oDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7";
xDigit =  
  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
  | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f";
bitInt = "0" ("b" | "B") bDigit {bDigit}; (*no spaces*)
octInt = "0" ("o" | "O") oDigit {oDigit}; (*no spaces*)
hexInt = "0" ("x" | "X") xDigit {xDigit}; (*no spaces*)
xInt = bitInt | octInt | hexInt;
int = dInt | xInt;
\end{verbatimwrite}
\ebnf{tmp.ebnf}{Binary, hexadecimal, and octal numbers.}
%
For example the value 367 in base 10 may be written as a \lstinline[language=ebnf]!dInt! integer as \lstinline[language=ebnf]!367!, as a \lstinline[language=ebnf]!bitInt! binary number as \lstinline!0b101101111!, as a \lstinline[language=ebnf]!octInt! octal number as \lstinline!0o557!, and as a \lstinline[language=ebnf]!hexInt! hexadecimal number as \lstinline!0x16f!. In contrast, \lstinline!0b12! and \lstinline!ff! are neither an \lstinline[language=ebnf]!dInt! nor an \lstinline[language=ebnf]!xInt!.

A \idx{character} is a \idx{Unicode} \idx{code point}, and character literals are enclosed in single quotation marks, see Appendix~\ref{sec:unicode} for a description of code points.\spec{Spec-4.0 p.28: \texttt{char-char} is missing option \texttt{unicodegraph-long} } The EBNF for characters is,
%
\begin{verbatimwrite}{tmp.ebnf}
codePoint = ?Any unicode codepoint?;
escapeChar = 
  "\" ("b" | "n" | "r" | "t" | "\" | '"' | "'" | "a" | "f" | "v")
  | "\u" xDigit xDigit xDigit xDigit
  | "\U" xDigit xDigit xDigit xDigit xDigit xDigit xDigit xDigit
  | "\" dDigit dDigit dDigit;  (*no spaces*)
char = "'" codePoint | escapeChar "'"; (*no spaces*)
\end{verbatimwrite}
\ebnf{tmp.ebnf}{Character escape sequences.}
% 
where \lstinline[language=ebnf]!codePoint! is a UTF8 encoding of a char. The escape characters \lstinline[language=ebnf]{escapeChar} are special sequences that are interpreted as a single code point shown in Table~\ref{tab:escapeChar}. The trigraph \lstinline|\DDD| uses decimal specification for the first 256 code points, and the hexadecimal escape codes \lstinline|\uXXXX|, \lstinline|\UXXXXXXXX| allow for the full specification of any code point.
\begin{table}
  \centering
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabular}{|c|l|l|}
    \hline
    \rowcolor{headerRowColor} Character& Escape sequence & Description\\
    \hline
    BS &\lstinline|\b|& Backspace\\
    LF &\lstinline|\n|&Line feed\\
    CR &\lstinline|\r|&Carriage return\\
    HT &\lstinline|\t|&Horizontal tabulation\\
    \textbackslash &\lstinline|\\|&Backslash\\
     " &\lstinline|\"|&Quotation mark\\
    ' &\lstinline|\'|&Apostrophe\\
    BEL&\lstinline|\a|& Bell\\
    FF&\lstinline|\f|&Form feed\\
    VT &\lstinline|\v|&Vertical tabulation\\
    &\lstinline|\uXXXX|, \lstinline|\UXXXXXXXX|, \lstinline|\DDD|&Unicode character\\
    \hline
  \end{tabular}
  \caption{Escape characters. For the unicode characters 'X' are hexadecimal digits, while for tricode characters 'D' is a decimal character.}
  \label{tab:escapeChar}
\end{table}
Examples of a \lstinline[language=ebnf]!char! are \lstinline{'a'}, \lstinline{'_'}, \lstinline{'\n'}, and \lstinline{'\065'}.

A \idx{string} is a sequence of characters enclosed in double quotation marks,\spec{Spec-4.0 p. 28-29: \texttt{simple-string-char} is undefined, \texttt{string-elem} is unused.}
%
\begin{verbatimwrite}{tmp.ebnf}
stringChar = char - '"';
string = '"' { stringChar }  '"';
verbatimString = '@"' {char - ('"' | '\"' )| '""'} '"';
\end{verbatimwrite}
\ebnf{tmp.ebnf}{Strings.}
% 
Examples are \lstinline{"a"}, \lstinline{"this is a string"}, and \lstinline{"-&#\@"}. \idx[newline]{Newlines} and following \idx[whitespace]{whitespaces},
\begin{verbatimwrite}{tmp.ebnf}
whitespace = " " {" "};
newline = "\n" | "\r" "\n";
\end{verbatimwrite}
\ebnf{tmp.ebnf}{Whitespace and newline.}
are taken literally, but may be ignored by a preceding \textbackslash character. Further examples of strings are,
%
\fsOutput{stringLiterals}{Examples of string literals.}
%
The response is shown in double quotation marks, which are not part of the string. 

F\# supports \idx[literal type]{literal types}, where the type of a literal is indicated as a prefix og suffix as shown in the Table~\ref{tab:literalTypes}.\idxss{\lstinline{int32}}\idxss{\lstinline{uint32}}\idxss{\lstinline{byte}}\idxss{\lstinline{uint8}}\idxss{\lstinline{byte[]}}\idxss{\lstinline{sbyte}}\idxss{\lstinline{int8}}\idxss{\lstinline{int16}}\idxss{\lstinline{uint16}}\idxss{\lstinline{int64}}\idxss{\lstinline{uint64}}\idxss{\lstinline{bignum}}\idxss{\lstinline{nativeint}}\idxss{\lstinline{unativeint}}\idxss{\lstinline{double}}\idxss{\lstinline{single}}\idxss{\lstinline{float32}}\idxss{\lstinline{decimal}}
\begin{table}
  \centering
  %\begin{tabularx}{\linewidth}{|>{\hsize=.6\hsize}X|>{\hsize=1.4\hsize}X|>{\hsize=1\hsize}X|}
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabular}{|l|l|l|}
    \hline
    \rowcolor{headerRowColor} type & EBNF & Examples \\
    \hline
    \lstinline!int!, \lstinline!int32! & \lstinline[language=ebnf]!(dInt | xInt) ["l"]!  & \lstinline!3! \\
    \lstinline!uint32! & \lstinline[language=ebnf]!(dInt | xInt) ("u" | "ul")! & \lstinline!3u! \\
    \lstinline!byte!, \lstinline!uint8! & \lstinline[language=ebnf]!((dInt | xInt) "uy") | (char "B")!  & \lstinline!3uy!  \\
    \lstinline!byte[]! & \lstinline[language=ebnf]!["@"] string "B"!  & \lstinline!"abc"B! and \lstinline!"@http:\\"B!  \\
    \lstinline!sbyte!, \lstinline!int8! & \lstinline[language=ebnf]!(dInt | xInt) "y"! & \lstinline!3y!  \\
    %\lstinline!int16! & \lstinline[language=ebnf]!(dInt | xInt) "s"!  & \lstinline!3s!  \\
    %\lstinline!uint16! & \lstinline[language=ebnf]!(dInt | xInt) "us"! & \lstinline!3us!  \\
    %\lstinline!int64! & \lstinline[language=ebnf]!(dInt | xInt) "L"!  & \lstinline!3L!  \\
    %\lstinline!uint64! & \lstinline[language=ebnf]!(dInt | xInt) ("UL" | "uL")!  & \lstinline!3UL! and \lstinline!3uL!  \\
    %\lstinline!bignum!$^*$ & \lstinline[language=ebnf]!dInt "I"! & \lstinline!3I!  \\
    %\lstinline!nativeint! & \lstinline[language=ebnf]!(dInt | xInt) "n"! & \lstinline!3n!  \\
    %\lstinline!unativeint! & \lstinline[language=ebnf]!(dInt | xInt) "un"!  & \lstinline!3un!  \\
    \lstinline!float!, \lstinline!double! & \lstinline[language=ebnf]!float | (xInt "LF")!  & \lstinline!3.0!  \\
    %\lstinline!single!, \lstinline!float32! & \lstinline[language=ebnf]!(float ("F" | "f")) | (xInt "lf") !  & \lstinline!3.0f!  \\
    %\lstinline!decimal! &\lstinline[language=ebnf]!(float | dInt) ("M" | "m")! & \lstinline!3.0m! and \lstinline!3m!  \\
    \lstinline!string! & \lstinline[language=ebnf]!simpleString |! & \lstinline!"a \"quote\".\n"!  \\
         & \lstinline[language=ebnf]!'@"' {(char - ('"' | '\"' )) | '""'} '"' |!&\lstinline!@"a ""quote"".\n"! \\
        % & \lstinline[language=ebnf]!'""' {char} '""' (*no '"""' substring*)! & \lstinline!"""a "quote".\n"""!  \\
    \hline
  \end{tabular}
  % \end{tabularx}
  \caption{List of literal type. No spacing is allowed between the literal and the prefix or suffix. 
    % The \lstinline![]! notation is for lists, see Chapter~\ref{chap:lists}. $^*$\lstinline[language=ebnf]!bignum! is not a basic type and does not yet have an implementation for \lstinline[language=ebnf]!dInt ("Q"|"R"|"Z"|"N"|"G")! in Mono.
  }
  \label{tab:literalTypes}
\end{table}
Examples are,
%
\fsOutput{namedLiterals}{Named and implied literals.}
%
Strings literals may be \idx{verbatim} by the @-notation % or triple double quotation marks,
meaning that the escape sequences are not converted to their code point., e.g.,
%
\fsOutput{stringVerbatim}{Examples of a string literal.}
%
%For strings containing double quotation marks, verbatim literals has 2 possible notations, either use the @-notation and escaping double quotation marks with an extra double quotation mark, or use triple double quotation marks. \advice{The triple double quotation marks notation may not contain substrings that are triple double quotation marks, and thus @-notation is preferred.}

Many basic types are compatible, and the type of a literal may be changed by \idx{typecasting}. E.g.,
%
\fsOutput{upcasting}{Casting an integer to a floating point number.}
% 
which is a \lstinline!float!, since when \lstinline|float| is given an argument, then it acts as a function rather than a type, and for the integer \lstinline|3| it returns the floating point number \lstinline|3.0|.  For more on functions see Chapter~\ref{chap:let}. Boolean values are often treated as the integer values 0 and 1, but no short-hand function names exists for their conversions. Instead use,
%
\fsOutput{castingBooleans}{Casting booleans.}
% 
Here \lstinline|System.Convert.ToBoolean| is the identifier of a function \lstinline|ToBoolean|, which is a \idx{member} of the \idx{class} \lstinline|Convert| that is included in the \idx{namespace} \lstinline|System|. Namespaces, classes, and members are all part of Structured programming to be discussed in Part~\ref{part:structured}.

Typecasting is often a destructive operation, e.g., typecasting a \lstinline{float} to \lstinline{int} removes the fractional part without rounding,
%
\fsOutput{downcasting}{Fractional part is removed by downcasting.}
%
Here we typecasted to a lesser type, in the sense that the set of integers is a subset of floating point numbers, and this is called \idx{downcasting}. The opposite is called \idx{upcasting} and is often non-destructive, as Listing~\ref{upcasting} showed, where an integer was casted to a float while retaining its value. As a side note, \idx{rounding} a number $y.x$, where $y$ is the \idx{whole part} and $x$ is the \idx{fractional part}, is the operation of mapping numbers in the interval $y.x \in [y.0,y.5)$ to $y$ and $y.x\in [y.5,y+1)$ to $y+1$. This can be performed by downcasting as follows,
%
\fsOutput{rounding}{Fractional part is removed by downcasting.}
%
since if $y.x\in [y.0, y.5)$, then $y.x+0.5\in [y.5, y+1)$, from which downcasting removes the fractional part resulting in $y$. And if $y.x\in [y.5, y+1)$, then $y.x+0.5\in [y+1,y+1.5)$, from which downcasting removes the fractional part resulting in $y+1$. Hence, the result is rounding. 

\section{Operators on basic types}
Listing~\ref{rounding} is an example of an arithmetic \idx{expression} using an \idx{infix operator}. Expressions is the basic building block of all F\# programs, and its grammar has many possible options. In the example, \lstinline!+! is the operator, and it is an infix operator, since it takes values on its left and right side. The grammar for expressions are defined recursively, and some of it is given by, \spec{Spec-4.0 Section 4.3: const is missing uint8, int8 nativeint, unativeint.}
%
\begin{verbatimwrite}{tmp.ebnf}
const = byte | sbyte | int32 | uint32 | int | ieee64 | char | string 
  | verbatimString | "false" | "true" | "()";
sliceRange = 
  expr 
  | expr ".." (*no space between expr and ".."*)
  | ".." expr (*no space between expr and ".."*)
  | expr ".." expr (*no space between expr and ".."*)
  | "*";
expr = ...
  | const (*a const value*)
  | "(" expr ")" (*block*)
  | expr expr (*application*)
  | expr infixOp expr (*infix application*)
  | prefixOp expr (*prefix application*)
  | expr ".[" expr "]" (*index lookup, no space before "."*)
  | expr ".[" sliceRange "]" (*index lookup, no space before "."*)
\end{verbatimwrite}
\ebnf{tmp.ebnf}{Expressions.}
%
Recursion means that a rule or a function is used by the rule or function itself in its definition, e.g., in the definition of \lstinline[language=ebnf]!expression!, the token \lstinline[language=ebnf]!expression! occurs both on the left and the right side of the \lstinline[language=ebnf]!=! symbol. See Part~\ref{part:declarative} for more on recursion. Infix notation means that the \idx{operator} \lstinline[language=ebnf]!op! appears between the two \idx{operands}, and since there are 2 operands, it is a \idx{binary operator}. As the grammar shows, the operands themselves can be expressions. Examples are \lstinline!3+4! and \lstinline!4+5+6!. Some operators only takes one operand, e.g., \lstinline!-3!, where \lstinline!-! here is used to negate a postive integer. Since the operator appears before the operand it is a \idx{prefix operator}, and since it only takes one argument it is also a \idx{unary operator}. Finally, some expressions are function names, which can be applied to expressions. F\# supports a range of arithmetic infix and prefix operators on its built-in types such as addition, subtraction, multiplication, division, and exponentiation using the \lexeme{+}, \lexeme{-}, \lexeme{*}, \lexeme{/}, \lexeme{**} binary operators respectively. Not all operators are defined for all types, e.g., addition is defined for integer and float types as well as for characters and strings, but multiplication is only defined for integer and floating point types. A complete list of built-in operators on basic types is shown in Table~\ref{tab:preNInfixOperators} and~\ref{tab:comparisonOperators} and a range of mathematical functions shown in Table~\ref{tab:arithmeticFunctions}.

The concept of \idx{precedence} is an important concept in arithmetic expressions.\jon{minor comment on indexing and slice-ranges.} If parentheses are omitted in Listing~\ref{rounding}, then F\# will interpret the expression as \lstinline|(int 357.6)  + 0.5|, which is erroneous, since addition of an integer with a float is undefined. This is an example of precedence, i.e., function evaluation takes precedence over addition meaning that it is performed before addition. Consider the arithmetic expression,
%
\fsOutput{simpleArithmetic}{A simple arithmetic expression.}
%
Here, the addition and multiplication functions are shown in \idx{infix notation} with the \idx{operator} lexemes \lexeme{+} and \lexeme{*}. To arrive at the resulting value 23, F\# has to decide in which order to perform the calculation. There are 2 possible orders, \lstinline|3 + (4 * 5)| or \lstinline|(3 + 4) * 5|, which gives different results. For integer arithmetic, the correct order is of course to multiply before addition, and we say that multiplication takes \idx{precedence} over addition. Every atomic operation that F\# can perform is ordered in terms of its precedences, and for some common built-in operators shown in Table~\ref{tab:someOperatorPrecedences}, the precedence is shown by the order they are given in the table.

Associativity implies the order in which calculations are performed for operators of same precedence. For some operators and type combinations association matters little, e.g., multiplication associates to the left and exponentiation associates to the right, e.g., in\spec{Spec-4.0, Table 18.2.1 appears to be missing boolean 'and' and 'or' operations. Section 4.4 seems to be missing \&\&\& and ||| bitwise operators.}
%
\fsOutput{precedence}{Precedences rules define implicite parentheses.}
%
the expression for \lstinline|3.0 * 4.0 * 5.0| associates to the left, and thus is interpreted as \mbox{\lstinline|(3.0 * 4.0) * 5.0|,} but gives the same results as \lstinline|3.0 * (4.0 * 5.0)|, since association does not matter for multiplication of numbers. However, the expression for \lstinline|4.0 ** 3.0 ** 2.0| associates to the right, and thus is interpreted as \lstinline|4.0 ** (3.0 ** 2.0)|, which is quite different from \lstinline|(4.0 ** 3.0) ** 2.0|. \advice{Whenever in doubt of association or any other basic semantic rules, it is a good idea to use parentheses as here. It is also a good idea to test your understanding of the syntax and semantic rules by making a simple scripts.}

\section{Boolean arithmetic}
Boolean arithmetic is the basis of almost all computers and particularly important for controlling program flow, which will be discussed in Chapter~\ref{chap:flow}. Boolean values are one of 2 possible values, true or false, which is also sometimes written as 1 and 0. Basic operations on boolean values are '\idx{and}', '\idx{or}', and '\idx{not}', which in F\# is written as the binary operators \lstinline!&&!, \lstinline!||!, and the function \lstinline!not!. Since the domain of boolean values is so small, then all possible combination of input on these values can be written on tabular form, known as a \idx{truth table}, and the truth tables for the basic boolean operators and functions is shown in Table~\ref{tab:truthTable}.
\begin{table}
  \centering
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    \rowcolor{headerRowColor} \lstinline!a! & \lstinline!b! & \lstinline!a && b!& \lstinline!a || b! & \lstinline!not a!\\
    \hline
    \lstinline!false!&\lstinline!false!&\lstinline!false!&\lstinline!false!&\lstinline!true!\\
    \lstinline!false!&\lstinline!true!&\lstinline!false!&\lstinline!true!&\lstinline!true!\\
    \lstinline!true!&\lstinline!false!&\lstinline!false!&\lstinline!true!&\lstinline!false!\\
    \lstinline!true!&\lstinline!true!&\lstinline!true!&\lstinline!true!&\lstinline!false!\\
    \hline
  \end{tabular}
  \caption{Truth table for boolean 'and', 'or', and 'not' operators. Value 0 is false and 1 is true.}
  \label{tab:truthTable}
\end{table}
A good mnemonics for remembering the result of the 'and' and 'or' operators is to use 1 for true, 0 for false, multiplication for the boolean 'and' operator, and addition for boolean 'or' operator, e.g., true and false in this mnemonic translates to $1\cdot 0 = 0$, and the results translates back to the boolean value false. In F\# the truth table for the basic boolean operators is reproduced by,
%
\fsOutput{truthTable}{Boolean operators and truth tables.}
%
In Listing~\ref{truthTable} we used the \lstinline|printfn| function, to present the results of many expressions on something that resembles a tabular form. The spacing produced using the \lstinline|printfn| function is not elegant, and in Section~\ref{sec:printf} we will discuss better options for producing more beautiful output. Notice, that the arguments for \lstinline|printfn| was given on the next line with indentation. The indentation is an important part of telling F\#, which part of what you write belongs together. This is an example of the so-called lightweight syntax. Generally, F\# ignores newlines and whitespaces except when using the ligthweight syntax, and the examples of the difference between regular and lightweight syntax is discussed in Chapter~\ref{chap:let}.

\section{Integer arithmetic}
The set of integers is infinitely large, but since all computers have limited resources, it is not possible to represent it in their entirety. The various integer types listed in Table~\ref{tab:primitiveTypes} are finite subsets reduced by limiting their ranges. 
%Although \lstinline!bignum! is theoretically unlimited, the biggest number representable is still limited by computer memory. 
An in-depth description of integer implementation can be found in Appendix~\ref{app:numbers}. The type \keyword{int} is the most common type. 

Table~\ref{tab:preNInfixOperators}, \ref{tab:comparisonOperators}, and~\ref{tab:arithmeticFunctions} gives examples operators and functions pre-defined for integer types. Notice that fewer functions are available for integers than for floating point numbers. For most addition, subtraction, multiplication, and negation the result straight forward. However, performing arithmetic operations on integers requires extra care, since the result may cause \idx{overflow} and \idx{underflow}. E.g., the range of the integer type \lstinline|sbyte| is $[-128\ldots 127]$, which causes problems in the following example,
%
\fsOutput{overflow}{Adding integers may cause overflow.}
%
Here $100+30=130$, which is larger than the biggest \lstinline|sbyte|, and the result is an overflow. Similarly, we get an underflow, when the arithmetic result falls below the smallest value storable in an \lstinline|sbyte|,
%
\fsOutput{underflow}{Subtracting integers may cause underflow.}
%
I.e., we were expecting a negative number, but got a postive number instead.

The overflow error in Listing~\ref{overflow} can be understood in terms of the binary representation of integers: In binary, $130=10000010_2$, and this binary pattern is interpreted differently as \lstinline{byte} and \lstinline{sbyte},
%
\fsOutput{overflowBits}{The left most bit is interpreted differently for signed and unsigned integers, which gives rise to potential overflow errors.}
%
That is, for signed bytes, the left-most bit is used to represent the sign, and since the addition of $100=01100100_2$ and $30=00011110_b$ is $130=10000010_2$ causes the left-most bit to be used, then this is wrongly interpreted as a negative number, when stored in an \lstinline{sbyte}. Similar arguments can be made explaining underflows.

The division and remainder operators\idxs{integer division}, which discards the fractional part after division, and the \idx{remainder} operator calculates the remainder after integer division, e.g.,
%
\fsOutput{integerDivisionRemainder}{Integer division and remainder operators.}
%
Together integer division and remainder is a lossless representation of the original number as,
%
\fsOutput{integerDivisionRemainderLossless}{Integer division and remainder is a lossless representation of an integer, compare with Listing~\ref{integerDivisionRemainder}.}
%
And we see that integer division of 7 by 3 followed by multiplication by 3 is less that 7, and the difference is \lstinline!7 % 3!.

Notice that neither overflow nor underflow error gave rise to an error message, which is why such bugs are difficult to find. 
 Dividing any non-zero number with 0 is infinite, which is also outside the domain of any of the integer types, but in this case, F\# casts an \idx{exception},
%
\fsOutput{integerDivisionByZeroError}{Integer division by zero causes an exception run-time error.}
%
The output looks daunting at first sight, but the first and last line of the error message are the most important parts, which tells us what exception was cast and why the program stopped. The middle are technical details concerning which part of the program caused this, and can be ignored for the time being. Exceptions are a type of \idx{run-time error}, and are treated in Chapter~\ref{chap:exceptions}

Integer exponentiation is not defined as an operator, but this is available the built-in function \lstinline|pown|, e.g.,
%
\fsOutput{integerPown}{Integer exponent function.}
%
which is equal to $2^5$.

For binary arithmetic on integers, the following operators are available:
\lstinline{leftOp <<< rightOp}, which shifts the bit pattern of \lstinline|leftOp| \lstinline|rightOp| positions to the left while inserting 0's to right;
\lstinline{leftOp >>> rightOp}, which shifts the bit pattern of \lstinline|leftOp| \lstinline|rightOp| positions to the right while inserting 0's to left;
\lstinline{leftOp &&& rightOp}, bitwise 'and', returns the result of taking the boolean 'and' operator position-wise;
\lstinline{leftOp ||| rightOp}, bitwise 'or', as 'and' but using the boolean 'or' operator; and
\lstinline{leftOp ~~~ leftOp}, bitwise xor, which is returns the result of the boolean 'xor' operator defined by the truth table in Table~\ref{tab:xor}.\idxs{xor}\idxs{exclusive or}
\begin{table}
  \centering
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabular}{|c|c|c|}
    \hline
    \rowcolor{headerRowColor} \lstinline!a! & \lstinline!b! & \lstinline!a ~~~ b!\\
    \hline
    \lstinline!false! & \lstinline!false! & \lstinline!false!\\
    \lstinline!false! & \lstinline!true! & \lstinline!true!\\
    \lstinline!true! & \lstinline!false! & \lstinline!true!\\
    \lstinline!true! & \lstinline!true! & \lstinline!false!\\
    \hline
  \end{tabular}
  \caption{Boolean exclusive or truth table.}
  \label{tab:xor}
\end{table}
% Unfortunately, there are no built-ind functions to output integers on binary form, so to understand the output of the following program,
% \begiverbatimwrite}{tmp.ebnf}
% > let a = 0b11000011uy  
% - let b = a <<< 1
% - let c = a >>> 1
% - let d = ~~~a
% - let e = a ^^^0b11111111uy;;
%
% val a : byte = 195uy
% val b : byte = 134uy
% val c : byte = 97uy
% val d : byte = 60uy
% val e : byte = 60uy
% \end{verbatimwrite}
%\ebnf{tmp.ebnf}{to do.}
% we must consider the 8-bit binary form of the unsigned integers: $195 = 11000011_2$, $134 = 10000110_2$, $97 = 01100001_2$, and $60 = 00111100_2$, which agrees with the definitions. 

\section{Floating point arithmetic}
The set of reals is infinitely large, and since all computers have limited resources, it is not possible to represent it in their entirety. Floating point types are finite subsets reduced by sampling the space of reals. An in-depth description of floating point implementations can be found in Appendix~\ref{app:numbers}. The type \keyword{float} is the most common type. 

Table~\ref{tab:preNInfixOperators}, \ref{tab:comparisonOperators}, and~\ref{tab:arithmeticFunctions} gives examples operators and functions pre-defined for floating point types. For most addition, subtraction, multiplication, divisions, and negation the result straight forward. The remainder operator for floats calculates the remainder after division and discarding the fractional part,
%
\fsOutput{floatDivisionRemainder}{Floating point division and remainder operators.}
%
The remainder for floating point numbers can be fractional, but division, discarding fractional part, and remainder is still a lossless representation of the original number as,
%
\fsOutput{floatDivisionRemainderLossless}{Floating point division, truncation, and remainder is a lossless representation of a number.}
%

Arithmetic using \lstinline|float| will not cause over- and underflow problems, since the IEEE 754 standard includes the special numbers $\pm\infty$ and NaN. E.g.,
%
\fsOutput{floatDivisionByZero}{Floating point numbers include infinity and Not-a-Number.}
%
However, the \lstinline|float| type has limited precision, since there is only a finite number of numbers that can be stored in a float. E.g.,
%
\fsOutput{floatImprecission}{Floating point arithmetic has finite precision.}
%
That is, addition and subtraction associates to the left, hence the expression is interpreted as \lstinline!(357.8 + 0.1)  - 357.9!, and we see that we do not get the expected 0, since only a limited number of floating point values are available, and the numbers \lstinline!357.8 + 0.1!  and \lstinline!357.9! do not result in the same floating point representation. Such errors tend to accumulate and comparing the result of expressions of floating point values should therefore be treated with care. Thus, \advice{equivalence of two floating point expressions should only be considered up to sufficient precision, e.g., comparing \lstinline!357.8 + 0.1! and \lstinline!357.9! up to \lstinline!1e-10! precision should be tested as, \lstinline!abs ((357.8 + 0.1) - 357.9)  < 1e-10!.}

\section{Char and string arithmetic}
Addition is the only operator defined for characters, nevertheless, character arithmetic is often done by casting to integer. A typical example is conversion of case, e.g., to convert the lowercase character 'z' to uppercase, we use the \idx{ASCIIbetical order} and add the difference between any Basic Latin Block letters in upper- and lowercase as \lstinline{integers} and cast back to \lstinline{char}, e.g.,
%
\fsOutput{upcaseChar}{Converting case by casting and integer arithmetic.}
%
I.e., the code point difference between upper and lower case for any alphabetical character 'a' to 'z' is constant, hence we can change case by adding or subtracting the difference between any corresponding character. Unfortunately, this does not generalize to characters from other languages.

A large collection of operators and functions exist for \lstinline{string}. The most simple is concatenation using, e.g.,
%
\fsOutput{stringConcatenation}{Example of string concatenation.}
%
Characters and strings cannot be concatenated, which is why the above example used the string of  a space \lstinline|" "| instead of the space character \lstinline|' '|. The characters of a string may be indexed as using the \idx{\lstinline{.[]}} notation,
%
\fsOutput{stringIndexing}{String indexing using square brackets.}
%
Notice, that the first character has index 0, and to get the last character in a string, we use the string's length property as,
%
\fsOutput{stringIndexingLength}{String length attribute and string indexing.}
%
Since index counting starts at 0, and the string length is 7, then the index of the last character is 6. 
%An alternative notation for indexing is to use the property \lstinline|Char|, and in the example \lstinline|''abcdefg''.[3]| is the same as \lstinline|a.Char 3|. 
The is a long list of built-in functions in \lstinline|System.String| for working with strings, some of which will be discussed in Chapter~\ref{sec:system.string}.
 
The \idx{dot notation} is an example of Structured programming, where technically speaking, the string \mbox{\lstinline|"abcdefg"|} is an immutable \idx{object} of \idx{class} \lstinline|string|, \lstinline|[]| is an object \idx{method}, and \lstinline|Length| is a property. For more on object, classes, and methods see Chapter~\ref{chap:oop}.  

Strings are compared letter by letter. For two strings to be equal, they must have the same length and all the letters must be identical. E.g., \mbox{\lstinline!"abs" = "absalon"!} is false, while \lstinline!"abs"\space = "abs"! is true. The \lexeme{<>} operator is the boolean negation of the \lexeme{=} operator, e.g., \lstinline!"abs" <> "absalon"! is true, while \lstinline!"abs" <> "abs"! is false. For the \lexeme{<} , \lexeme{<=}, \lexeme{>}, and \lexeme{>=} operators, the strings are ordered alphabetically, such that \lstinline!"abs" < "absalon" && "absalon" < "milk"! is true, that is, the \lexeme{<} operator on two strings is true, if the left operand should come before the right, when sorting alphabetically. The algorithm for deciding the boolean value of \lstinline!leftOp < rightOp! is as follows: we start by examining the first character, and if \lstinline!leftOp.[0]! and \lstinline!rightOp.[0]! are different, then the \lstinline!leftOp < rightOp! is equal to \lstinline!leftOp.[0] < rightOp.[0]!. E.g., \lstinline!"milk" < "abs"! is the same as \lstinline!'m' < 'a'!, which is false, since the letter 'm' does not come before the letter 'a' in the alphabet, or more precisely, the codepoint of 'm' is not less than the codepoint of 'a'. If \lstinline!leftOp.[0]! and \lstinline!rightOp.[0]! are equal, then we move onto the next letter and repeat the investigation, e.g., \lstinline!"abe" < "abs"! is true, since \lstinline!"ab" = "ab"! is true and \lstinline!'e' < 's'! is true. If we reach the end of either of the two strings, then the short is smaller than the larger, e.g., \lstinline!"abs" < "absalon"! is true, while \lstinline!"abs" < "abs"! is false. The \lexeme{<=}, \lexeme{>}, and \lexeme{>=} operators are defined similarly.

\section{Programming intermezzo}
Conversion of integers between decimal and binary form is a key concept in order to understand some of the basic properties of calculations on the computer. From binary to decimal is straight forward using the power-of-two algorithm, i.e., given a sequence of $n+1$ bits that represent an intager $b_n b_{n-1}\dots b_0$, where $b_n$ and $b_0$ are the most and least significant bits, then the decimal value is calculated as,
\begin{align}
  v = \sum_{i=0}^nb_i2^i
\end{align}
For example $10011_2 = 1+2+16 = 19$. From decimal to binary is a little more complex, but a simple divide-by-two algorithm exists. The key to understanding the divide-by-two algorithm is to realize that when you divide a number by two, then that is equivalent to shifting its binary representation 1 to the right. E.g., $10 = 1010_2$ and $10/2 = 5 = 101_2$. Odd numbers have $b_0=1$, e.g., $11_{10} = 1011_2$ and $11_{10}/2 = 5.5 = 101.1_2$. Hence, if we divide any number by two and get a non-integer number, then its least significant bit was $1$. Another way to express this is that the least significant bit is the remainder after integer division by two. Sequential application of this idea leads directly to the divide-by-two algorithm. E.g., if we were to convert the number $11_{10}$ on decimal form to binary form we would perform the following steps:
\samepage{
\begin{align*}
  11\tikzmark{a1} \text{ div } 2 = \tikzmark{a2}5\tikzmark{a3},\;   \tikzmark{a4}11  \text{ rem }  2 & =\tikzmark{a5}1\tikzmark{a6}\\
  \nonumber \\
  5\tikzmark{b1} \text{ div }  2 = \tikzmark{b2}2\tikzmark{b3},\;  \tikzmark{b4}5  \text{ rem } 2 & =\tikzmark{b5}1\tikzmark{b6}\\
  \\\nonumber
  2\tikzmark{c1}  \text{ div }  2 = \tikzmark{c2}1\tikzmark{c3},\;   \tikzmark{c4}2 \text{ rem }  2 & =\tikzmark{c5}0\tikzmark{c6} \\
  \\\nonumber
  1\tikzmark{d1}  \text{ div }  2 = \tikzmark{d2}0\tikzmark{d3},\;   \tikzmark{d4}1  \text{ rem }  2 & =\tikzmark{d5}1\tikzmark{d6}\\
\end{align*}
\marginpar{\DrawArrow[]{a2}{b1}
\DrawArrow[]{a3}{b4}
\DrawArrow[]{b2}{c1}
\DrawArrow[]{b3}{c4}
\DrawArrow[]{c2}{d1}
\DrawArrow[]{c3}{d4}
\FrameArea{a5}{d6}}
}
Here we used div and rem to signify the integer division and remainder operators. The algorithms stops, when the result of integer division is zero. Reading off the remainder from below and up we find the sequence $1011_2$, which is the binary form of the decimal number $11_{10}$. Using interactive mode, we can calculate the same as,
\begin{codeNOutput}{: Converting the number $11_{10}$ to binary form.}
\begin{lstlisting}[language=console]
> printfn "(%d, %d)" (11 / 2) (11 % 2);;
(5, 1)
val it : unit = ()
> printfn "(%d, %d)" (5 / 2) (5 % 2);;  
(2, 1)
val it : unit = ()
> printfn "(%d, %d)" (2 / 2) (2 % 2);;  
(1, 0)
val it : unit = ()
> printfn "(%d, %d)" (1 / 2) (1 % 2);;
(0, 1)
val it : unit = ()
\end{lstlisting}
\end{codeNOutput}
Thus, but reading the second integer-respons from \lstinline!printfn! from below and up, we again obtain the binary form of $11_{10}$ to be $1011_2$. For integers with a fractional part, the divide-by-two may be used on the whole part, while multiply may be used in a similar manner on the fractional part.


%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
