\chapter{Constants, tuples, and types}
%\chapter{Numbers, Characters, and Strings}
All programs rely on processing of data, and an essential property of data is its \idx{type}. A \idx{literal} is a fixed value such as "3", and if we type the number \lstinline!3! in an interactive session at the input prompt, then F\# responds as follows,
\begin{lstlisting}[language=fsharp,caption={fsharpi, typing the number 3.}]
> 3;;    
val it : int = 3
\end{lstlisting}
What this means is that F\# has inferred the type to be \idx{lstinline!int!} and bound it to the identifier \idx{\lstinline{it}}. Rumor has it, that the identifier \lstinline|it| is an abbreviation for 'irrelevant'. For more on binding and identifiers see Chapter~\ref{chap:let}. Types matter, since the operations that can be performed on integers are quite different from those that can be performed on, e.g., strings. I.e.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, many representations of the number 3 but using different types.}]
> 3;;    
val it : int = 3
> 3.0;;
val it : float = 3.0
> '3';;
val it : char = '3'
> "3";;
val it : string = "3"
\end{lstlisting}
Each literal represent the number 3, but their types are different, and hence they are quite different values. The types \lstinline!int! for integer numbers, \lstinline!float! for floating point numbers, \lstinline!char! for characters, and \lstinline!string! for strings of characters are the most common types of literals. A table of all predefined types is given in Table~\ref{tab:primitiveTypes}.\jon{We should start by giving examples of int, xint, float, char, string literals without literal types. Then then binding to identifiers incl. the it identdifier.}
\begin{table}
  \centering
  \begin{tabularx}{\textwidth}{|l|l|>{\raggedright\arraybackslash}X|}
    \hline
    Metatype & Type name & Description\\
    \hline
    Boolean & bool & Boolean values true or false \\
    \hline
    Integer & \textbf{int} & Integer values from -2,147,483,648 to 2,147,483,647 \\
             & byte &Integer values from 0 to 255\\
             & sbyte &Integer values from -128 to 127\\
             & int8 &Synonymous with byte\\
             & uint8 &Synonymous with sbyte\\
             & int16 &Integer values from -32768 to 32767\\
             & uint16 &Integer values from 0 to 65535\\
             & int32 &Synonymous with int\\
             & uint32 & Integer values from 0 to 4,294,967,295\\
             & int64 &Integer values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\\
             & uint64 &Integer values from 0 to 18,446,744,073,709,551,615\\
             %& bignum &Integer not limited to 64 bits\\
             & nativeint &A native pointer as a signed integer\\
             & unativeint &A native pointer as an unsigned integer\\
    \hline
    Real &\textbf{float} & 64-bit IEEE 754 floating point value from $-\infty$ to $\infty$\\
             & double & Synonymous with float\\
             & single &A 32-bit floating point type\\
             & float32 &Synonymous with single\\
             & decimal &A floating point data type that has at least 28 significant digits\\
    \hline
    Character &\textbf{char} &Unicode character\\
             &\textbf{string} & Unicode sequence of characters\\
    \hline
    None &\textbf{unit} & No value denoted\\
    \hline
    Object &\textbf{obj} & An object\\
    \hline
    Exception &\textbf{exn} & An exception\\
    \hline
  \end{tabularx}
  \caption{List of basic types. The most commonly used types are highlighted in bold. For at description of integer see Appendix~\ref{sec:binary}, for floating point numbers see Appendix~\ref{sec:floatingPoint}, for ASCII and Unicode characters see Appendix~\ref{sec:characterSets}, for objects see Chapter~\ref{chap:oop}, and for exceptions see Chapter~\ref{chap:exceptions}.}
  \label{tab:primitiveTypes}
\end{table}
Besides these built-in types, F\# is designed such that it is easy to define new types. 

Humans like to use the \idx{decimal number} system for representing numbers. Decimal numbers are \idx{base} 10 means that for a number consisting of a sequence of digits separated by a \idx{decimal point}, where each \idx{digit} can have values $d \in \{0,1,2,\ldots,9\}$, and the value, which each digit represents is proportional to its position. As an example \lstinline!35.7! is a decimal number, whose value is $3\cdot 10^1+5\cdot 10^0+7\cdot 10^{-1}$. In F\# a decimal number is called a \idx{floating point number} and in this text we use \idx{Extended Backus-Naur Form} (\idx{EBNF}) to describe the grammar of F\#, the decimal number just described is given as,
%
\begin{lstlisting}[language=EBNF]
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
int = digit {digit}
float = int "." {digit}
\end{lstlisting}
%
meaning that a digit is either "0'' or "1" or \dots or "9'', an \lstinline!int! is 1 or more digits, and a \lstinline!float! is 1 or more digits, a dot and 0 or more digits. There is no space between the digits and between digits and the dot. So \lstinline!3!, \lstinline!049! are examples of integers, \lstinline!34.89! \lstinline!3.! are examples of floats, while \lstinline!.5! is neither.  Floating point numbers may alternatively be given using exponential notation, such as \lstinline!3.5e-4!, which means the number $3.5 10^{-4} = 0.0035$, so to describe this in EBNF we write
%
\begin{lstlisting}[language=EBNF]
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
int = digit {digit}
simpleFloat = int "." {digit}
expFloat = int ["." {digit}] ("e" | "E" ) ["+" | "-"] int
float = simpleFloat | expFloat
\end{lstlisting}
%

The basic unit of information in almost all computers is the binary digit or \idx{bit} for short. A \idx{binary} number consists of a sequence of binary digits separated by a decimal point, where each digit can have values $b \in \{0,1\}$, and the base is $2$. E.g., the binary number $101.01_2 = 1\cdot 2^2+0\cdot 2^1+1\cdot 2^0+0\cdot 2^{-1}+1\cdot 2^1=5.25$. Binary numbers are closely related to octal and hexadecimal numbers, where octals uses 8 as basis and can be written in binary using 3 bits, while hexadecimal numbers uses 16 as basis and can be written in binary using 4 bits. Octals and hexadecimals thus conviniently serve as shorthand for the much longer binary representation. F\# has a syntax for wrting integers on binary, octal, decimal, and hexadecimal numbers as,
%
\begin{lstlisting}[language=EBNF]
bDigit = "0" | "1"
oDigit  = bDigit | "2" | "3" | "4" | "5" | "6" | "7"
digit = oDigit | "8" | "9"
xDigit  = 
  digit 
  | "A" | "B" | "C" | "D" | "E" | "F" 
  | "a" | "b" | "c" | "d" | "e" | "f" 
int = digit {digit}
bitInt = "0" ("b" | "B") bDigit {bDigit}
octInt = "0" ("o" | "O") oDigit {oDigit}
hexInt = "0" ("x" | "X") xDigit {xDigit}
xint = bitInt | octInt | hexInt
\end{lstlisting}
%
For example \lstinline!367! is an \lstinline[language=EBNF]!int!, \lstinline!0b101101111!, \lstinline!0o557!, and \lstinline!0x16f! are examples of an \lstinline[language=EBNF]!xint! each representing the number 367, while \lstinline!0b12! are \lstinline!ff! neither an \lstinline[language=EBNF]!int! nor an \lstinline[language=EBNF]!xint!.

A character is a Unicode code point, see Appendix~\ref{sec:unicode} for a description of code points, and character literals enclosed in single quotation marks,\jon{Spec-4.0 p.28: \texttt{char-char} is missing option \texttt{unicodegraph-long} }
%
\begin{lstlisting}[language=EBNF]
escapeCodePoint = 
  "\u" xDigit xDigit xDigit xDigit
  | "\U" xDigit xDigit xDigit xDigit xDigit xDigit xDigit xDigit
  | "\" digit digit digit 
escapeChar = 
  "\" ("b" | "n" | "r" | "t" | "\" | '"' | "'" | "a" | "f" | "v")
  escapeCodePoint
char = "'" codePoint | escapeChar "'"
\end{lstlisting}
% 
where \lstinline[language=EBNF]!codePoint! is a UTF8 encoding of a char. The escape characters \lstinline[language=EBNF]{escapeChar} are code points or escape sequence starting with \textbackslash\ as illustrated in Table~\ref{tab:escapeChar}, and the trigraph \lstinline|\DDD| uses decimal specification for the first 256 unicode characters. The hexadecimal escape codes \lstinline|\uXXXX|, \lstinline|\UXXXXXXXX| allow for the full specification of any unicode character.
\begin{table}
  \centering
  \begin{tabular}{|c|l|l|}
    \hline
    Character& Escape sequence & Description\\
    \hline
    BS &\lstinline|\b|& Backspace\\
    LF &\lstinline|\n|&Newline\\
    CF &\lstinline|\r|&Carriage return\\
    HT &\lstinline|\t|&Horizontal tabulation\\
    \textbackslash &\lstinline|\\|&Backslash\\
     " &\lstinline|\"|&Quotation mark\\
    ' &\lstinline|\'|&Apostrophe\\
    BEL&\lstinline|\a|& Bell\\
    FF&\lstinline|\f|&Form feed\\
    VT &\lstinline|\v|&Vertical tabulation\\
    &\lstinline|\uXXXX|, \lstinline|\UXXXXXXXX|, \lstinline|\DDD|&Unicode character\\
    \hline
  \end{tabular}
  \caption{Escape characters. For the unicode characters 'X' are hexadecimal digits, while for tricode characters 'D' is a decimal character.}
  \label{tab:escapeChar}
\end{table}
Examples of a \lstinline[language=ebnf]!char! are \lstinline{'a'}, \lstinline{'_'}, \lstinline{'\n'}, and \lstinline{'\065'}.

A string is a sequence of characters enclosed in double quotation marks,\jon{Spec-4.0 p. 28-29: \texttt{simple-string-char} is undefined, \texttt{string-elem} is unused.}
%
 \begin{lstlisting}[language=EBNF]
   string-expr = '"' { char | LF | SP }  '"'
\end{lstlisting}
% 
Examples are \lstinline{"a"}, \lstinline{"this is a string"}, and \lstinline{"-&#\@"}. Newlines and following whitespaces are taken literally, but may be ignored by a preceding \textbackslash character. Further examples of strings are,
\begin{lstlisting}[language=fsharp,caption={fsharpi, examples of string literals.}]
> "abcde";;
val it : string = "abcde"
> "abc
- de";;
val it : string = "abc
de"
> "abc\
-  de";;
val it : string = "abcde"
> "abc\nde";;
val it : string = "abc
de"
\end{lstlisting}
%
The response is shown in double quotation marks, which are not part of the string. 

F\# supports \idx[literal type]{literal types}, where the type of a literal is indicated as a prefix og suffix as shown in the Table~\ref{tab:literalTypes}.
\begin{table}
  \centering
  \begin{tabularx}{\linewidth}{|l|l|l|X|}
    \hline
    type & EBNF & Literal examples & Comment \\
    \hline
    \lstinline!int!, \lstinline!int32! & \lstinline[language=ebnf]!(int | xint) ["l"]!  & \lstinline!3! & \\
    \lstinline!uint32! & \lstinline[language=ebnf]!(int | xint) ("u" | "ul")! & \lstinline!3u! & \\
    \lstinline!byte!, \lstinline!uint8! & \lstinline[language=ebnf]!((int | xint) "uy") | (char "B")!  & \lstinline!3uy!  & \\
    \lstinline!byte[]! & \lstinline[language=ebnf]!["@"] string "B"!  & \lstinline!"abc"B! and \lstinline!"@http:\\\\"B!  & \\
    \lstinline!sbyte!, \lstinline!int8! & \lstinline[language=ebnf]!(int | xint) "y"! & \lstinline!3y!  & \\
    \lstinline!int16! & \lstinline[language=ebnf]!(int | xint) "s"!  & \lstinline!3s!  & \\
    \lstinline!uint16! & \lstinline[language=ebnf]!(int | xint) "us"! & \lstinline!3us!  & \\
    \lstinline!int64! & \lstinline[language=ebnf]!(int | xint) "L"!  & \lstinline!3L!  & \\
    \lstinline!uint64! & \lstinline[language=ebnf]!(int | xint) ("UL" | "uL")!  & \lstinline!3UL! and \lstinline!3uL!  & \\
    \lstinline!bignum! & \lstinline[language=ebnf]!int "I"! & \lstinline!3I!  & \lstinline[language=ebnf]!int ("Q"|"R"|"Z"|"N"|"G")! not yet implemented in Mono.\\
    \lstinline!nativeint! & \lstinline[language=ebnf]!(int | xint) "n"! & \lstinline!3n!  & \\
    \lstinline!unativeint! & \lstinline[language=ebnf]!(int | xint) "un"!  & \lstinline!3un!  & \\
    \lstinline!float!, \lstinline!double! & \lstinline[language=ebnf]!float | (xint "LF")!  & \lstinline!3.0!  & \\
    \lstinline!single!, \lstinline!float32! & \lstinline[language=ebnf]!(float ("F" | "f")) | (xint "lf") !  & \lstinline!3.0f!  & \\
    \lstinline!decimal! &\lstinline[language=ebnf]!(float | int) ("M" | "m")! & \lstinline!3.0m! and \lstinline!3m!  & \\
    \lstinline!string! & \lstinline[language=ebnf]!["@"] string!  & \lstinline!"abc"! and \lstinline!@"http:\\\\"!  & \\
    \hline
  \end{tabularx}
  \caption{List of literal type. No spacing is allowed between the literal and the prefix or suffix.}
  \label{tab:literalTypes}
\end{table}
Examples are,
\begin{lstlisting}[language=fsharp,caption={fsharpi, Named and implied literals.}]
> 3;;
val it : int = 3
> 4u;; 
val it : uint32 = 4u
> 5.6;;
val it : float = 5.6
> 7.9f;;
val it : float32 = 7.9000001f
> 'A';;
val it : char = 'A'
> 'B'B;;
val it : byte = 66uy
> "ABC";;
val it : string = "ABC"
\end{lstlisting}
%
Strings literals may be \idx{verbatim} by preceding the string with '@', meaning that the escape sequences are not converted to their code point, e.g., 
\begin{lstlisting}[language=fsharp,caption={fsharpi, examples of string literals.}]
> @"abc\nde";;
val it : string = "abc\nde"
\end{lstlisting}
%
Verbatim literals containing double quotation marks are escaped with an extra double quotation mark, or the alternative tripple double quotation mark may be used, e.g.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, example of double quotation marks in verbatim string literals.}]
> @"This is a verbatim ""quote"".";;
val it : string = "This is a verbatim "quote"."
> """This is a verbatim "quote".""";; 
val it : string = "This is a verbatim "quote"."
\end{lstlisting}
%

Many basic types are compatible and the type of a literal may be changed by \idx{type casting}. E.g.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, casting an integer to a floating point number.},label=upcasting]
> float 3;;
val it : float = 3.0
\end{lstlisting}
which is a \lstinline!float!, since the integer number \lstinline|3| is casted to float resulting in a similar floating point value, in this case the float point number \lstinline|3.0|. As a technical detail, \lstinline|float| is here a function rather than a type, which takes the argument \lstinline|3| and returns the value \lstinline|3.0|.  For more on functions see Section~\ref{chap:functions}. Boolean values are often treated as the integer values 0 and 1, but no short-hand function names exists for their conversions. Instead use,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, casting booleans.}]
> System.Convert.ToBoolean 1;;
val it : bool = true
> System.Convert.ToBoolean 0;;
val it : bool = false
> System.Convert.ToInt32 true;;
val it : int = 1
> System.Convert.ToInt32 false;;
val it : int = 0
\end{lstlisting}
Here \lstinline|System.Convert.ToBoolean| is the identifier of a function \lstinline|ToBoolean|, which is a \idx{member} of the \idx{class} \lstinline|Convert| that is included in the \idx{namespace} \lstinline|System|. Namespaces, classes, and members are all part of Structured programming to be discussed in Part~\ref{part:structured}.

Type casting is often a destructive operation, e.g., type casting a \lstinline{float} to \lstinline{int} removes the part after the decimal point without rounding,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, Fractional part is removed by downcasting.}]
> int 357.6;;
val it : int = 357
\end{lstlisting}
%\fs{quickStartDownCast}{Fractional part is removed by downcasting.}
%
Here we type casted to a lesser type, in the sense that integers is a subset of floating point numbers, which is called \idx{downcasting}. The opposite is called \idx{upcasting} is often non-destructive, as Listing~\ref{upcasting} showed, where an integer was casted to a float while retaining its value. As a side note, \idx{rounding} a number $y.x$, where $y$ is the \idx{whole part} and $x$ is the \idx{fractional part}, is the operation of mapping numbers in the interval $y.x \in [y.0,y.5)$ to $y$ and $y.x\in [y.5,y+1)$ to $y+1$. This can be performed by downcasting as follows,
%
\begin{lstlisting}[language=fsharp,label=rounding,caption={fsharpi, Fractional part is removed by downcasting.}]
> int (357.6 + 0.5);;
val it : int = 358
\end{lstlisting}
%\fs{rounding}{The rounding function may be obtained by downcasting.}
%
since if $y.x\in [y.0, y.5)$, then $y.x+0.5\in [y.5, y+1)$, from which downcasting removes the fractional part resulting in $y$. And if $y.x\in [y.5, y+1)$, then $y.x+0.5\in [y+1,y+1.5)$, from which downcasting removes the fractional part resulting in $y+1$. Hence, the result is rounding. 

If parentheses are omitted in Listing~\ref{rounding}, then F\# will interpret the expression as \lstinline|(int 357.6) + 0.5|, which is erroneous, since addition of an integer with a float is undefined. This is an example of precedence, i.e., function evaluation takes precedence over addition meaning that it is performed before addition. Consider the arithmetic expression, whose result is bound to \lstinline|a| by
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, a simple arithmetic expression.}]
> 3 + 4 * 5;;
val it : int = 23
\end{lstlisting}
Here, the addition and multiplication functions are shown in \idx{infix notation} with the \idx{operator} tokens \token{+} and \token{*}. To arrive at the resulting value 23, F\# has to decide in which order to perform the calculation. There are 2 possible orders, \lstinline|3 + (4 * 5)| or \lstinline|(3 + 4) * 5|, which gives different results. For integer arithmetic, the correct order is of course to multiply before addition, and we say that multiplication takes \idx{precedence} over addition. Every atomic operation that F\# can perform is ordered in terms of its precedences, and for some common built-in operators shown in Table~\ref{tab:operatorPrecedence}, the precedence is shown by the order they are given in the table.
\begin{table}
  \centering
  \begin{tabularx}{\linewidth}{|l|l|l|X|}
    \hline
    Operator & Associativity & Example & Description\\
    \hline
     \lstinline|+op|, \lstinline|-op|, \lstinline|\~\~\~op| & Left & \lstinline|-3| & Unary identity, negation, and bitwise negation operator\\
     \hline
    \lstinline|f x| & Left & \lstinline|f 3| & Function application\\
    \hline
    \lstinline|op ** op| & Right & \lstinline| 3.0 ** 2.0| & Exponent\\ 
    \hline
    \lstinline|op * op|, \lstinline|op / op|, \lstinline|op \% op| & Left & \lstinline| 3.0 / 2.0| & Multiplication, division and remainder\\
    \hline
    \lstinline|op + op|, \lstinline|op - op| & Left & \lstinline|3.0 + 2.0| & Addition and subtraction binary operators\\
    \hline
     \lstinline|op \^\^\^ op| & Right & \lstinline|0xAAuy \^\^\^ 0xFFuy| & bitwise exclucive or\\
    \hline
    \begin{minipage}[t]{0.25\linewidth}
      \lstinline|op < op|, \lstinline|op <= op|,\\
      \lstinline|op > op|, \lstinline|op >= op|,\\
      \lstinline|op = op|, \lstinline|op <> op|,\\
      \lstinline|op <<< op|, \lstinline|op >>> op|,\\
      {\lstinline|op &&& op|}, \lstinline!op ||| op!,\\
    \end{minipage}
    & Left & \lstinline|3 > 5| & Comparison operators, bitwise shift, and bitwise 'and' and 'or'.\\
    \hline
    {\lstinline|&&|} & Left & {\lstinline|true && true|} & Boolean and\\
    \hline
    \lstinline+||+ & Left & \lstinline+true || true+ & Boolean or\\
    \hline
  \end{tabularx}
  \caption{Some common operators, their precedence, and their associativity. Rows are ordered from highest to lowest precedences, such that \lstinline|op * op| has higher precedence than \lstinline|op + op|. Operators in the same row has same precedence. }
  \label{tab:operatorPrecedence}
\end{table}
Associativity implies the order in which calculations are performed for operators of same precedence. For some operators and type combinations association matters little, e.g., multiplication associates to the left and exponentiation associates to the right, e.g., in\jon{Spec-4.0, Table 18.2.1 appears to be missing boolean 'and' and 'or' operations. Section 4.4 seems to be missing \&\&\& and ||| bitwise operators.}
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, precedences rules define implicite parantheses.}]
> let a = 3.0*4.0*5.0
- let b = (3.0*4.0)*5.0
- let c = 3.0*(4.0*5.0);;

val a : float = 60.0
val b : float = 60.0
val c : float = 60.0

> let d = 4.0 ** 3.0 ** 2.0
- let e = (4.0 ** 3.0) ** 2.0
- let f = 4.0 ** (3.0 ** 2.0);;

val d : float = 262144.0
val e : float = 4096.0
val f : float = 262144.0
\end{lstlisting}
the expression for \lstinline|a| is interpreted as \lstinline|b| but gives the same results as \lstinline|c| since association does not matter for multiplication of numbers, but the expression for \lstinline|d| is interpreted as \lstinline|f| which is quite different from \lstinline|e|.

A less common notation is to define bindings for expressions using the \idx{\keyword{in}} keyword, e.g.,
%
\fs{numbersIn}{The identifier \lstinline!p! is only bound in the nested scope following the keyword \keyword{in}.}
%
Here \lstinline|p| is only bound in the \idx{scope} of the expression following the \keyword{in} keyword, in this the \lstinline|printfn| statement, and \lstinline|p| is unbound in lines that follows.
\begin{comment}
  Here the use of indentation to define a sequence of expressions
  % 
  \fs{numbersInWIndentation}{The identifier \lstinline!p! is only bound in the nested scope following the keyword \keyword{in}.}
  % 
\end{comment}

\section{Booleans}
Boolean arithmetic is the basis of almost all computers and particularly important for controlling program flow, which will be discussed in Chapter~\ref{chap:flow}. Boolean values are one of 2 possible values, true or false, which is also sometimes written as 1 and 0. Two basic operations on boolean values are '\idx{and}' often also written as multiplication, and '\idx{or}' often written as addition, and '\idx{not}' often written as a bar above the value. All possible combination of input on these values can be written on tabular form, known as a \idx{truth table}, shown in Table~\ref{tab:truthTable}.
\begin{table}
  \centering
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    $a$ & $b$ & $a\cdot b$& $a + b$&$\bar{a}$\\
    \hline
    0&0&0&0&1\\
    0&1&0&1&1\\
    1&0&0&1&0\\
    1&1&1&1&0\\
    \hline
  \end{tabular}
  \caption{Truth table for boolean 'and', 'or', and 'not' operators. Value 0 is false and 1 is true.}
  \label{tab:truthTable}
\end{table}
That is, the multiplication and addition are good mnemonics for remembering the result of the 'and' and 'or' operators. In F\# the values \lstinline|true| and \lstinline|false| are used, and the operators \lstinline|&&| for 'and', \lstinline+||+ for 'or', and the function \lstinline|not| for 'not', such that the above table is reproduced by,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, boolean operators and truth tables.}]
> let t = true
- let f = false
- printfn "a     b     a*b   a+b   not a"                                       
- printfn "%A %A %A %A %A" f f (f && f) (f || f) (not f)
- printfn "%A %A  %A %A  %A" f t (f && t) (f || t) (not f)
- printfn "%A  %A %A %A  %A" t f (t && f) (t || f) (not t)
- printfn "%A  %A  %A  %A  %A" t t (t && t) (t || t) (not t);;
a     b     a*b   a+b   not a
false false false false true
false true  false true  true
true  false false true  false
true  true  true  true  false

val t : bool = true
val f : bool = false
val it : unit = ()
\end{lstlisting}
%
Careful spacing in the format string of the \lstinline|printfn| function was used to align columns. Next section will discuss more elegant formatting options.

\section{Integers and Reals}
The set of integers and reals are infinitely large, and since all computers have limited resources, it is not possible to represent these sets in their entirety. The various integer and floating point types listed in Table~\ref{tab:primitiveTypes} are finite subset where the integer types have been reduced by limiting their ranges and the floating point types have been reduced by sampling the space of reals. An in-depth description of integer and floating point implementations can be found in Appendix~\ref{app:numbers}. The \keyword{int} and \keyword{float} are the most common types. 

For integers the following arithmetic operators are defined: 
\begin{description}
\item[\texttt{+op}, \texttt{-op}:] These are unary plus and minus operators, and plus has no effect, but minus changes the sign, e.g.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, unary integer negation operator.}]
> let a = 5       
- let b = -a;;

val a : int = 5
val b : int = -5
\end{lstlisting}
\item[\lstinline|op + op|, \lstinline|op - op|, \lstinline|op * op|:] These are binary operators, where addition, subtraction and multiplication performs the usual operations, 
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, binary integer addition, subtraction, and multiplication operators.}]
> let a = 7 + 3
- let b = 7 - 3
- let c = 7 * 3;;

val a : int = 10
val b : int = 4
val c : int = 21
\end{lstlisting}
\item[\lstinline|op / op|, \lstinline|op \% op|:] These are binary operators, and division performs integer division, where the fractional part is discarded after division, and the \lstinline|\%| is the remainder operator, which calculates the remainder after integer division,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, binary integer division and remainder operators.}]
> let a = 7 / 3
- let b = 7 % 3;;

val a : int = 2
val b : int = 1
\end{lstlisting}
Together integer division and remainder is a lossless representation of the original number as,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, binary division and remainder is a lossless representation of an integer.}]
> let x = 7
- let whole = x / 3
- let remainder = x % 3
- let y = whole * 3 + remainder;;

val x : int = 7
val whole : int = 2
val remainder : int = 1
val y : int = 7
\end{lstlisting}
And we see that \lstinline|x| and \lstinline|y| is bound to the same value.
\end{description}
Integer exponentiation is not defined as an operator, but this is available the built-in function \lstinline|pown|, e.g.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, integer exponentiation function, and the irrelevant identifier.}]
> pown 2 5;;
val it : int = 32
\end{lstlisting}
which is equal to $2^5$. Note that when no let statement is used in conjunction with an expression then F\# automatically binds the result to the \idx{\lstinline{it}} identifier, i.e., the above is equal to
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, the equivalent to the irrelevant identifier.}]
  > let it = pown 2 5;;

val it : int = 32
\end{lstlisting}
Rumor has it, that the identifier \lstinline|it| is an abbreviation for 'irrelevant'.

Performing arithmetic operations on \keyword{int} types requires extra care, since the result may cause \idx{overflow}, \idx{underflow}, and even exceptions, e.g., the range of the integer type \lstinline|sbyte| is $[-128\ldots 127]$, which causes problems in the following example,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, adding integers may cause overflow.},label=overflow]
> let a = 100y 
- let b = 30y 
- let c = a+b;;

val a : sbyte = 100y
val b : sbyte = 30y
val c : sbyte = -126y
\end{lstlisting}
Here $100+30=130$, which is larger than the biggest \lstinline|sbyte|, and the result is an overflow. Similarly, we get an underflow, when the arithmetic result falls below the smallest value storable in an \lstinline|sbyte|,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, subtracting integers may cause underflow}]
> let a = -100y  
- let b = -30y  
- let c = a+b;;

val a : sbyte = -100y
val b : sbyte = -30y
val c : sbyte = 126y
\end{lstlisting}
Notice that neither overflow nor underflow error gave rise to an error message, which is why such bugs are difficult to find. 
 Dividing any non-zero number with 0 is infinite, which is also outside the domain of any of the integer types, but in this case, F\# casts an\idx{exception},
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, integer division by zero causes an exception run-time error.}]
> 3/0;; 
System.DivideByZeroException: Attempted to divide by zero.
  at <StartupCode$FSI_0007>.$FSI_0007.main@ () <0x6b78180 + 0x0000e> in <filename unknown>:0 
  at (wrapper managed-to-native) System.Reflection.MonoMethod:InternalInvoke (System.Reflection.MonoMethod,object,object[],System.Exception&)
  at System.Reflection.MonoMethod.Invoke (System.Object obj, BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) <0x1a55ba0 + 0x000a1> in <filename unknown>:0 
Stopped due to error
\end{lstlisting}
The output looks daunting at first sight, but the first and last line of the error message are the most important parts, which tells us what exception was cast and why the program stopped. The middle are technical details concerning which part of the program caused this, and can be ignored for the time being. Exceptions are a type of \idx{run-time error}, and are treated in Chapter~\ref{chap:exceptions}

Integers can also be written in binary, octal, or hexadecimal format using the prefixes \lstinline|0b|, \lstinline|0o|, and \lstinline|0x|, e.g.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, integer types may be specified as binary, octal, and hexadecimal numbers.}]
> let a = 0b1011
- let b = 0o13
- let c = 0xb;;

val a : int = 11
val b : int = 11
val c : int = 11
\end{lstlisting}
For a description of binary representations see Appendix~\ref{sec:binary}. The overflow error in Listing~\ref{overflow} can be understood in terms of the binary representation of integers: In binary, $130=10000010_2$, and this binary pattern is interpreted differently as \lstinline{byte} and \lstinline{sbyte},
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, the left most bit is interpreted differently for signed and unsigned integers, which gives rise to potential overflow errors.}]
> let a = 0b10000010uy
- let b = 0b10000010y;;

val a : byte = 130uy
val b : sbyte = -126y
\end{lstlisting}
That is, for signed bytes, the left-most bit is used to represent the sign, and since the addition of $100=01100100_2$ and $30=00011110_b$ is $130=10000010_2$ causes the left-most bit to be used, then this is wrongly interpreted as a negative number, when stored in an \lstinline{sbyte}.

For binary arithmatic on integers, the following operators are available:
\begin{description}
\item[\texttt{op $<<<$ n}:] Bitwise left shift, shifts any integer bit pattern \lstinline|n| positions to the left insert 0's to right.
\item[\texttt{op $>>>$ n}:] Bitwise left right, shifts any integer bit pattern \lstinline|n| positions to the right insert 0's to left.
\item[\texttt{op1 \&\&\& op2}:] Bitwise 'and', returns the result of taking the boolean 'and' operator position-wise.
\item[\texttt{op ||| op}:] Bitwise 'or', as 'and' but using the boolean 'or' operator
\item[\texttt{op1 $\sim\sim\sim$ op1}:] Bitwise xor, which is returns the result of the boolean 'xor' operator defined by,
  \begin{center}
    \begin{tabular}{|l|l|l|}
      a&b& a xor b\\
      0 & 0 & 0\\
      0 & 1 & 1\\
      1 & 0 & 1\\
      0 & 1 & 0\\
    \end{tabular}
  \end{center}
position-wise. 
\end{description}
Unfortunately, there are no built-ind functions outputting integers on binary form, so to understand the output of the following program,
\begin{lstlisting}[language=fsharp,caption={fsharpi, the left most bit is interpreted differently for signed and unsigned integers, which gives rise to potential overflow errors.}]
> let a = 0b11000011uy  
- let b = a <<< 1
- let c = a >>> 1
- let d = ~~~a
- let e = a ^^^0b11111111uy;;

val a : byte = 195uy
val b : byte = 134uy
val c : byte = 97uy
val d : byte = 60uy
val e : byte = 60uy
\end{lstlisting}
we must consider the 8-bit binary form of the unsigned integers: $195 = 11000011_2$, $134 = 10000110_2$, $97 = 01100001_2$, and $60 = 00111100_2$, which agrees with the definitions. \jon{mention somewhere that comparison operators will be treated later.}

For floating point numbers the following arithmetic operators are defined: 
\begin{description}
\item[\texttt{+op}, \texttt{-op}:] These are unary plus and minus operators, and plus has no effect, but minus changes the sign, e.g.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, unary floating point negation operator.}]
> let a = 5.0 
- let b = -a;;

val a : float = 5.0
val b : float = -5.0
\end{lstlisting}
\item[\lstinline|op + op|, \lstinline|op - op|, \lstinline|op * op|, \lstinline|op / op|:] These are binary operators, where addition, subtraction, multiplication, and division performs the usual operations, 
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, binary floating point addition, subtraction, multiplication, and division operators.}]
> let a = 7.0 + 3.0
- let b = 7.0 - 3.0
- let c = 7.0 * 3.0
- let d = 7.0 / 3.0;;

val a : float = 10.0
val b : float = 4.0
val c : float = 21.0
val d : float = 2.333333333
\end{lstlisting}
\item[\lstinline|op \% op|:] The binary remainder operator, and division performs integer division, where the fractional part is discarded after division, and the \lstinline|\%| is the remainder operator, which calculates the remainder after integer division,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, binary floating point division and remainder operators.}]
> let a = 7.0 / 3.0
- let b = 7.0 % 3.0;;

val a : int = 2.0
val b : int = 1.0
\end{lstlisting}
The remainder for floating point numbers can be fractional, but division, rounding, and remainder is still a lossless representation of the original number as,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, floating point division, truncation, and remainder is a lossless representation of a number.}]
> let x = 7.0
- let division = x / 3.2
- let whole = float (int (division + 0.5))
- let remainder = x % 3.2
- let y = whole * 3.2 + remainder;;

val x : float = 7.0
val division : float = 2.1875
val whole : float = 2.0
val remainder : float = 0.6
val y : float = 7.0
\end{lstlisting}
And we see that \lstinline|x| and \lstinline|y| is bound to the same value.  
\item[\texttt{op ** op}:] In spite of an unusual notation, the binary exponentiation operator performs the usual calculation,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, binary floating point exponentiation.}]
> let a = 2.0 ** 5.0;;

val a : float = 32.0
\end{lstlisting}
which is equal to $2^5$.
\end{description}

Arithmetic using \lstinline|float| will not cause over- and underflow problems, since the IEEE 754 standard includes the special numbers $\pm\infty$ and NaN. E.g.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, floating point numbers include infinity and Not-a-Number}]
> let a = 1.0/0.0  
- let b = 0.0/0.0;;

val a : float = infinity
val b : float = nan
\end{lstlisting}
However, the \lstinline|float| type has limite precision, since there is only a finite number of numbers that can be stored in a float. E.g.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, floating point arithmatic has finite precision.}]
> let a = 357.8      
- let b = a+0.1      
- let c = b+0.1      
- let d = c - 358.0;;

val a : float = 357.8
val b : float = 357.9
val c : float = 358.0
val d : float = 5.684341886e-14
\end{lstlisting}
Hence, although \lstinline|c| appears to be correctly calculated, by the subtraction we see, that the value bound in \lstinline|c| is not exactly the same as \lstinline|358.0|, and the reason is that the neither \lstinline|357.8| nor \lstinline|0.1| are exactly representable as a \lstinline|float|, which is why the repeated addition accumulates a small representation error.

F\# allows for assigning \idx{unit of measure} to the following types,
\begin{quote}
  \mbox{\lstinline{sbyte},}
  \mbox{\lstinline{int},}
  \mbox{\lstinline{int16},}
  \mbox{\lstinline{int32},}
  \mbox{\lstinline{int64},}
  \mbox{\lstinline{single},}
  \mbox{\lstinline{float32},}
  \mbox{\lstinline{float},} and
  \mbox{\lstinline{decimal}.}
\end{quote}
by using the syntax,
%
\begin{lstlisting}[language=EBNF]
"[<Measure>] type" unit-name [ "=" measure ]
\end{lstlisting}
%
and then use \lstinline[language=EBNF]|"<" unit-name ">"| as suffix for literals. In Figure~\ref{fig:unitOfMeasureTypes}
E.g., defining unit of measure 'm' and 's', then we can make calculations like,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, floating point and integer numbers may be assigned unit of measures.}]
> [<Measure>] type m
- [<Measure>] type s 
- let a = 3<m/s^2>
- let b = a * 10<s>
- let c = 4 * b;;

[<Measure>]
type m
[<Measure>]
type s
val a : int<m/s ^ 2> = 3
val b : int<m/s> = 30
val c : int<m/s> = 120
\end{lstlisting}
However, if we mixup unit of measures under addition, then we get an error,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, unit of measures adds an extra layer of types for syntax checking at compile time.}]
> [<Measure>] type m 
- [<Measure>] type s 
- let a = 1<m>
- let b = 1<s>
- let c = a + b;;

  let c = a + b;;
  ------------^

/Users/sporring/repositories/fsharpNotes/stdin(63,13): error FS0001: The unit of measure 's' does not match the unit of measure 'm'
\end{lstlisting}
Unit of measures allow for \token{*}, \token{/}, and \token{^}\jon{Spec-4.0: this notation is inconsistent with \texttt{**} for float exponentiation.} for multiplication, division and exponentiation. Values with units can be casted to \idx{unit-less} values by casting, and back again by multiplication as,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, type casting unit of measures.}]
> [<Measure>] type m      
- let a = 2<m>            
- let b = int a           
- let c = b * 1<m>;;

[<Measure>]
type m
val a : int<m> = 2
val b : int = 2
val c : int<m> = 2
\end{lstlisting}
Compound symbols can be declared as,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, aggregated unit of measures.}]
> [<Measure>] type s         
- [<Measure>] type m
- [<Measure>] type kg
- [<Measure>] type N = kg * m / s^2;;

[<Measure>]
type s
[<Measure>]
type m
[<Measure>]
type kg
[<Measure>]
type N = kg m/s ^ 2
\end{lstlisting}
For fans of the metric system there is the International System of Units, and these are built-in in \lstinline|Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols| and give in Table~\ref{tab:siUnits}.
\begin{table}
  \centering
  \begin{tabularx}{0.75\linewidth}{|l|X|}
    \hline
    Unit & Description \\
    \hline
    \lstinline|A| & Ampere, unit of electric current.\\
    \lstinline|Bq|&Becquerel, unit of radioactivity.\\
    \lstinline|C|&Coulomb, unit of electric charge, amount of electricity.\\
    \lstinline|cd|&Candela, unit of luminous intensity.\\
    \lstinline|F|&Farad, unit of capacitance.\\
    \lstinline|Gy|&Gray, unit of an absorbed dose of radiation.\\
    \lstinline|H|&Henry, unit of inductance.\\
    \lstinline|Hz|&Hertz, unit of frequency.\\
    \lstinline|J|&Joule, unit of energy, work, amount of heat.\\
    \lstinline|K|&Kelvin, unit of thermodynamic (absolute) temperature.\\
    \lstinline|kat|&Katal, unit of catalytic activity.\\
    \lstinline|kg|&Kilogram, unit of mass.\\
    \lstinline|lm|&Lumen, unit of luminous flux.\\
    \lstinline|lx|&Lux, unit of illuminance.\\
    \lstinline|m|&Metre, unit of length.\\
    \lstinline|mol|&Mole, unit of an amount of a substance.\\
    \lstinline|N|&Newton, unit of force.\\
    \lstinline|ohm|&Unitnames.o SI unit of electric resistance.\\
    \lstinline|Pa|&Pascal, unit of pressure, stress.\\
    \lstinline|s|&Second, unit of time.\\
    \lstinline|S|&Siemens, unit of electric conductance.\\
    \lstinline|Sv|&Sievert, unit of dose equivalent.\\
    \lstinline|T|&Tesla, unit of magnetic flux density.\\
    \lstinline|V|&Volt, unit of electric potential difference, electromotive force.\\
    \lstinline|W|&Watt, unit of power, radiant flux.\\
    \lstinline|Wb|&Weber, unit of magnetic flux.\\
    \hline
  \end{tabularx}
  \caption{International System of Units.}
  \label{tab:siUnits}
\end{table}
Hence, using the predefined unit of seconds, we may write,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, SI unit of measures are built-in.}]
> let a = 10.0<Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols.s>;;

val a : float<Data.UnitSystems.SI.UnitSymbols.s> = 10.0
\end{lstlisting}
To make the use of these predefined symbols easier, we can import them into the present scope by the \idx{\keyword{open}} keyword,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, simpler syntax by importing, but beware of namespace polution.}]
> open Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols;;
> let a = 10.0<s>;;

val a : float<s> = 10.0
\end{lstlisting}
The \keyword{open} keyword should be used with care, since now all the bindings in \lstinline|Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols| have been imported into the present scope, and since we most likely do not know, which bindings have been used by the programmers of \lstinline|Microsoft.FSharp.Data.UnitSystems.SI.UnitSymbols|, we do not know which identifiers to avoid, when using \keyword{let} statements. We have obtained, what is known as \idx{namespace pollution}. Read more about namespaces in Part~\ref{part:structured}.

Using unit of measures is advisable for calculations involving real-world values, since some semantical errors of arithmetic expressions may be discovered by checking the resulting unit of measure.

\jon{add comparsion operators!}

\section{Chars and Strings}
***

Character arithmatic is most often done by in integer space. A typical example is conversion of case, e.g., to convert the lowercase character 'z' to uppercase, we use the \idx{ASCIIbetical order} and add the difference between any Basic Latin Block letters in upper- and lowercase as \lstinline{integers} and cast back to \lstinline{char}, e.g.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, converting case by casting and integer arithmatic.}]
> char (int 'z' - int 'a' + int 'A');; 
val it : char = 'Z'
\end{lstlisting}
%

*****

Operations on \lstinline{string} is quite rich. The most simple is concatenation using \token{+} token, e.g.,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, example of string concatenation.}]
> let a = "hello"      
- let b = "world"      
- let c = a + " " + b;;

val a : string = "hello"
val b : string = "world"
val c : string = "hello world"
\end{lstlisting}
%
Characters and strings cannot be concatenated, which is why the above example used the string of  a space \lstinline|" "| instead of the space character \lstinline|' '|. The characters of a string may be indexed as,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, example of string indexing.}]
> let a = "abcdefg"
- let b = a.[0]
- let c = a.[3]
- ;;

val a : string = "abcdefg"
val b : char = 'a'
val c : char = 'd'
\end{lstlisting}
%
The \idx{dot notation} is an example of Structured programming, where technically \lstinline|a| is an immutable \idx{object} of \idx{class} \lstinline|string|, and \lstinline|[]| is an object \idx{method}. For more on object, classes, and methods see Chapter~\ref{chap:oop}.  Notice, that the first character has index 0, and to get the last character in a string, we use the string's lenght property as,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, string length attribute and string indexing.}]
> let a = "abcdefg"                                                                             
- let l = a.Length                                                       
- let first = a.[0]
- let last = a.[l-1];;

val a : string = "abcdefg"
val l : int = 7
val first : char = 'a'
val last : char = 'g'
\end{lstlisting}
%
Notice, since index counting starts at 0, and the string length is 7, then the index of the last character is 6. An alternative notation for indexing is to use the property \lstinline|Char|, and in the example \lstinline|a.[3]| is the same as \lstinline|a.Char 3|. The is a long list of built-in functions in \lstinline|System.String| for working with strings, some of which will be discussed in Chapter~\ref{sec:system.string}.

%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
