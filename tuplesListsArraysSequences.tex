\chapter{Tuples, Lists, Arrays, and Sequences}
\label{chap:lists}\jon{possibly add maps and sets as well.}
F\# is tuned to work with lists, and there are several built-in lists with various properties making them useful for different tasks. E.g.,
%
\fs{tuplesQuadraticEq}{Using tuples to gather values.}
%
F\# has 4 built-in list types: tuples, lists, arrays, and sequences following this syntax:
%
\begin{lstlisting}[language=ebnf]
tupleList = expr | expr "," tupleList
comp-or-range-expr = comp-expr | short-comp-expr | range-expr
short-comp-expr = "for" pat "in" (expr | range-expr) "->" expr
range-exp = expr ".." expr [".." expr]
comp-expr =
  ("let" | "let!") pat "=" expr "in" comp-expr
  | ("do" | "do!") expr "in" comp-expr
  | ("use" | "use!") pat = expr "in" comp-expr
  | ("yield" | "yield!") expr
  | ("return" | "return!") expr
  | "if" expr "then" comp-expr ["else" comp-expr]
  | "match" expr "with" comp-rules
  | "try" comp-expr "with" comp-rules
  | "try" comp-expr "finally" expr
  | "while" expr "do" expr ["done"]
  | "for" ident "=" expr "to" expr "do" comp-expr ["done"]
  | "for" pat "in" expr-or-range-expr "do" comp-expr ["done"]
  | comp-expr ";" comp-expr
  | expr
comp-rule = pat pattern-guardopt "->" comp-expr
comp-rules = comp-rule | comp-rule '|' comp-rules
expr = ... 
  | tupleList
  | "[" comp-or-range-expr "]" (* computed list expression *)
  | "[|" comp-or-range-expr "|]" (* computed array expression *)
  | expr "{" comp-or-range-expr "}" (* computation expression *)
  | ...
\end{lstlisting}
%
\jon{Spec-4.0: grammar for list and array expressions are subsets of computed list and array expressions.}Tuples are a direct extension of constants. They are immutable and do not have concatenations nor indexing operations. This is in contrast to lists. Lists are also immutable, but have a simple syntax for concatenation and indexing. Arrays are mutable lists, and support higher order structures such as tables and 3 dimensional arrays. Sequences are like lists, but with the added advantage of a very flexible construction mechanism, and the option of representing infinite long sequences. In the following, we will present these datastructures in detail.

\section{Tuples}
\idx[tuple]{Tuples} are unions of immutable types, 
%
\begin{lstlisting}[language=ebnf]
tupleList = expr | expr "," tupleList
expr = ... 
  | tupleList
  | ...
\end{lstlisting}
%
and the they are identified by the \lexeme{,} lexeme. Most often the tuple is enclosed in parantheses, but that is not required. Consider the tripel, also known as a 3-tuple, \lstinline!(2,true,"hello")! in interactive mode,
%
\fso{tuple}{Definition of a tuple.}
%
The values \lstinline!2!, \lstinline!true!, and \lstinline!"hello"! are \idx[member]{members}, and the number of elements of a tuple is its \idx{length}. From the response of F\# we see that the tuple is inferred to have the type \lstinline!int * bool * string!, where the \lexeme{*} is cartesian product between the three sets.  Notice, that tuples can be products of any types and have lexical scope like value and function bindings. Notice also, that a tuple may be printed as a single entity by the \lstinline!%A! placeholder. In the example, we bound \lstinline!tp! to the tuple, the opposite is also possible,
%
\fso{tupleDeconstruction}{Definition of a tuple.}
%
In this a function is defined that takes 1 argument, a 3-tuple, and which is bound to a tuple with 3 named members. Since we used the \lstinline!%A! placeholder in the \lstinline!printfn! function, then the function is generic and can be called with 3-tuples of different types. Note, \advice{don't confuse a function of $n$ arguments with a function of an $n$-tuple.}  The later has only 1 argument, and the difference is the \lexeme{,}'s. Another example is \lstinline!let solution a b c = ...!, which is the beginning of the function definition in Listing~\ref{tuplesQuadraticEq}. It is a function of 3 arguments, while \lstinline!let solution (a, b, c) = ...! would be a function of 1 argument, which is a 3-tuple. Functions of several arguments makes currying easy, i.e., we could define a new function which fixes the quadratic term to be 0 as \lstinline!let solutionToLinear = solution 0.0!, that is, without needing to specify anything else. With tuples, we would need the slightly more complicated, \lstinline!let solutionToLinear (b, c) = solution (0.0, b, c)!.

Tuples comparison are defined similarly as strings. Tuples of different lengths are different. For tuples of equal length, then they are compared element by element. E.g., \lstinline!(1,2) = (1,3)! is false, while \lstinline!(1,2) = (1,2)! is true. The \lexeme{<>} operator is the boolean negation of the \lexeme{=} operator. For the \lexeme{<} , \lexeme{<=}, \lexeme{>}, and \lexeme{>=} operators, the strings are ordered alphabetically like, such that \lstinline!('a', 'b', 'c') < ('a', 'b', 's') && ('a', 'b', 's') <  ('c', 'o', 's')! is true, that is, the \lexeme{<} operator on two tuples is true, if the left operand should come before the right, when sorting alphabetically like. 
%
\fs{tupleCompare}{Tuples are compared as strings are compared alphabetically.}
%
The algorithm for deciding the boolean value of \lstinline!(a1, a2) < (b1, b2)! is as follows: we start by examining the first elements, and if \lstinline!la1! and \lstinline!b1! are different, then the \lstinline!(a1, a2) < (b1, b2)! is equal to \lstinline!a1 < b1!. If \lstinline!la1! and \lstinline!b1! are equal, then we move onto the next letter and repeat the investigation. The \lexeme{<=}, \lexeme{>}, and \lexeme{>=} operators are defined similarly.

Binding tuples to mutuals does not make the tuple mutable, e.g.,
%
\fs{tupleOfMutables}{A mutable change value, but the tuple defined by it does not refer to the new value.}
%
However, tuples may be mutual such that new tuple values can be assigned to it, e.g., in the Fibonacci example, we can write a more compact script by using mutable tuples and the \keyword{fst} and \keyword{snd} functions as follows.
%
\fs{fibTuple}{Calculating Fibonacci numbers using mutable tuple.}
%
In this example, the central computation has been packed into a single line, \lstinline!prev <- (snd prev, (fst prev) + (snd prev))!, where both the calculation of $\text{fib}(n) = \text{fib}(n-2) + \text{fib}(n-1)$ and the rearrangement of memory to hold the new values $\text{fib}(n)$ and $\text{fib}(n-1)$ based on the old values $\text{fib}(n-2) + \text{fib}(n-1)$. While this may look elegant and short there is the risk of \idx{obfuscation}, i.e., writing compact code that is difficult to read, and in this case, an unprepared reader of the code may not easily understand the computation nor appreciate its elegance without an accompanying explanation.  Hence, \advice{always keep an eye out for compact and concise ways to write code, but never at the expense of readability.}

\section{Lists}
Lists are unions of immutable values of the same type and have a more flexible structure than tuples. Its grammar follows \idx{computational expressions}, which is very rich and shared with arrays and sequences:
\begin{lstlisting}[language=ebnf]
comp-or-range-expr = comp-expr | short-comp-expr | range-expr
short-comp-expr = "for" pat "in" (expr | range-expr) "->" expr
range-exp = expr ".." expr [".." expr]
comp-expr =
  ("let" | "let!") pat "=" expr "in" comp-expr
  | ("do" | "do!") expr "in" comp-expr
  | ("use" | "use!") pat = expr "in" comp-expr
  | ("yield" | "yield!") expr
  | ("return" | "return!") expr
  | "if" expr "then" comp-expr ["else" comp-expr]
  | "match" expr "with" comp-rules
  | "try" comp-expr "with" comp-rules
  | "try" comp-expr "finally" expr
  | "while" expr "do" expr ["done"]
  | "for" ident "=" expr "to" expr "do" comp-expr ["done"]
  | "for" pat "in" expr-or-range-expr "do" comp-expr ["done"]
  | comp-expr ";" comp-expr
  | expr
comp-rule = pat pattern-guardopt "->" comp-expr
comp-rules = comp-rule | comp-rule '|' comp-rules
expr = ... 
  | "[" comp-or-range-expr "]" (* computed list expression *)
  | ...
\end{lstlisting}
Simple examples of a list grammars are, \lstinline[language=ebnf]![expr; expr; ... ; expr]!, \lstinline[language=ebnf]![expr ".." expr]!, \lstinline[language=ebnf]![expr ".." expr ".." expr]!, e.g., an explicit list \lstinline!let lst = [1; 2; 3; 4; 5]!, which may be written shortly as range \lstinline!let lst = [1 .. 5]!, and ranges may include a step size \lstinline!let lst = [1 .. 2 .. 5]!, which is the same as \lstinline!let lst = [1; 3; 5]!. Computational expressions is a small program, whose result is list, for example, \lstinline!let lst = [for i = 1 to 5 do yield i done]!



However, an elegant alternative is available as
\fs{flowForLists}{}
This to be preferred, since we completely can ignore list boundary conditions and hence avoid out of range indexing. For comparison see a recursive implementation of the same,
\fs{flowForListsRecursive}{}
Note how this implementation avoids the use of variables in contrast to the previous examples.




\section{Arrays}
\subsection{1 dimensional arrays}
Roughly speaking, arrays are mutable lists, and may be created and indexed in the same manner, e.g.,
\fs{arrayCreation}{}
Notice that as for lists, arrays are indexed starting with 0, and that in this particular case it was necessary to specify the type of the argument for \texttt{printArray} as an array of integers with the \texttt{array} keyword. The \texttt{array} keyword is synonymous with '\verb|[]|'. Arrays do not support pattern matching, cannot be resized, but are mutable,
\fs{arrayReassign}{}
Notice that in spite the missing \texttt{mutable} keyword, the function \texttt{square} still had the side-effect of squaring alle entries in \texttt{A}. Arrays support \idx{slicing}, that is, indexing an array with a range results in a copy of array with values corresponding to the range, e.g.,
\fs{arraySlicing}{}
As illustrated, the missing start or end index implies from the first or to the last element.

There are quite a number of built-in procedures for all arrays some of which we summarize in Table~\ref{tab:arrayMethods}.
\begin{table}
  \centering
  \begin{tabularx}{\textwidth}{|>{\hsize=.2\hsize}X|>{\hsize=1.8\hsize}X|}
    \hline
    append &Creates an array that contains the elements of one array followed by the elements of another array.\\
    average & Returns the average of the elements in an array.\\
    blit &Reads a range of elements from one array and writes them into another. \\
    choose &Applies a supplied function to each element of an array. Returns an array that contains the results x for each element for which the function returns Some(x).\\
    collect &Applies the supplied function to each element of an array, concatenates the results, and returns the combined array.\\
    concat &Creates an array that contains the elements of each of the supplied sequence of arrays.\\
    copy &Creates an array that contains the elements of the supplied array.\\
    create &Creates an array whose elements are all initially the supplied value.\\
    empty &Returns an empty array of the given type.\\
    exists &Tests whether any element of an array satisfies the supplied predicate.\\
    fill &Fills a range of elements of an array with the supplied value.\\
    filter &Returns a collection that contains only the elements of the supplied array for which the supplied condition returns true.\\
    find &Returns the first element for which the supplied function returns true. Raises System.Collections.Generic.KeyNotFoundException if no such element exists.\\
    findIndex &Returns the index of the first element in an array that satisfies the supplied condition. Raises System.Collections.Generic.KeyNotFoundException if none of the elements satisfy the condition.\\
    fold &Applies a function to each element of an array, threading an accumulator argument through the computation. If the input function is f and the array elements are i0...iN, this function computes f (...(f s i0)...) iN.\\
    foldBack &Applies a function to each element of an array, threading an accumulator argument through the computation. If the input function is f and the array elements are i0...iN, this function computes f i0 (...(f iN s)).\\
    forall &Tests whether all elements of an array satisfy the supplied condition.\\
    isEmpty &Tests whether an array has any elements.\\
    iter &Applies the supplied function to each element of an array.\\
    init &\dots\\
    length &Returns the length of an array. The System.Array.Length property does the same thing.\\
    map &Creates an array whose elements are the results of applying the supplied function to each of the elements of a supplied array.\\
    mapi &\\
    max &Returns the largest of all elements of an array. Operators.max is used to compare the elements.\\
    min &Returns the smallest of all elements of an array. Operators.min is used to compare the elements.\\
    ofList &Creates an array from the supplied list.\\
    ofSeq &Creates an array from the supplied enumerable object.\\
    partition &Splits an array into two arrays, one containing the elements for which the supplied condition returns true, and the other containing those for which it returns false.\\
    rev &Reverses the order of the elements in a supplied array. \\
    sort &Sorts the elements of an array and returns a new array. Operators.compare is used to compare the elements.\\
    sub &Creates an array that contains the sup<plied subrange, which is specified by starting index and length.\\
    sum &Returns the sum of the elements in the array.\\
    toList &Converts the supplied array to a list.\\
    toSeq &Views the supplied array as a sequence.\\
    unzip &Splits an array of tuple pairs into a tuple of two arrays.\\
    zeroCreate &Creates an array whose elements are all initially zero.\\
    zip &Combines two arrays into an array of tuples that have two elements. The two arrays must have equal lengths; otherwise, System.ArgumentException is raised.\\
    \hline
  \end{tabularx}
  \caption{Some built-in procedures in the Array module for arrays (from \protect\url{https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-core-library-reference})}
  \label{tab:arrayMethods}
\end{table}
Thus, the \texttt{arrayReassign.fsx} program can be written using arrays as,
\fs{arrayReassignModule}{}
and the \texttt{flowForListsIndex.fsx} program can be written using arrays as,
\fs{flowForListsIndexModule}{}
Both cases avoid the use of variables and side-effects which is a big advantage for code safety.

\subsection{Multidimensional Arrays}
Higher dimensional arrays can be created as arrays of arrays (of arrays \dots). These are known as \idx{jagged arrays}, since there is no inherent control of that all sub-arrays are of similar size. E.g., the following is a jagged array of increasing width,
\fs{arrayJagged}{}
Indexing arrays of arrays is done sequentially, in the sense that in the above example, the number of outer arrays is \verb|a.Length|,  \verb|a.[i]| is the i'th array, the length of the i'th array is \verb|a.[i].Length|, and the j'th element of the i'th array is thus \verb|a.[i].[j]|. Often 2 dimensional square arrays are used, which can be implemented as a jagged array as,
\fs{arrayJaggedSquare}{}
In fact, square arrays of dimensions 2 to 4 are so common that fsharp has built-in modules for their support. In the following describe Array2D. The workings of Array3D and Array4D are very similar. An example of creating the same 2 dimensional array as above but as an \texttt{Array2D} is,
\fs{array2D}{}
Notice that the indexing uses a slightly different notation '\verb|[,]|' and the length functions are also slightly different. The statement \verb|A.Length| would return the total number of elements in the array, in this case 12.

\jon{note that \texttt{A.[1,*]} is a Array but \texttt{A.[1..1,*]} is an Array2D.}

There are a bit few built-in procedures for 2 dimensional array types, some of which are summarized in Table~\ref{tab:array2dMethods}
\begin{table}
  \centering
  \begin{tabularx}{\textwidth}{|>{\hsize=.2\hsize}X|>{\hsize=1.8\hsize}X|}
    \hline
    blit &Reads a range of elements from one array and writes them into another. \\
    copy &Creates an array that contains the elements of the supplied array.\\
    create &Creates an array whose elements are all initially the supplied value.\\
    iter &Applies the supplied function to each element of an array.\\
    length1 &Returns the length of an array in the first dimension.\\
    length2 &Returns the length of an array in the second dimension.\\
    map &Creates an array whose elements are the results of applying the supplied function to each of the elements of a supplied array.\\
    mapi &\\
    zeroCreate &Creates an array whose elements are all initially zero.\\
    \hline
  \end{tabularx}
  \caption{Some built-in procedures in the Array2D module for arrays (from \protect\url{https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/fsharp-core-library-reference})}
  \label{tab:array2dMethods}
\end{table}
\section{Sequences}
\label{sec:sequences}
%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
