\chapter{Tuples, Lists, Arrays, and Sequences}
\label{chap:lists}\jon{possibly add maps and sets as well.}
F\# is tuned to work with lists, and there are several built-in lists with various properties making them useful for different tasks. E.g.,
%
\fs{tuplesQuadraticEq}{Using tuples to gather values.}
%
F\# has 4 built-in list types: tuples, lists, arrays, and sequences following this syntax:
%
\begin{lstlisting}[language=ebnf]
tupleList = expr | expr "," tupleList
comp-or-range-expr = comp-expr | short-comp-expr | range-expr
short-comp-expr = "for" pat "in" (expr | range-expr) "->" expr
range-exp = expr ".." expr [".." expr]
comp-expr =
  ("let" | "let!") pat "=" expr "in" comp-expr
  | ("do" | "do!") expr "in" comp-expr
  | ("use" | "use!") pat = expr "in" comp-expr
  | ("yield" | "yield!") expr
  | ("return" | "return!") expr
  | "if" expr "then" comp-expr ["else" comp-expr]
  | "match" expr "with" comp-rules
  | "try" comp-expr "with" comp-rules
  | "try" comp-expr "finally" expr
  | "while" expr "do" expr ["done"]
  | "for" ident "=" expr "to" expr "do" comp-expr ["done"]
  | "for" pat "in" expr-or-range-expr "do" comp-expr ["done"]
  | comp-expr ";" comp-expr
  | expr
comp-rule = pat pattern-guardopt "->" comp-expr
comp-rules = comp-rule | comp-rule '|' comp-rules
expr = ... 
  | tupleList
  | "[" comp-or-range-expr "]" (* computed list expression *)
  | "[|" comp-or-range-expr "|]" (* computed array expression *)
  | expr "{" comp-or-range-expr "}" (* computation expression *)
  | ...
\end{lstlisting}
%
\jon{Spec-4.0: grammar for list and array expressions are subsets of computed list and array expressions.}Tuples are a direct extension of constants. They are immutable and do not have concatenations nor indexing operations. This is in contrast to lists. Lists are also immutable, but have a simple syntax for concatenation and indexing. Arrays are mutable lists, and support higher order structures such as tables and 3 dimensional arrays. Sequences are like lists, but with the added advantage of a very flexible construction mechanism, and the option of representing infinite long sequences. In the following, we will present these data structures in detail.

\section{Tuples}
\idx[tuple]{Tuples} are unions of immutable types, 
%
\begin{lstlisting}[language=ebnf]
tupleList = expr | expr "," tupleList
expr = ... 
  | tupleList
  | ...
\end{lstlisting}
%
and the they are identified by the \lexeme{,} lexeme. Most often the tuple is enclosed in parentheses, but that is not required. Consider the tripel, also known as a 3-tuple, \lstinline!(2,true,"hello")! in interactive mode,
%
\fso{tuple}{Definition of a tuple.}
%
The values \lstinline!2!, \lstinline!true!, and \lstinline!"hello"! are \idx[member]{members}, and the number of elements of a tuple is its \idx{length}. From the response of F\# we see that the tuple is inferred to have the type \lstinline!int * bool * string!, where the \lexeme{*} is cartesian product between the three sets.  Notice, that tuples can be products of any types and have lexical scope like value and function bindings. Notice also, that a tuple may be printed as a single entity by the \lstinline!%A! placeholder. In the example, we bound \lstinline!tp! to the tuple, the opposite is also possible,
%
\fso{tupleDeconstruction}{Definition of a tuple.}
%
In this a function is defined that takes 1 argument, a 3-tuple, and which is bound to a tuple with 3 named members. Since we used the \lstinline!%A! placeholder in the \lstinline!printfn! function, then the function is generic and can be called with 3-tuples of different types. Note, \advice{don't confuse a function of $n$ arguments with a function of an $n$-tuple.}  The later has only 1 argument, and the difference is the \lexeme{,}'s. Another example is \lstinline!let solution a b c = ...!, which is the beginning of the function definition in Listing~\ref{tuplesQuadraticEq}. It is a function of 3 arguments, while \lstinline!let solution (a, b, c) = ...! would be a function of 1 argument, which is a 3-tuple. Functions of several arguments makes currying easy, i.e., we could define a new function which fixes the quadratic term to be 0 as \lstinline!let solutionToLinear = solution 0.0!, that is, without needing to specify anything else. With tuples, we would need the slightly more complicated, \lstinline!let solutionToLinear (b, c) = solution (0.0, b, c)!.

Tuples comparison are defined similarly as strings. Tuples of different lengths are different. For tuples of equal length, then they are compared element by element. E.g., \lstinline!(1,2) = (1,3)! is false, while \lstinline!(1,2) = (1,2)! is true. The \lexeme{<>} operator is the boolean negation of the \lexeme{=} operator. For the \lexeme{<} , \lexeme{<=}, \lexeme{>}, and \lexeme{>=} operators, the strings are ordered alphabetically like, such that \lstinline!('a', 'b', 'c') < ('a', 'b', 's') && ('a', 'b', 's') <  ('c', 'o', 's')! is true, that is, the \lexeme{<} operator on two tuples is true, if the left operand should come before the right, when sorting alphabetically like. 
%
\fs{tupleCompare}{Tuples are compared as strings are compared alphabetically.}
%
The algorithm for deciding the boolean value of \lstinline!(a1, a2) < (b1, b2)! is as follows: we start by examining the first elements, and if \lstinline!la1! and \lstinline!b1! are different, then the \lstinline!(a1, a2) < (b1, b2)! is equal to \lstinline!a1 < b1!. If \lstinline!la1! and \lstinline!b1! are equal, then we move onto the next letter and repeat the investigation. The \lexeme{<=}, \lexeme{>}, and \lexeme{>=} operators are defined similarly.

Binding tuples to mutuals does not make the tuple mutable, e.g.,
%
\fs{tupleOfMutables}{A mutable change value, but the tuple defined by it does not refer to the new value.}
%
However, tuples may be mutual such that new tuple values can be assigned to it, e.g., in the Fibonacci example, we can write a more compact script by using mutable tuples and the \keyword{fst} and \keyword{snd} functions as follows.
%
\fs{fibTuple}{Calculating Fibonacci numbers using mutable tuple.}
%
In this example, the central computation has been packed into a single line, \lstinline!prev <- (snd prev, (fst prev) + (snd prev))!, where both the calculation of $\text{fib}(n) = \text{fib}(n-2) + \text{fib}(n-1)$ and the rearrangement of memory to hold the new values $\text{fib}(n)$ and $\text{fib}(n-1)$ based on the old values $\text{fib}(n-2) + \text{fib}(n-1)$. While this may look elegant and short there is the risk of \idx{obfuscation}, i.e., writing compact code that is difficult to read, and in this case, an unprepared reader of the code may not easily understand the computation nor appreciate its elegance without an accompanying explanation.  Hence, \advice{always keep an eye out for compact and concise ways to write code, but never at the expense of readability.}

\section{Lists}
\idx[list]{Lists} are unions of immutable values of the same type and have a more flexible structure than tuples. Its grammar follows \idx{computational expressions}, which is very rich and shared with arrays and sequences, and we will delay a discussion on most computational expressions to Section~\ref{sec:sequences}, and here just consider a subset of the grammar:
\begin{lstlisting}[language=ebnf]
comp-or-range-expr = comp-expr | .. | range-expr
range-exp = expr ".." expr [".." expr]
comp-expr =
  ...
  | comp-expr ";" comp-expr
  | expr
expr = ... 
  | "[" comp-or-range-expr "]" (* computed list expression *)
  | ...
\end{lstlisting}
Simple examples of a list grammars are, \lstinline[language=ebnf]![expr; expr; ... ; expr]!, \lstinline[language=ebnf]![expr ".." expr]!, \lstinline[language=ebnf]![expr ".." expr ".." expr]!, e.g., an explicit list \lstinline!let lst = [1; 2; 3; 4; 5]!, which may be written shortly as \idx{range expression} as \lstinline!let lst = [1 .. 5]!, and ranges may include a step size \lstinline!let lst = [1 .. 2 .. 5]!, which is the same as \lstinline!let lst = [1; 3; 5]!.

Lists may be indexed and concatenated much like strings, e.g.,
%
\fs{listIndexing}{Examples of list concatenation, indexing.}
%
A list type is identified with the \keyword{list} keyword, as here a list of integers is \lstinline!int list!. Above, we used the \idx{\lexeme{@}} and \idx{\lexeme{::}} concatenation operators, the \idx{\lexeme{.[]}} index method, and the \idx{\lexeme{Length}} property. Notice, as strings, list elements are counted from 0, and thus the last element has \lstinline!lst.Length - 1!. In \lstinline!printList! the \keyword{for}-\keyword{in} is used, which runs loops through each element of the list and assigns it to the identifier \lstinline!elm!. This is in contrast to \lstinline!printListAlt!, which uses uses the \keyword{for}-\keyword{to} keyword and explicitly represents the index \lstinline!i!. Explicit representation of the index makes more complicated programs, and thus increases the chances of programming errors. Hence, \advice{\keyword{for}-\keyword{in} is to be preferred over \keyword{for}-\keyword{to}.} Lists support slicing identically to strings, e.g.,
%
\fs{listSlicing}{Examples of list slicing. Compare with Listing~\ref{stringIndexing}.}
%

Lists are well suited for recursive functions and pattern matching with, e.g., \keyword{match}-\keyword{with} as illustrated in the next example:
%
\fs{listPatternMatching}{Examples of list concatenation, indexing.}
%
The pattern \lstinline!l::rest! is the pattern for the first element followed by a list of the rest of the list. This pattern matches all lists except an empty list, hence \lstinline!rest! may be empty. Thus the wildcard pattern matching anything including the empty list, will be used only when \lstinline!lst! is empty.

\idx[pattern matching]{Pattern matching} with lists is quite powerful, consider the following problem:
\begin{problem}
  Given a list of pairs of course names and course grades, calculate the average grade.
\end{problem}
A list of course names and grades is \lstinline![("name1", grade1); ("name2", grade2); ...]!. Let's take a recursive solution. First problem will be to iterate through the list. For this we can use pattern matching similarly to Listing~\ref{listPatternMatching} with \lstinline!(name, grade)::rest!. The second problem will be to calculate the average. The average grade is the sum all grades and divide by the number of grades. Assume that we already have made a function, which calculates the \lstinline!sum! and \lstinline!n!, the sum and number of elements, for \lstinline!rest!, then all we need is to add \lstinline!grade! to the \lstinline!sum! and \lstinline!1! to \lstinline!n!. For an empty list, \lstinline!sum! and \lstinline!n! should be \lstinline!0!. Thus we arrive at the following solution,
% However, an elegant alternative is available as
% \fs{flowForLists}{}
% This to be preferred, since we completely can ignore list boundary conditions and hence avoid out of range indexing. For comparison see a recursive implementation of the same,
%
\fs{avgGradesRec}{Calculating a list of average grades using recursion and pattern matching.}
%
%Note how this implementation avoids the use of variables in contrast to the previous examples.

Pattern matching and appending is a useful combination, if we wish to produce new from old lists. E.g., a function returning a list of squared entries of its argument can be programmed as,
%
\fs{listSquare}{Using pattern matching and list appending elements to lists.}
%
This is a prototypical functional programming style solution, and which uses the \lexeme{::} for 2 different purposes: First the list \lstinline![1 .. 10]! is first matched with \lstinline!1 :: [2 .. 10]!, and then we assume that we have solved the problem for \lstinline!square rest!, such that all we need to do is append \lstinline!1*1! to the beginning output from \lstinline!square rest!. Hence we get, \lstinline!square [1 .. 10]! $\curvearrowright$ \lstinline!1 * 1 :: square [2 .. 10]! $\curvearrowright$ \lstinline!1 * 1 :: (2 * 2 :: square [3 .. 10])! $\curvearrowright$ \dots \lstinline!1 * 1 :: (2 * 2 :: ... 10 * 10 :: [])!, where the stopping criterium is reached, when the \lstinline!elm :: rest! does not match with a, hence it is empty, which does match the wildcard pattern \lexeme{_}. More on functional programming in Section~\ref{chap:functional}

The basic properties and members of lists are summarized in Table~\ref{tab:list}.\idxss{Length}\idxss{List.Empty}\idxss{IsEmpty}\idxss{Item}\idxss{Head}\idxss{Tail}\idxss{Cons}
\begin{table}
  \centering
  \begin{tabularx}{\linewidth}{|>{\hsize=.5\hsize}X|>{\hsize=1.5\hsize}X|>{\hsize=1\hsize}X|}
    \hline
    Function name & Example & Description\\
    \hline
    \lstinline!Length! & \fsi{listLength}{1.5} & The number of elements in a list\\
    \hline
    \lstinline!List.Empty! & \fsi{listEmpty}{1.5} & An empty list of specified type\\
    \hline
    \lstinline!IsEmpty! & \fsi{listIsEmpty}{1.5} & Compare with the empty list\\
    \hline
    \lstinline!Item! & \fsi{listItem}{1.5} & Indexing\\
    \hline
    \lstinline!Head! & \fsi{listHead}{1.5} & The first element in the list. Exception if empty.\\
    \hline
    \lstinline!Tail! & \fsi{listTail}{1.5} & The list except its first element. Exception if empty.\\
    \hline
    \lstinline!Cons! & \fsi{listCons}{1.5} & Append an element to the front of the list\\
    \hline
    \lstinline!@! & \fsi{listConcatenate}{1.5} & Concatenate two lists\\
    \hline
  \end{tabularx}
  \caption{Basic properties and members of lists.}
  \label{tab:list}
\end{table}
In addition, Lists have many other built-in functions, which will be discussed in Chapter~\ref{chap:collection} and Part~\ref{part:declarative}.

It is possible to make multidimensional lists as lists of lists, e.g., 
%
\fs{listMultidimensional}{A ragged multidimensional list, built as lists of lists, and its indexing.}
%
The example shows a \idx{ragged multidimensional list}, since each row has different number of elements. The indexing of a particular element is not elegant, which is why arrays are often preferred in F\#.

\section{Arrays}
\label{sec:arrays}
\subsection{1 dimensional arrays}
1 dimensional arrays or just arrays for short are mutable lists of the same type and follow a similar syntax as lists. Its grammar follows \idx{computational expressions}, which will be discussed in Section~\ref{sec:sequences}. Here we consider a subset of the grammar:
%
\begin{lstlisting}[language=ebnf]
comp-or-range-expr = comp-expr | ... | range-expr
comp-expr =
  | comp-expr ";" comp-expr
  | expr
expr = ... 
  | "[|" comp-or-range-expr "|]" (* computed array expression *)
  | ...
\end{lstlisting}
%
Thus the creation of arrays is identical to lists, but there is no explicit operator support for appending and concatenation, e.g.,
%
\fs{arrayCreation}{Creating arrays with a syntax similarly to lists.}
%
The array type is defined using the \keyword{array} keyword or alternatively the \keyword{[]} lexeme. Arrays cannot be resized, but are mutable,
%
\fs{arrayReassign}{Arrays are mutable in spite the missing \keyword{mutable} keyword.}
%
Notice that in spite the missing \keyword{mutable} keyword, the function \lstinline{square} still had the \idx{side-effect} of squaring alle entries in \lstinline{A}.  Arrays only support direct pattern matching, e.g.,
%
\fs{arrayPatternMatching}{Only simple pattern matching is allowed for arrays.}
%
The given example is the first example of a 2-dimensional array, which can be implemented as arrays of arrays and here written as \lstinline!string array array!. In Section~\ref{sec:array2d} will 2 and higher dimensional arrays be discussed.  Arrays support \idx{slicing}, that is, indexing an array with a range results in a copy of array with values corresponding to the range, e.g.,
%
\fs{arraySlicing}{Examples of array slicing. Compare with Listing~\ref{listSlicing} and Listing~\ref{stringIndexing}.}
%
As illustrated, the missing start or end index implies from the first or to the last element.

There are quite a number of built-in procedures for all arrays many which will be discussed in Chapter~\ref{chap:collections}.

\subsection{Multidimensional Arrays}
Higher dimensional arrays can be created as arrays of arrays (of arrays \dots). These are known as \idx{jagged arrays}, since there is no inherent control of that all sub-arrays are of similar size. E.g., the following is a jagged array of increasing width,
%
\fs{arrayJagged}{An array of arrays. When row lengths are of non-equal elements, then it is a Jagged array.}
%
Indexing arrays of arrays is done sequentially, in the sense that in the above example, the number of outer arrays is \lstinline|a.Length|,  \lstinline|a.[i]| is the i'th array, the length of the i'th array is \lstinline|a.[i].Length|, and the j'th element of the i'th array is thus \lstinline|a.[i].[j]|. Often 2 dimensional rectangular arrays are used, which can be implemented as a jagged array as,
%
\fs{arrayJaggedSquare}{A rectangular array. Notice, the \keyword{for}-\keyword{in} cannot be used in \lstinline!pownArray!}, e.g., \lstinline!for row in arr do for elm in row do elm <- pown elm p done done} since the iterator value \lstinline!elm! is not mutable even though \lstinline!arr! is an array.
%
In fact, square arrays of dimensions 2 to 4 are so common that F\# has built-in modules for their support. In the following describe Array2D. The workings of Array3D and Array4D are very similar. An example of creating the same 2 dimensional array as above but as an \texttt{Array2D} is,
%
\fs{array2D}{Creating a 3 by 4 rectangular arrays of intigers.}
%
Notice that the indexing uses a slightly different notation '\verb|[,]|' and the length functions are also slightly different. The statement \verb|A.Length| would return the total number of elements in the array, in this case 12. As can be seen, the \lstinline!printf! supports direct printing of the 2 dimensional array. Higher dimensional arrays support slicing, e.g.,
%
\fs{array2DSlicing}{Examples of Array2D slicing. Compare with Listing~\ref{array2D}.}
%
Note that in almost all cases, slicing produces a sub rectangular 2 dimensional array except for \lstinline{arr.[1,*]}, which is an array, as can be seen by the single \lexeme{[}. In contrast, \lstinline{A.[1..1,*]} is an Array2D. Note also, that \lstinline!printfn! typesets 2 dimensional arrays as \lstinline{[[ ... ]]} and not \lstinline{[|[| ... |]|]}, which can cause confusion with lists of lists.
\jon{Array2D.ToString produces \lstinline{[[ ... ]]} and not \lstinline{[|[| ... |]|]}, which can cause confusion.}

Array2D and higher have a number of built-in functions that will be discussed in Chapter~\ref{chap:collections}.

\section{Sequences}
\label{sec:sequences}

A computational expression is a small program, whose result is list, for example, \lstinline!let lst = [for i = 1 to 5 do yield i done]!

\fs{arrayJaggedCompExpr}{}
Indexing arrays of arrays is done sequentially, in the sense that in the above example, the number of outer arrays is \verb|a.Length|,  \verb|a.[i]| is the i'th array, the length of the i'th array is \verb|a.[i].Length|, and the j'th element of the i'th array is thus \verb|a.[i].[j]|. Often 2 dimensional square arrays are used, which can be implemented as a jagged array as,
\fs{arrayJaggedSquareCompExpr}{}
In fact, square arrays of dimensions 2 to 4 are so common that F\# has built-in modules for their support. In the following describe Array2D. The workings of Array3D and Array4D are very similar. An example of creating the same 2 dimensional array as above but as an \texttt{Array2D} is,
\fs{array2DCompExpr}{}
Notice that the indexing uses a slightly different notation '\verb|[,]|' and the length functions are also slightly different. The statement \verb|A.Length| would return the total number of elements in the array, in this case 12.

%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
