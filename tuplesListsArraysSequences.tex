\chapter{Ordered series of data}
\label{chap:lists}
F\# is tuned to work with ordered series, and there are several built-in lists with various properties making them useful for different tasks. E.g.,
%
\fs{tuplesQuadraticEq}{Using tuples to gather values.}
%
F\# has four built-in list types: strings, tuples, lists, arrays, and sequences. Strings were discussed in Chapter~\ref{chap:calculator}, sequences will be discussed in Chapter~\ref{chap:sequences}. Here we will concentrate on tuples, lists,  and arrays, and following this (simplified) syntax:
%
\begin{verbatimwrite}{tmp.ebnf}
expr = ... 
  | exprTuple (*tuple*)
  | "[" (exprSeq | rangeExpr) "]" (*list*)
  | "[|" (exprSeq | rangeExpr) "|]" (*array*)

exprTuple = expr | expr "," exprTuple;
exprSeq =  expr | expr ";" exprSeq;
rangeExpr = expr ".." expr [".." expr];
\end{verbatimwrite}
\ebnf{tmp.ebnf}{}
%
\spec{Spec-4.0: grammar for list and array expressions are subsets of computation list and array expressions.} Tuples are a direct extension of constants. They are immutable and do not have concatenations nor indexing operations. This is in contrast to lists. Lists are also immutable, but have a simple syntax for concatenation and indexing. Arrays are mutable lists, and support higher order structures such as tables and three dimensional arrays. 
%Sequences are like lists, but with the added advantage of a very flexible construction mechanism, and the option of representing infinitely long sequences. In the following, we will present these data structures in detail.

\section{Tuples}
\idx[tuple]{Tuples} are unions of immutable types, 
%
\begin{verbatimwrite}{tmp.ebnf}
expr = ... 
  | exprTuple (*tuple*)

exprTuple = expr | expr "," exprTuple;
\end{verbatimwrite}
\ebnf{tmp.ebnf}{}
%
and the they are identified by the \lexeme{,} lexeme. Most often the tuple is enclosed in parentheses, but that is not required. Consider the tripel, also known as a 3-tuple, \lstinline!(2,true,"hello")! in interactive mode,
%
\fsOutput{tuple}{Definition of a tuple.}
%
The values \lstinline!2!, \lstinline!true!, and \lstinline!"hello"! are \idx[member]{members}, and the number of elements of a tuple is its \idx{length}. From the response of F\# we see that the tuple is inferred to have the type \lstinline!int * bool * string!, where the \lexeme{*} is cartesian product between the three sets.  Notice, that tuples can be products of any types and have lexical scope like value and function bindings. Notice also, that a tuple may be printed as a single entity by the \lstinline!%A! placeholder. In the example, we bound \lstinline!tp! to the tuple, the opposite is also possible,
%
\fsOutput{tupleDeconstruction}{Definition of a tuple.}
%
In this a function is defined that takes 1 argument, a 3-tuple, and which is bound to a tuple with 3 named members. Since we used the \lstinline!%A! placeholder in the \lstinline!printfn! function, then the function is generic and can be called with 3-tuples of different types. Note, \advice{don't confuse a function of $n$ arguments with a function of an $n$-tuple.}  The later has only 1 argument, and the difference is the \lexeme{,}s. Another example is \lstinline!let solution a b c = ...!, which is the beginning of the function definition in Listing~\ref{tuplesQuadraticEq}. It is a function of 3 arguments, while \lstinline!let solution (a, b, c) = ...! would be a function of 1 argument, which is a 3-tuple. Functions of several arguments makes currying easy, i.e., we could define a new function which fixes the quadratic term to be 0 as \lstinline!let solutionToLinear = solution 0.0!, that is, without needing to specify anything else. With tuples, we would need the slightly more complicated, \lstinline!let solutionToLinear (b, c) = solution (0.0, b, c)!.

Tuples comparison are defined similarly as strings. Tuples of different lengths are different. For tuples of equal length, then they are compared element by element. E.g., \lstinline!(1,2) = (1,3)! is false, while \lstinline!(1,2) = (1,2)! is true. The \lexeme{<>} operator is the boolean negation of the \lexeme{=} operator. For the \lexeme{<} , \lexeme{<=}, \lexeme{>}, and \lexeme{>=} operators, the strings are ordered lexicographically, such that \lstinline!('a', 'b', 'c') < ('a', 'b', 's') && ('a', 'b', 's') <  ('c', 'o', 's')! is true, that is, the \lexeme{<} operator on two tuples is true, if the left operand should come before the right, when sorting alphabetically like. 
%
\fs{tupleCompare}{Tuples are compared as strings are compared alphabetically.}
%
The algorithm for deciding the boolean value of \lstinline!(a1, a2) < (b1, b2)! is as follows: we start by examining the first elements, and if \lstinline!la1! and \lstinline!b1! are different, then the \lstinline!(a1, a2) < (b1, b2)! is equal to \lstinline!a1 < b1!. If \lstinline!la1! and \lstinline!b1! are equal, then we move onto the next letter and repeat the investigation. The \lexeme{<=}, \lexeme{>}, and \lexeme{>=} operators are defined similarly.

Binding tuples to mutables does not make the tuple mutable, e.g.,
%
\fs{tupleOfMutables}{A mutable change value, but the tuple defined by it does not refer to the new value.}
%
However, it is possible to define a mutable variable of type tuple such that new tuple values can be assigned to it, e.g., in the Fibonacci example, we can write a more compact script by using mutable tuples and the \keyword{fst} and \keyword{snd} functions as follows.
%
\fs{fibTuple}{Calculating Fibonacci numbers using a mutable tuple.}
%
In this example, the central computation has been packed into a single line, \lstinline!prev <- (snd prev, (fst prev) + (snd prev))!, where both the calculation of $\text{fib}(n) = \text{fib}(n-2) + \text{fib}(n-1)$ and the rearrangement of memory to hold the new values $\text{fib}(n)$ and $\text{fib}(n-1)$ based on the old values $\text{fib}(n-2) + \text{fib}(n-1)$. While this may look elegant and short there is the risk of \idx{obfuscation}, i.e., writing compact code that is difficult to read, and in this case, an unprepared reader of the code may not easily understand the computation nor appreciate its elegance without an accompanying explanation.  Hence, \advice{always keep an eye out for compact and concise ways to write code, but never at the expense of readability.}

\section{Lists}
\idx[list]{Lists} are unions of immutable values of the same type and have a more flexible structure than tuples. Its grammar follows \idx{computation expressions}, which is very rich and shared with arrays and sequences, and we will delay a discussion on most computation expressions to Section~\ref{sec:sequences}, and here just consider a subset of the grammar:
\begin{verbatimwrite}{tmp.ebnf}
expr = ... 
  | "[" (exprSeq | rangeExpr) "]" (*list*)

exprSeq =  expr | expr ";" exprSeq;
rangeExpr = expr ".." expr [".." expr];
\end{verbatimwrite}
\ebnf{tmp.ebnf}{}
E.g., an explicit list \mbox{\lstinline!let lst = [1; 2; 3; 4; 5]!}, which may be written shortly as \idx{range expression} as \mbox{\lstinline!let lst = [1 .. 5]!}, and ranges may include a step size \mbox{\lstinline!let lst = [1 .. 2 .. 5]!}, which is the same as \mbox{\lstinline!let lst = [1; 3; 5]!}.

Lists may be indexed and concatenated much like strings, e.g.,
%
\fs{listIndexing}{Examples of list concatenation, indexing.}
%
A list type is identified with the \keyword{list} keyword, as here a list of integers is \lstinline!int list!. Above, we used the \idx{\lexeme{@}} and \idx{\lexeme{::}} concatenation operators, the \idx{\lexeme{.[]}} index method, and the \idx{\lexeme{Length}} property. There also exists a family of functions including \lstinline!List.length!, \lstinline!List.isEmpty!, \lstinline!List.item!, \lstinline!List.head!, \lstinline!List.tail! for working with list. Notice, as strings, list elements are counted from 0, and thus the last element has \lstinline!lst.Length - 1!. In \lstinline!printList! the \keyword{for}-\keyword{in} is used, which runs loops through each element of the list and assigns it to the identifier \lstinline!elm!. This is in contrast to \lstinline!printListAlt!, which uses uses the \keyword{for}-\keyword{to} keyword and explicitly represents the index \lstinline!i!. Explicit representation of the index makes more complicated programs, and thus increases the chances of programming errors. Hence, \advice{\keyword{for}-\keyword{in} is to be preferred over \keyword{for}-\keyword{to}.} Lists support slicing identically to strings, e.g.,
%
\fs{listSlicing}{Examples of list slicing. Compare with Listing~\ref{stringIndexing}.}
%

The basic properties and members of lists are summarized in Table~\ref{tab:list}-~\ref{tab:listCont}.\idxss{Length}\idxss{List.Empty}\idxss{IsEmpty}\idxss{Item}\idxss{Head}\idxss{Tail}\idxss{Cons}
\begin{table}
  \centering
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabularx}{\linewidth}{|>{\hsize=.5\hsize}X|>{\hsize=1.75\hsize}X|>{\hsize=.75\hsize}X|}
    \hline
    \rowcolor{headerRowColor} Function name & Example & Description\\
    \hline
    \lstinline!Length! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listLength}{} & The number of elements in a list\\
    \hline
    \lstinline!List.Length! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listLengthAlt}{} & The number of elements in a list\\
    \hline
    \lstinline!List.Empty! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listEmpty}{} & An empty list of specified type\\
    \hline
    \lstinline!IsEmpty! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listIsEmpty}{} & Compare with the empty list\\
    \hline
    \lstinline!List.isEmpty! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listIsEmptyAlt}{} & Compare with the empty list\\
    \hline
    \lstinline!Item! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listItem}{} & Indexing\\
    \hline
    \lstinline!List.item! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listItemAlt}{} & Indexing\\
    \hline
  \end{tabularx}
  \caption{Basic properties and members of lists. The syntax used in \lstinline{List<int>.Empty} ensures that the empty list is of type \lstinline{int}.}
  \label{tab:list}
\end{table}
\begin{table}
  \centering
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabularx}{\linewidth}{|>{\hsize=.5\hsize}X|>{\hsize=1.75\hsize}X|>{\hsize=.75\hsize}X|}
    \hline
    \rowcolor{headerRowColor} Function name & Example & Description\\
    \hline
    \lstinline!Head! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listHead}{} & The first element in the list. Exception if empty.\\
    \hline
    \lstinline!List.head! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listHeadAlt}{} & The first element in the list. Exception if empty.\\
    \hline
    \lstinline!List.tail! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listTailAlt}{} & The list except its first element. Exception if empty.\\
    \hline
    \lstinline!Cons! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listCons}{} & Append an element to the front of the list\\
    \hline
    \lstinline!@! & \fsOutput[aboveskip=0pt,belowskip=0pt,emptylines=0]{listConcatenate}{} & Concatenate two lists\\
    \hline
  \end{tabularx}
  \caption{Basic properties and members of lists continued from Table~\ref{tab:list}.}
  \label{tab:listCont}
\end{table}
In addition, lists have many other built-in functions, such as functions for converting lists to arrays,\idxss{List.toList}\idxss{List.toArray}
%
\fs{listConversion}{The \lstinline!List! module contains functions for conversion to arrays.}
%
These and more will be discussed in Chapter~\ref{chap:collection} and Part~\ref{part:declarative}.\jon{Add description of prepend and concatenation operator for lists.}

It is possible to make multidimensional lists as lists of lists, e.g., 
%
\fs{listMultidimensional}{A ragged multidimensional list, built as lists of lists, and its indexing.}
%
The example shows a \idx{ragged multidimensional list}, since each row has different number of elements. The indexing of a particular element is not elegant, which is why arrays are often preferred in F\#.

\section{Arrays}
\label{sec:arrays}
%\subsection{1 dimensional arrays}
One dimensional arrays or just arrays for short are mutable lists of the same type and follow a similar syntax as lists. Its grammar follows \idx{computation expressions}, which will be discussed in Section~\ref{sec:sequences}. Here we consider a subset of the grammar:
%
\begin{verbatimwrite}{tmp.ebnf}
expr = ... 
  | "[|" (exprSeq | rangeExpr) "|]" (*array*)

exprSeq =  expr | expr ";" exprSeq;
rangeExpr = expr ".." expr [".." expr];
\end{verbatimwrite}
\ebnf{tmp.ebnf}{}
%
Thus the creation of arrays is identical to lists, but there is no explicit operator support for appending and concatenation, e.g.,
%
\fs{arrayCreation}{Creating arrays with a syntax similarly to lists.}
%
The array type is defined using the \keyword{array} keyword or alternatively the \keyword{[]} lexeme. Arrays cannot be resized, but are mutable,
%
\fs{arrayReassign}{Arrays are mutable in spite the missing \keyword{mutable} keyword.}
%
Notice that in spite the missing \keyword{mutable} keyword, the function \lstinline{square} still had the \idx{side-effect} of squaring alle entries in \lstinline{A}.  

Arrays support \idx{slicing}, that is, indexing an array with a range results in a copy of array with values corresponding to the range, e.g.,
%
\fs{arraySlicing}{Examples of array slicing. Compare with Listing~\ref{listSlicing} and Listing~\ref{stringIndexing}.}
%
As illustrated, the missing start or end index implies from the first or to the last element.

Arrays can be converted to lists by,\idxss{Array.toList}
%
\fs{arrayConversion}{The \lstinline!Array! module contains functions for conversion to lists.}
%
There are quite a number of built-in procedures for all arrays many which will be discussed in Chapter~\ref{chap:collection}.

%\subsection{Multidimensional Arrays}
Higher dimensional arrays can be created as arrays of arrays (of arrays \dots). These are known as \idx{jagged arrays}, since there is no inherent control of that all sub-arrays are of similar size. E.g., the following is a jagged array of increasing width,
%
\fs{arrayJagged}{An array of arrays. When row lengths are of non-equal elements, then it is a Jagged array.}
%
Indexing arrays of arrays is done sequentially, in the sense that in the above example, the number of outer arrays is \lstinline|a.Length|,  \lstinline|a.[i]| is the i'th array, the length of the i'th array is \lstinline|a.[i].Length|, and the j'th element of the i'th array is thus \lstinline|a.[i].[j]|. Often 2 dimensional rectangular arrays are used, which can be implemented as a jagged array as,
%
\fs{arrayJaggedSquare}{A rectangular array.} 
%
Notice, the \keyword{for}-\keyword{in} cannot be used in \lstinline!pownArray!, e.g., \lstinline{for row in arr do for elm in row do elm <- pown elm p done done} since the iterator value \lstinline!elm! is not mutable even though \lstinline!arr! is an array.
%
In fact, square arrays of dimensions 2 to 4 are so common that F\# has built-in modules for their support. In the following, we describe Array2D. The workings of Array3D and Array4D are very similar. An example of creating the same 2 dimensional array as above but as an \lstinline{Array2D} is,
%
\fs{array2D}{Creating a 3 by 4 rectangular arrays of intigers.}
%
Notice that the indexing uses a slightly different notation \lstinline|[,]| and the length functions are also slightly different. The statement \lstinline|A.Length| would return the total number of elements in the array, in this case 12. As can be seen, the \lstinline!printf! supports direct printing of the 2 dimensional array. Higher dimensional arrays support slicing, e.g.,
%
\fs{array2DSlicing}{Examples of Array2D slicing. Compare with Listing~\ref{array2D}.}
%
Note that in almost all cases, slicing produces a sub rectangular 2 dimensional array except for \lstinline{arr.[1,*]}, which is an array, as can be seen by the single \lexeme{[}. In contrast, \lstinline{A.[1..1,*]} is an Array2D. Note also, that \lstinline!printfn! typesets 2 dimensional arrays as \lstinline{[[ ... ]]} and not \lstinline{[|[| ... |]|]}, which can cause confusion with lists of lists.
\jon{Array2D.ToString produces \lstinline{[[ ... ]]} and not \lstinline{[|[| ... |]|]}, which can cause confusion.}

Array2D and higher have a number of built-in functions that will be discussed in Chapter~\ref{chap:collection}.


%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
