\chapter{Introduction}
Programming is a creative process in which exciting problems may be solved and new tools and applications may be created. With programming skills you may create high-level applications to run on a mobile device that interacts with other users, databases, and artificial intelligences; you may create programs that run on super computers for simulating weather systems on alien planets or social phenomenons in the internet economy; and you may create programs that run on small custom-made hardware for controlling your home appliances. A program is a physical realisation of ideas and thoughts, and the computer allows you to play, to interact, and to test your ideas in very short time.

\section{How to learn to program}
To learn how to program there are a couple of steps, that are useful to follow:
\begin{enumerate}
\item Choose a programming language: It is possible to program without a concrete language, but your ideas and thoughts must be expressed in some fairly rigorous way. Actually, theoretical computer science typically does not rely on computers nor programming languages, but uses mathematics to prove properties of algorithms. However, most computer scientists program, and with a real language, you have the added benefit of checking your algorithm and hence your thoughts rigorously on a real computer. This book teaches a subset of F\#. The purpose is not to be a reference guide to this language, but to use it as a vessel to teach you, the reader, how to convert your ideas into programs.
\item Learn the language: A computer language is a structure for thought, and it influences which thoughts you choose to implement as a program, and how you choose to do it. Any conversion requires you to acquirer a sufficient level of fluency, for you to be able to make programs. You do not need to be a master in F\# nor to know every corner of the language, and you will expand your knowledge as you expose yourself to solving problems in the language, but you invest an initial amount of time and energy in order to learn the basics of the language. This book aims at getting you started quickly, which is why we intentionally are teaching a small subset of F\#. On the net and through other works, you will be able to learn much more, but keep in mind, that while languages are beautiful, it's what you express in the languages that allow you to shine.
\item Practice: If you want to be a good programmer, then there is only one way: practice, practice, practice! It has been estimated that to master anything, then you have to have spent at least 10000 hours of practice, so get startet logging hours! It of course matters, what you practice. This book teaches 3 different programming themes. The point is that programming is thinking, and the scaffold that you use, shapes your thoughts. It is therefore important to recognize this scaffold, and to have the ability to choose that which suits your ideas and your goals best. And the best way to expand your abilities is to both sharpen your present abilities and pushing yourself into new territory and trying something new. Don't be afraid to make errors or be frustrated at first. These are the experiences that make you grow.
\item Solve real problems: I have found that using my programming skills in real situations with customers demanding solutions, that work for them, has allowed me to put into perspective the programming tools and techniques that I use. Often customers wants solutions that work, are secure, are cheap, and delivered fast, which has pulled me as a programmer in the direction of ``if it works, then sell it'', while on the longer perspective customers also wants bug fixes, upgrades, and new features, which requires carefully designed code, well written test-suites, and good documentation. And as always, the right solution is somewhere in between. Regardless, real problems creates real programmers.
\end{enumerate}

\section{How to solve problems}
Programming is the act of solving a problem by writing a program to be executed on a computer. A general method for solving problems was given by George Pólya~\cite{polya45} and adapted to programming is:
\begin{description}
\item[Understand the problem:] To solve any problem it is crucial that the problem formulation is understood, and questions like: What is to be solved? Do you understand everything in the problem description. Is all information for finding the solution available or is something missing?
\item[Design a plan:] Good designs means that programs are faster to program easier to debug and maintain. So before you start typing a program consider things like: What are the requirements and constraints for the program? Which components should the program have? How are these components to work together? Designing often involves drawing a diagram of the program, and writing pseudo-code on paper.
\item[Implement the plan:] Implementation is the act of transforming a program design into a code. A crucial part of any implementation is choosing which programming language to use. Also, the solution to many problems will have a number of implementations which vary in how much code they require, to which degree they rely on external libraries, which programming style the are best suited for, what machine resources they require, and what their running times are.  With a good design, then the coding is usually easy, since the design will have uncovered the major issues and found solutions for these, but sometimes implementation reveals new problems, which requires rethinking the design. Most implementations also include writing documentation of the code.
\item[Reflect on the result:] A crucial part in any programming task is ensuring that the program solves the problem sufficiently. E.g., what are the program's bugs, is the documentation of the code sufficient and relevant for its intended use. Is the code easily maintainable and extendable by other programmers. Are there any general lessons to be learned from or general code developed by the programming experience, which may be used for future programming sessions?
\end{description}
Programming is a very complicated process, and the steps in Pólya's list are almost always to be performed, but the order of the steps and the number of times each step is performed varies. \jon{Should we mention core activities: Requirements, Design, Construction, Testing, Debugging, Deployment, Maintenance?}

\section{Approaches to programming}
This book focusses on 3 fundamentally different approaches to programming: 
\begin{description}
\item[Imperative programming,]\idxs{Imperative programming} which is a type of programming that \idx{statements} to change the program's \idx{state}. Imperative programming emphasises \emph{how a program shall accomplish a solution} and less on\emph{what the solution is}. A cooking recipes is an example of the spirit of imperative programming. Almost all computer hardware is designed to execute low-level programs written in imperative style. The first major language was FORTRAN~\cite{backus54} which emphasized imperative style of programming.
\item[Declarative programming,]\idxs{Declarative programming} which emphasises \emph{what a program shall accomplish} but not \emph{how}. We will consider Functional programming as a type of declarative programming. \idxs{Functional programming} A type of programming which evaluates \idx{functions} and avoids state changes. The program consists of \idx{expressions} instead of statements. As a consequence, the output of functions only depends on its arguments. Functional programming has its roots in lambda calculus~\cite{church32}, and the first language emphasizing functional programming was Lisp~\cite{mccarthy60}. 
\item[Structured programming,]\idxs{Structured programming}, which emphasises organisation of code in units with well defined interfaces and isolation of internal states and code from other parts of the program. We will focus on Object-oriented programming is the example of structured programming. \idxs{Object-orientered programming} is a type of programming, where the states and programs are structured into \idx{objects}. A typical object-oriented design takes a problem formulation and identifies key nouns as potential objects and verbs as potential actions to be take on objects. The first object-oriented programming language was Simula~67 developed by Dahl and Nygaard at the Norwegian Computing Center in Oslo.
\end{description}
Most programs follows a single programming paradigm as, e.g., one of the above, but are a mix. Nevertheless, this book will treat each paradigm separately to emphasize their advantages and disadvantages.

\section{Why use F\#}
This book uses F\# also known as Fsharp, which is a functional first programming language that also supports imperativ and object oriented programming. It was originally developed for Microsoft's .Net platform, but is available as open source for many operating systems through Mono. As an introduction to programming, F\# is a young programming language still under development, with syntax that at times is a bit complex, but it offers a number of advantages:
\begin{description}
\item[Interactive and compile mode] F\# has an interactive and a compile mode of operation.
\item[Indentation for scope] F\# uses indentation to indicate scope.
\item[Strongly typed] F\# is strongly typed, reducing the number of run-time errors.
\item[Multi-platform] F\# is available on Linux, Mac OS X, Android, iOS, Windows, GPUs, and browsers via the Mono platform.
\item[Free to use and open source] F\# is supported by the Fsharp foundation (\url{http://fsharp.org}) and sponsored by Microsoft.
\item[Assemblies] F\# programs interface easily with other .Net and Mono programs through the language-independent, platform-independent bytecode called Common Intermediate Language (CIL).
\item[Modern computing] F\# supports all aspects of modern computing including Graphical User Interfaces, Web programming, Information rich programming, Parallel algorithms, \dots
\item[Integrated development environments (IDE)] F\# is supported by major IDEs such as Visual Studio (\url{https://www.visualstudio.com}) and Xamarin Studio (\url{https://www.xamarin.com}).
\end{description}

\section{How to read this book}
Learning to program requires mastering a programming language, however most programming languages contains details that are rarely used or used in contexts far from a specific programming topic. Hence, this book takes the approach to start with an introduction to the most basic concepts of F\# in Part~\ref{part:basics}, followed by the 3 programming paradigms in Part~\ref{part:imperative}--\ref{part:structured} while gradually expanding the introduction of F\# syntax and semantics. In Part~\ref{part:appendix} are a number of general topics given for reference. The disadvantage of this approach is that no single part contains a reference guide to F\# and F\# topics are revisited and expanded across the book. For further reading please consult \url{http://fsharp.org}.

%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
