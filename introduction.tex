\documentclass[fsharpnotes.tex]{subfiles}
\graphicspath{ {./figures/} }

\begin{document}
\chapter{Introduction}
\label{chap:introduction}
Programming is a creative process in which exciting problems may be solved and new tools and applications may be created. With programming skills, you can create high-level applications to run on a mobile device that interact with other users, databases, and artificial intelligence; you may create programs that run on supercomputers for simulating weather systems on alien planets or social phenomena in the internet economy; and you may create programs that run on small custom-made hardware for controlling your home appliances. 

\section{How to Learn to Solve Problems by Programming}
In order to learn how to program, there are a couple of steps that are useful:
\begin{enumerate}
\item Choose a programming language: A programming language, such as F\#, is a vocabulary and a set of grammatical rules for instructing a computer to perform a certain task. It is possible to program without a concrete language, but your ideas and thoughts must still be expressed in some fairly rigorous way. Theoretical computer scientists typically do not rely on computers nor programming languages but uses mathematics to prove properties of algorithms. However, most computer scientists program using a computer, and with a real language you have the added benefit of checking your algorithm, and hence your thoughts, rigorously on a real computer. This book teaches a subset of F\#. The purpose is not to be a reference guide to this language but to use it as a vessel to teach you, the reader, how to convert your ideas into programs.
\item Learn the language: A computer language is a structure for thought, and it influences which thoughts you choose to express as a program, and how you choose to do it. Any conversion requires you to acquire a sufficient level of fluency in order for you to be able to make programs. You do not need to be a master in F\# nor to know every corner of the language, and you will expand your knowledge as you expose yourself to solving problems in the language, but you must invest an initial amount of time and energy in order to learn the basics of the language. This book aims at getting you started quickly, which is why we intentionally teach just a small subset of F\#. On the internet and through other works you will be able to learn much more.
%, but keep in mind, that while languages are beautiful, it's what you express in the languages that allow you to shine.
\item Practice: In order to be a good programmer, the most essential step is: practice, practice, practice! It has been estimated that to master anything, then you have to have spent at least 10000 hours practicing, so get started logging hours! It of course matters, how you practice. This book teaches a number of different programming themes. The point is that programming is thinking, and the scaffold you use shapes your thoughts. It is therefore important to recognize this scaffold and to have the ability to choose one which suits your ideas and your goals best. The best way to expand your abilities is to sharpen your present abilities, push yourself into new territory, and try something new. Do not be afraid to make errors or be frustrated at first. These are the experiences that make you grow.
\item Solve real problems: I have found that using my programming skills in real situations with customers demanding specific solutions, has forced me to put the programming tools and techniques that I use into perspective. Sometimes a task requires a cheap and fast solution, other times customers want a long-perspective solution with bug fixes, upgrades, and new features. Practicing solving real problems helps you strike a balance between the two when programming. It also allows makes you a more practical programmer, by allowing you to recognize its applications in your everyday experiences. Regardless, real problems create real programmers.
\end{enumerate}

\section{How to Solve Problems}
Programming is the act of solving a problem by writing a program to be executed on a computer. A general method for solving problems, given by George Pólya~\cite{polya45} and adapted to programming, is:
\begin{description}
\item[Understand the problem:] To solve any problem it is crucial that the problem formulation is understood. What is to be solved? Do you understand everything in the description of the problem? Is all information for finding the solution available or is something missing?
\item[Design a plan:] Good designs lead to programs are faster to implement, easier to find errors in, and easier to update in the future. Before you start typing a program consider things like: What are the requirements and constraints for the program? Which components should the program have? How are these components supposed to work together? Designing often involves drawing a diagram of the program and writing program sketches on paper.
\item[Implement the plan:] Implementation is the act of transforming a program design into code. A crucial part of any implementation is choosing which programming language to use. Furthermore, the solution to many problems will have a number of implementations which vary in how much code they require, to which degree they rely on external libraries, which programming style they are best suited for, what machine resources they require, and how long time they take to run on a computer.  With a good design, the coding is usually easy, since the design will have uncovered the major issues and found solutions for these, but sometimes implementation reveals new problems, which require rethinking the design. Most often the implementation step also require a careful documentation of key aspects of the code, e.g., a user manual for the user, and internal notes for fellow programmers that are to maintain and update the code in the future.
\item[Reflect on the result:] A crucial part of any programming task is ensuring that the program solves the problem sufficiently. Ask yourself questions such as: What are the program's errors, is the documentation of the code sufficient and relevant for its intended use? Is the code easily maintainable and extendable by other programmers? Which parts of your method would you avoid or replicate in future programming sessions? Can you reuse some of the code you developed in other programs?
\end{description}
Programming is a very complicated process, and Pólya's list is a useful guide but not a fail-safe approach. Always approach problem-solving with an open mind.
% \jon{Should we mention core activities: Requirements, Design, Construction, Testing, Debugging, Deployment, Maintenance?}

\section{Approaches to Programming}
This book focuses on several fundamentally different approaches to programming: 
\begin{description}
\item[Imperative programming]\idxs{imperative programming} emphasizes \emph{how a program shall accomplish a solution} and focusses less on \emph{what the solution is}. A cooking recipe is an example of the spirit of imperative programming, where the recipe emphasizes what should be done in each step rather than describing the result. For example, a recipe for bread might tell you to first mix yeast and water, then add flour, etc. In imperative programming what should be done are called \idx[statement]{statements} and in the recipe analogy, the steps are the statements. Statements influence the computer's \idx[state]{states}, in the same way that adding flour changes the state of our dough. Almost all computer hardware is designed to execute low-level programs written in imperative style. Imperative programming builds on the Turing machine~\cite{turing36}. As a historical note, the first major language was FORTRAN~\cite{backus54} which emphasized an imperative style of programming.
\item[Declarative programming]\idxs{declarative programming} emphasizes \emph{what a program shall accomplish} but not \emph{how}. We will consider Functional programming as an example of declarative programming. A \idx{functional programming} language evaluates \idx[function]{functions} and avoids state changes. The program consists of \idx[expression]{expressions} instead of statements. As an example, the function $f(x) = x^2$ takes a number $x$, evaluates the expression $x^2$, and returns the resulting number. Everything about the function may be characterized by the relation between the input and output values.  Functional programming has its roots in lambda calculus~\cite{church36}. The first language emphasizing functional programming was Lisp~\cite{mccarthy60}. 
\item[Structured programming]\idxs{structured programming} emphasizes organization of programs in units of code and data. For example, a traffic light may consist of a state (red, yellow, green), and code for updating the state, i.e., switching from one color to the next. We will focus on Object-oriented programming as the example of structured programming. \idx[object-oriented programming]{Object-oriented programming} is a type of programming, where the code and data are structured into \idx[object]{objects}. E.g., a traffic light may be an object in a traffic-routing program. The first object-oriented programming language was Simula~67 developed by Dahl and Nygaard at the Norwegian Computing Center in Oslo~\cite{dahl.nygaard67}.
\item[Event-driven programming,]\idxs{event-driven programming} which is often used when dynamically interacting with the real world. This is useful, for example, when programming graphical user interfaces, where programs will often need to react to a user clicking on the mouse or to text arriving from a web-server to be displayed on the screen. Event-driven programs are often programmed using \idx[call-back function]{call-back functions}, which are small programs that are ready to run when events occur.
\end{description}
Most programs do not follow a single programming paradigm as, e.g., one of the above, but are a mix. Nevertheless, this book will treat each paradigm separately to emphasize its advantages and disadvantages.

\section{Why Use F\#}
This book uses F\#, also known as Fsharp, which is a functional first programming language, meaning that it is designed as a functional programming language that also supports imperative and object-oriented programming. It was originally developed for Microsoft's .Net platform but is available as open source for many operating systems through Mono. As an introduction to programming, F\# is a young programming language still under development, with syntax that at times is a bit complex. Still, it offers a number of advantages:
\begin{description}
\item[Interactive and compile mode:] F\# has an interactive and a compile mode of operation. In interactive mode you can write code that is executed immediately in a manner similar to working with a calculator, while in compile mode you combine many lines of code possibly in many files into a single application, which is easier to distribute to people who are not F\# experts and is faster to execute.
\item[Indentation for scope:] F\# uses indentation to indicate scope. Some lines of code belong together and should be executed in a certain order and may share data. Indentation helps in specifying this relationship.
\item[Strongly typed:] F\# is strongly typed, reducing the number of runtime errors. That is, F\# is picky, and will not allow the programmer to mix up types such as numbers and text. This is a great advantage for large programs.
\item[Multi-platform:] F\# is available on Linux, Mac OS X, Android, iOS, Windows, GPUs, and browsers via the Mono platform.
\item[Free to use and open source:] F\# is supported by the Fsharp foundation (\url{http://fsharp.org}) and sponsored by Microsoft.
\item[Assemblies:] F\# is designed to be able to easily communicate with other .Net and Mono programs through the language-independent, platform-independent bytecode called Common Intermediate Language (CIL) organized as assemblies. Thus, if you find that certain parts of a program are easy to express in F\# and others in C++, then you will be able to combine these parts later into a single program.
\item[Modern computing:] F\# supports all aspects of modern computing including Graphical User Interfaces, Web programming, Information rich programming, Parallel algorithms, \dots
\item[Integrated development environments (IDE):] F\# is supported by major IDEs such as Visual Studio (\url{https://www.visualstudio.com}) and Xamarin Studio (\url{https://www.xamarin.com}).
\end{description}

\section{How to Read This Book}
Learning to program requires mastering a programming language, however, most programming languages contain details that are rarely used or used in contexts far from a specific programming topic. Hence, this book only includes a subset of F\# but focuses on language structures necessary to understand several common programming paradigms: Imperative programming mainly covered in \Crefrange{chap:let}{chap:lists}, functional programming mainly covered in \Crefrange{sec:recursion}{chap:higherOrderFunctions}, object-oriented programming in \Cref{chap:oop,chap:oopp}, and event-driven programming in \Cref{chap:windows}.  A number of general topics are given in the appendix for reference. For further reading please consult \url{http://fsharp.org}.
\end{document}
%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:

