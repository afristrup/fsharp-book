\chapter{Controlling program flow}

\subsection{Conditional expressions}
\begin{lstlisting}[language=EBNF]
"if" expr "then" expr 
[{"elif" expr "then" expr}
"else" expr]
\end{lstlisting}
A basic flow control mechanism used both for functional and imperative programming is the \texttt{if-then-else} construction, e.g.,
\fs{flowIfThen}{}
I.e., if and only if the value of the argument is postive, then it will be printed on screen. More common is to include the \texttt{else} 
\fs{flowIfThenElse}{}
A common construction is a nested list of \texttt{if-then-else},
\fs{flowIfThenElseNested}{}
where the integers 0--2 are converted to characters, and integers outside this domain is converted to the nearest equivalent number. This construction is so common that a short-hand notation exists, and we may equivalently have written,
\fs{flowIfThenElseNestedShort}{}

\subsection{For and while loops}
A major difference between functional and imperative programming is how loops are expressed. Consider the problem of printing the numbers 1 to 5 on the console with a \texttt{while} loop can be done as follows,
\fs{flowWhile}{}
where the same result by recursion as
\fs{flowWhileRecursion}{}
The counting example is so often used that a special notation is available, the \texttt{for} loop, where the above could be implemented as
\fs{flowFor}{}
Note that \texttt{i} is a value and not a variable here. For a more complicated example, consider the problem of calculating average grades from a list of courses and grades. Using the above construction, this could be performed as,
\fs{flowForListsIndex}{}
However, an elegant alternative is available as
\fs{flowForLists}{}
This to be preferred, since we completely can ignore list boundary conditions and hence avoid out of range indexing. For comparison see a recursive implementation of the same,
\fs{flowForListsRecursive}{}
Note how this implementation avoids the use of variables in contrast to the previous examples.


%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
