\chapter{Functions and procedures}
\label{chap:functions}
Function definition follows the same syntax as literal binding,
%
\begin{lstlisting}[language=EBNF]
"let" ["rec"] ident valIdent {valIdent} [":" type] "=" expr ["in" expr]
valident = ident | "(" ident ":" type ")"
\end{lstlisting}

or specify the type of the function at point of definition using the notation,
\begin{lstlisting}[language=ebnf]
  "let" name argWType { argWType } [ ":" type ] "=" expr
  argWType = arg | "(" arg ":" type ")"
\end{lstlisting}
where not all types need to be declared, just sufficent for F\# to be able to infer the types for the full statement. In the example, one sufficent specification is,
\begin{lstlisting}[language=fsharp,caption=fsharpi]
> let sum (x : float) (y : float) = x + y;;

val sum : x:float -> y:float -> float

> let c = sum 357.6 863.4;;

val c : float = 1221.0
\end{lstlisting}
but alternatively we could have specified the type of the result,
\begin{lstlisting}[language=fsharp]
  let sum x y : float = x + y
\end{lstlisting}
or even just one of the arguments,
\begin{lstlisting}[language=fsharp]
  let sum (x : float) y = x + y
\end{lstlisting}
In both cases, since the \lstinline|+| \idx{operator} is only defined for \idx[operand]{operands} of the same type, then when the type of either the result, any or both operands are declared, then the type of the remaining follows directly.





A function that elegantly implements the incrementation operation may be constructed as,
%
\fs{mutableAssignIncrementEncapsulation}{}
%
\jon{Explain why this works!} Here the output of \texttt{incr} is an anonymous function, that takes no argument, increments the variable of \texttt{incr} and returns the new value of the counter. This construction is called \idx{encapsulation}, since the variable \texttt{counter} is hidden by the function \texttt{incr} from the user, i.e., the user need not be concerned with how the increment operator is implemented and the variable name used by \texttt{incr} does not clutter the scope where it is used.

Variables cannot be returned from functions, that is,
%
\fs{mutableAssignReturnValue}{}
%
declares a function that has no arguments and returns the value 0, while the same for a variable is illegal,
%
\fs{mutableAssignReturnVariable}{}
%
There is a workaround for this by using \idx{reference cells} by the build-in function \texttt{ref} and operators \token|!| and \token|:=|,
%
\fs{mutableAssignReturnRefCell}{}
%
That is, the \texttt{ref} function creates a reference variable, the '\token|!|' and the '\token|:=|' operators reads and writes its value. Reference cells are in some language called pointers, and their use is strongly discouraged, since they may cause \idx{side-effects}, which is the effect that one function changes the state of another, such as the following example demonstrates,
%
\fs{mutableAssignReturnSideEffect}{}
%
In the example, the function \texttt{updateFactor} changes a variable in the scope of \texttt{multiplyWithFactor}, which is prone to errors, since the style of programming does not follow the usual assignment syntax. Better style of programming is,
%
\fs{mutableAssignReturnWithoutSideEffect}{}
%
Here there can be no doubt in \texttt{multiplyWithFactor} that the value of '\texttt{a}' is changing. Side-effects do have their use, but should in general be avoided at almost all costs, and in general it is advised to refrain from using ref cells.














A function is a mapping between an input and output domain. F\# is a functional first programming language, and offers a number of alternative methods for specifying parameters. A simple example is,
\fs{functionDeclarationMul}{}
which declares a function of a tuple and returns their multiplication. The types are inferred from its first use in the second line, i.e., \texttt{mul} is \texttt{val mul : x:int * y:int -> int}.  An argument may be of generic type for input, which need not be inferred without sacrificing type safety, e.g.,
\fs{functionDeclarationGeneric}{}
Here the function \texttt{second} does not use the first element in the tuple, \texttt{x}, and the type of the second element, \texttt{y}, can safely be anything.

Functions may be anonymously declared using the \texttt{fun} keyword,
\fs{functionDeclarationAnonymous}{}
Anonymous functions are often used as arguments to other functions, e.g.,
\fs{functionDeclarationAnonymousAdvanced}{}
This is a powerfull concept, but can make programs hard to read, and overly use is not recommended.

Functions may be declared using pattern matching, which is a flexible method for declaring output depending on conditions on the input value. The most common pattern matching method is by use of the \texttt{match with} syntax,
\fs{functionDeclarationMatchWith}{}

A short-hand only for functions of 1 parameter is the \texttt{function} syntax,
\fs{functionDeclarationFunction}{}
Note that the name given in the match, here \texttt{n}, is not used in the first line, and is arbitrary at the line of pattern matchin, and may even be different on each line. For these reasons is this syntax discouraged.

Functions may be declared from other functions
\fs{functionDeclarationTupleCurrying}{}
For functions of more than 1 argument, there exists a short notation, which is called \idx{currying} in tribute of Haskell Curry,
\fs{functionDeclarationCurrying}{}
Here \texttt{mul 2.0} is a partial specification of the function \texttt{mul x y}, where the first argument is fixed, and hence, \texttt{double} is a function of 1 argument being the second argument of \texttt{mul}. Currying is often used in functional programming, but generally currying should be used carefully, since currying may seriously reduce readability of code.

\section{Procedures}
A \idx{procedure} is a generalisation of the concept of functions, and in contrast to functions procedures need not return values. An example, we've already seen is the \texttt{printfn}, which is used to print text on the console, but does not return a value. Coincidentally, since the console is a state, printing to it is a side-effect. Above we examined 
%\begin{fse}
%   let updateFactor factor = 
%    factor := 2
%\end{fse}
\fse{mutableAssignReturnSideEffectStump}{}
which also does not have a return value. Procedural thinking is useful for encapsulation, but is prone to side-effects and should be minimized by being replaced by functional thinking.

\jon{Maybe explain the printf function, Spec-4.0 Section 6.3.16
  'printf' Formats, but also max and min comparison functions and math
  functions Section 18.2.2 and 18.2.4?}
%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
