\chapter{Values, functions, and variables}
\label{chap:let}
%
In the previous chapter, we saw how to use F\# as a calculator working with literals, operators and built-in functions. To save time and make programs easier to read and debug, it is useful to bind expressions to identifiers either as new constants, functions or operators. For example, to solve for  $x$, when
\begin{equation}
  a x^2+bx+c = 0
\end{equation}
we use the quadratic formula from elementary algebra,
\begin{equation}
  x = \frac{-b\pm\sqrt{b^2-4ac}}{2a},
\end{equation}
and write a small program that defines functions calculating relevant values for any set of coefficients,
%
\fs{identifiersExample}{Finding roots for quadratic equations using function name binding.}
%
Here 3 functions are defined as \lstinline!determinant!, \lstinline!postiveSolution!, and \lstinline!negativeSolution! are defined, and applied to 3 values named \lstinline!a!, \lstinline!b!, and \lstinline!c!, and the results are named \lstinline!d!, \lstinline!xn!, and \lstinline!xp!. These names are examples of identifiers, and with these, we may reuse the quadratic formulas and calculated values later, while avoiding possible typing mistakes and reducing amount of code, which needs to be debugged.

The use of identifiers is central in programming. For F\# not to be confused by built-in functionality, identifiers must follow a specific grammar: An identifier must start with a letter, but can be followed by zero or more of letters, digits, and a range of special characters. An identifier must not be a keyword or a reserved-keyword listed in Figure~\ref{fig:keywords} and~\ref{fig:reservedKeywords}.
\begin{figure}
  \mbox{\lstinline{abstract},} \mbox{\lstinline{and},} \mbox{\lstinline{as},} \mbox{\lstinline{assert},} \mbox{\lstinline{base},} \mbox{\lstinline{begin},} \mbox{\lstinline{class},} \mbox{\lstinline{default},} \mbox{\lstinline{delegate},} \mbox{\lstinline{do},} \mbox{\lstinline{done},} \mbox{\lstinline{downcast},} \mbox{\lstinline{downto},} \mbox{\lstinline{elif},} \mbox{\lstinline{else},} \mbox{\lstinline{end},} \mbox{\lstinline{exception},} \mbox{\lstinline{extern},} \mbox{\lstinline{false},} \mbox{\lstinline{finally},} \mbox{\lstinline{for},} \mbox{\lstinline{fun},} \mbox{\lstinline{function},} \mbox{\lstinline{global},} \mbox{\lstinline{if},} \mbox{\lstinline{in},} \mbox{\lstinline{inherit},} \mbox{\lstinline{inline},} \mbox{\lstinline{interface},} \mbox{\lstinline{internal},} \mbox{\lstinline{lazy},} \mbox{\lstinline{let},} \mbox{\lstinline{match},} \mbox{\lstinline{member},} \mbox{\lstinline{module},} \mbox{\lstinline{mutable},} \mbox{\lstinline{namespace},} \mbox{\lstinline{new},} \mbox{\lstinline{null},} \mbox{\lstinline{of},} \mbox{\lstinline{open},} \mbox{\lstinline{or},} \mbox{\lstinline{override},} \mbox{\lstinline{private},} \mbox{\lstinline{public},} \mbox{\lstinline{rec},} \mbox{\lstinline{return},} \mbox{\lstinline{sig},} \mbox{\lstinline{static},} \mbox{\lstinline{struct},} \mbox{\lstinline{then},} \mbox{\lstinline{to},} \mbox{\lstinline{true},} \mbox{\lstinline{try},} \mbox{\lstinline{type},} \mbox{\lstinline{upcast},} \mbox{\lstinline{use},} \mbox{\lstinline{val},} \mbox{\lstinline{void},} \mbox{\lstinline{when},} \mbox{\lstinline{while},} \mbox{\lstinline{with},} and \mbox{\lstinline{yield}.}
  \caption{List of keywords in F\#.}
  \label{fig:keywords}
\end{figure}
\begin{figure}
  \mbox{\lstinline{atomic},} \mbox{\lstinline{break},} \mbox{\lstinline{checked},} \mbox{\lstinline{component},} \mbox{\lstinline{const},} \mbox{\lstinline{constraint},} \mbox{\lstinline{constructor},} \mbox{\lstinline{continue},} \mbox{\lstinline{eager},} \mbox{\lstinline{fixed},} \mbox{\lstinline{fori},} \mbox{\lstinline{functor},} \mbox{\lstinline{include},} \mbox{\lstinline{measure},} \mbox{\lstinline{method},} \mbox{\lstinline{mixin},} \mbox{\lstinline{object},} \mbox{\lstinline{parallel},} \mbox{\lstinline{params},} \mbox{\lstinline{process},} \mbox{\lstinline{protected},} \mbox{\lstinline{pure},} \mbox{\lstinline{recursive},} \mbox{\lstinline{sealed},} \mbox{\lstinline{tailcall},} \mbox{\lstinline{trait},} \mbox{\lstinline{virtual},} and \mbox{\lstinline{volatile}.}
  \caption{List of reserved keywords for possible future use in F\#.}
  \label{fig:reservedKeywords}
\end{figure} 
For characters in the Basic Latin Block, i.e., the first 128 code points alias ASCII characters, an ident is,
%
\begin{lstlisting}[language=EBNF]
dDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
letter = "A" | "B" | ... |  "Z" | "a" | "b" | ... | "z"
specialChar = "_"
ident = (letter | "_") {letter | dDigit | specialChar}
\end{lstlisting}
%
Thus, examples of identifiers are \lstinline{a}, \lstinline{theCharacter9}, \lstinline{Next_Word}, \lstinline{_tok}. The for the full definition, \lstinline[language=EBNF]{letter = Lu | Ll | Lt | Lm | Lo | Nl} and \lstinline[language=EBNF]{specialChar = Pc | Mn | Mc | Cf}, which referes to the Unicode general categories described in Appendix~\ref{sec:unicode}, and there are currently 19.345 possible Unicode code points in the \lstinline[language=EBNF]{letter} category and 2.245 possible Unicode code points in the \lstinline[language=EBNF]{specialChar} category. 
Binding expressions to identifiers is done with the keyword \keyword{let}, using the following simplified syntax:
%
\begin{lstlisting}[language=EBNF]
arg = ident | "(" ident ":" type ")"
argList = arg | arg argList
identOrOp = ident | ( operatorName )
expr = ... 
  | "let " ["mutable "] ident  [":" type] "=" expr " in " expr (* binding a value *)
  | "let " ident-or-op argList [":" type] "=" expr " in " expr (* binding a function or operator *)
  | "let " rec function-or-value-defns (* recursive definition *)
  | "fun " argList "->" expr (* a function as value *)
  | expr ":" type (* type annotation *)
  | "begin " expr " end" (* alternative block expression *)
  | expr; expr (* sequence of expression *)
  | ...
\end{lstlisting}
%
% \begin{lstlisting}[language=EBNF,caption=expressionArithmetic]
% ident-or-op = ident | ( op-name ) | (*)
% atomic-pat = pat : one of const long-ident list-pat record-pat array-pat (pat) :? atomic-type null _
% argument-pats: atomic-pat ... atomic-pat
% access = "public" | "private" | "internal"
% return-type = ":" type
% function-defn = ["inline "] [access] ident-or-op [typar-defns] argument-pats [return-type] = expr
% value-defn = ["mutable"] [access] pat [typar-defns] [return-type] = expr
% expr = ...
%   | "let " ["rec "] function-defn " in " expr (* function definition expression *)
%   | "let " value-defn " in " expr (* value definition expression *)
%   | "fun " argument-pats "->" expr
%   | ...
% \end{lstlisting}
% %
which will be discussed in the following.\jon{Spec-4.0 Section 6.6, function-or-value-defns, 1. makes little sense to have values definitions recursive, and 2. possible Mono deviation from specification: let rec function-defn and function-defn requires newline before and.}

\section{Values (Constant bindings)}
Binding identifiers to literals or expressions that are evaluated to be values is called value binding, and examples are \lstinline!let a = 3.0! and \lstinline!let b = cos 0.9!. On EBNF the simplified syntax,
%
\begin{lstlisting}[language=EBNF]
"let " ["mutable "] ident  [":" type] "=" expr [" in " | LF] expr
\end{lstlisting}
I.e., the \idx{\keyword{let}} keyword dictates that the identifier \lstinline[language=EBNF]!ident! is an alias of the expression \lstinline[language=EBNF]!expr!. The type may be especified with the \idx{\token{:}} token to type \lstinline[language=EBNF]!type!. The binding may be mutable as indicated by the keyword \idx{\keyword{mutable}}, which will be discussed in Section~\ref{sec:mutableValues}, and the binding holds \idx{lexically} for the last expression as indicated by the \idx{\keyword{in}} keyword.\jon{\url{https://coders-corner.net/2013/11/12/lexical-scope-vs-dynamic-scope/}} For example, letting the identifier \lstinline!p! be bound to the value \lstinline!2.0! and using it in an expression is done as follows,
%
\fs{letValue}{The identifier \lstinline!p! is used in the expression following the \keyword{in} keyword.}
%
In the interactive mode used in the example above, we see that F\# infers the type...
F\# will ignore most newlines between tokens, i.e., the above is equivalent to writting,
%
\fs{letValueLF}{Newlines after \keyword{in} make the program easier to read.}
%
F\# also allows for an alternative notation called \idx{lightweight syntax}, where e.g., the \keyword{in} keyword is replaced with a newline, and the expression starts on the next line at the same column as \keyword{let} starts in, i.e., the above is equivalent to
%
\fs{letValueLightWeight}{Lightweight syntax does not require the \keyword{in} keyword, but expression must be aligned with the \keyword{let} keyword.}
%
The same expression in interactive mode will also respond the infered types, e.g.,
%
\fso{letValueLightWeightTypes}{Interactive mode also responds inferred types.}
%
By the \keyword{val} keyword in the line \lstinline!val p : float = 2.0! we see that \lstinline!p! is inferred to be of type \lstinline!float! and bound to the value \lstinline!2.0!. The inference is based on the type of the right-hand-side, which is of type \lstinline!float!.  Identifiers may be defined to have a type using the \token{:} token, but the types on the left-hand-side and right-hand-side of the \token{=} token must be identical. I.e., mixing types gives an error,
%
\fs{letValueTypeError}{Binding error due to type mismatch.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi, binding error due to type mismatch.}]
%   > let a : float = 3;;
%
%   let a : float = 3;;
%   ----------------^
%
% /Users/sporring/repositories/fsharpNotes/stdin(50,17): error FS0001: This expression was expected to have type
%     float    
% but here has type
%     int    
% \end{lstlisting}
Here, the left-hand-side is defined to be an identifier of type float, while the right-hand-side is a literal of type integer.

An expression can be a sequence of expressions separated by the token \token{;}, e.g.,
%
\fs{letValueSequence}{A value binding for a sequence of expressions.}
%
The lightweight syntax automatically inserts the \token{;} token at newlines, hence using the lightweight syntax the above is the same as,
%
\fs{letValueSequenceLightWeight}{A value binding for a sequence using lightweight syntax.}
%

A key concept of programming is \idx{scope}. In F\#, the scope of a value binding is lexically meaning that the binding is constant from the \keyword{let} statement defining it, untill it is redefined, e.g.,
%
\fs{letValueScopeLower}{Redefining identifiers is allowed in lower scopes.}
%
Scopes are given levels, and scopes may be nested, where the nested scope has a level one lower than its parent. F\# distinguishes between the top and lower levels, and at the top level in the lightweight syntax, redefining values is not allowed, e.g.,
%
\fs{letValueScopeLowerError}{Redefining identifiers is not allowed in lightweight syntax at top level.}
%
But using \keyword{begin} and \keyword{end} keywords, we create a \idx{block} which acts as a \idx{nested scope}, and then redefining is allowed, e.g.,
%
\fs{letValueScopeBlockAlternative2}{A block has lower scope level, and rebinding is allowed.}
%
It is said that the second binding \idx{overshadows} the first.
Alternatively we may use parentheses to create a block, e.g.,
%
\fs{letValueScopeBlockAlternative3}{A block may be created using parentheses.}
%
In both cases we used indentation, which is good practice, but not required here.  Lowering level is a natural part of function definitions to be discussed in Section~\ref{sec:functions} and flow control structures to be discussed in Chapter~\ref{chap:flow}.

Defining blocks is useful for controling the extend of a lexical scope of bindings. For example, adding a second \lstinline!printfn! statement,
%
\fs{letValueScopeBlockProblem}{Overshadowing hides the first binding.}
%
will print the value 4 last bound to the identifier \lstinline!p!, since token \token{;} associates to the right, i.e., the above is interpreted as \lstinline!let p = 3 in let p = 4 in (printfn "%A" p; printfn "%A" p)!. Instead we may create a block as,\jon{spacing in lstinline mode after double quotation mark is weird.}
%
\fs{letValueScopeBlock}{Blocks allow for the return to the previous scope.}
%
Here the lexical scope of \lstinline!let p = 4 in ...! is for the nested scope, which ends at \token{)}, returning to the lexical scope of \lstinline!let p = 3 in ...!. Alternatively, the \keyword{begin} and \keyword{end} keywords could equally have been used.
%\fs{letValueScopeBlockAlternative}{}

\jon{Remember to say something about interactive scripts and the \texttt{;;} token and scope}

\section{Functions (function bindings)}
\label{sec:functions}
A function is a mapping between an input and output domain. F\# is a functional first programming language, and offers a number of alternative methods for specifying parameters, which will be discussed in this section. Binding identifieres to functions follows a syntax similar to value binding,
%
\begin{lstlisting}[language=EBNF]
arg = ident | "(" ident ":" type ")"
argList = arg | arg argList
identOrOp = ident | ( operatorName )
expr = ... 
  | "let " ident-or-op argList [":" type] "=" expr " in " expr (* binding a function or operator *)
  | ...
\end{lstlisting}
An example in interactive mode is,
%
\fso{letFunction}{An example of a binding of an identifier and a function.}
%
and we see that the function is interpreted to have the type \lstinline!val sum : x:float -> y:float -> float!. The \token{->} token means a mapping between sets, in this case floats. The function is also a higher order function, to be discussed in detail below, and here it suffices to think of \lstinline!sum! as a function that takes 2 floats as argument and returns a float.
%, that \token{->} associates to the right, hence \lstinline!x:float -> y:float -> float! is equivalent to \lstinline!x:float -> (y:float -> float)! and thus, \lstinline!sum x! is a function, which gives a function

Not all types need to be declared, just sufficent for F\# to be able to infer the types for the full statement. In the example, one sufficent specification is, and we could just have specified the type of the result,
%
\fse{letFunctionAlterantive}{All types need most often not be specified.}
%
or even just one of the arguments,
%
\fse{letFunctionAlterantive2}{Just one type is often enough for F\# to infer the rest.}
%
In both cases, since the \lstinline|+| \idx{operator} is only defined for \idx[operand]{operands} of the same type, then when the type of either the result, any or both operands are declared, then the type of the remaining follows directly.  As for values, lightweight syntax automatically inserts the keyword \keyword{in} and the token \token{;},
%
\fs{letFunctionLightWeight}{Lightweight syntax for function definitions.}
%

Arguments need not always be inferred to types, but may be of generic type, which F\# prefers, when \idx{type safety} is ensured, e.g.,
%
\fso{functionDeclarationGeneric}{Typesafety implies that a function will work for any type, and hence it is generic.}
%
Here the function \lstinline{second} does not use the first argument, \lstinline{x} which is any type called \lstinline{'a}, and the type of the second element, \lstinline{y}, is also any type an not nessecarily the same as \lstinline!x!, so it is called \lstinline!'b!. Finally the result is the same type as \lstinline!y!, whatever it is. This is an example of a \idx{generic function}.

A function may contain a sequence of expressions, but must return a value. E.g., the quadratic formula may written as, 
%
\fs{identifiersExampleAdvance}{A function may contain sequences of expressions.}
%
Here we used the lightweight syntax, where the \token{=} identifies the start of a nested scope, and F\# identifies the scope by indentation. The amount of space used for indentation is does not matter, but all lines following the first must use the same. The scope ends before the first line with the previous indentation or none. Notice how the last expression is not bound to an identifier, but is the result of the function, i.e., in contrast to many other languages, F\# does not have an explicit keyword for returning values. Note also that since the function \lstinline!determinant! is defined in the nested scope of \lstinline!solution!, then  \lstinline!determinant! cannot be called outside \lstinline!solution!, since the scope ends before \lstinline!let a = 1.0!.

\idx[lexical scope]{Lexical scope} and function definitions can be a cause of confusion as the following example shows,
%
\fs{lexicalScopeNFunction}{Lexical scope means that $f(z) = 3x$ and not $4x$ at the time of calling.}
%
Here the value binding for \lstinline!a! is redefined, after it has been used to define a helper function \lstinline!f!. So which value of \lstinline!a! is used when we later apply \lstinline!f! to an argument? To resolve the confusion, remember that value binding is lexically defined, i.e., the binding \lstinline!let f z = a * x! uses the value of \lstinline!a!, it has by the ordering of the lines in the script, not dynamically by when \lstinline!f! was called. Hence, \advice{think of lexical scope as substitution of an identifier with its value or function immediately at the place of definition.} I.e., since \lstinline!a! and \lstinline!3.0! are synonymous in the first lines of the program, then the function \lstinline!f! is really defined as, \lstinline!let f z = 3.0 * x!. \jon{comment on dynamic scope and mutable variables.}

Functions do not need a name, but may be declared as an \idx{anonymous function} using the \keyword{fun} keyword and the \token{->} token,
%
\fs{functionDeclarationAnonymous}{Anonymous functions are functions as values.}
%
Here a name is bound to an anonymous function, which returns the first of two arguments. The difference to \lstinline!let first x y = x! is that anonymous functions may be treated as values, meaning that they may be used as arguments to other functions, and new values may be reassigned to their identifiers, when mutable, as will be discussed in Section~\label{sec:mutableValues}. A common use of anonymous functions is as as arguments to other functions, e.g.,
%
\fs{functionDeclarationAnonymousAdvanced}{Anonymous functions are often used as arguments for other functions.}
%
Note that here \lstinline!apply! is given 3 arguments, the function \lstinline!mul! and 2 integers. It is not given the result of \lstinline!mul 3 6!, since that would not match the definition of \lstinline!apply!. \advice{Anonymous functions and functions as arguments are powerfull concepts, but tend to make programs harder to read, and their use should be limited.}

Functions may be declared from other functions
\fs{functionDeclarationTupleCurrying}{}
For functions of more than 1 argument, there exists a short notation, which is called \idx{currying} in tribute of Haskell Curry,
%
\fs{functionDeclarationCurrying}{}
%
Here \lstinline{mul 2.0} is a partial specification of the function \lstinline{mul x y}, where the first argument is fixed, and hence, \lstinline{double} is a function of 1 argument being the second argument of \lstinline{mul}. Currying is often used in functional programming, but generally \advice{currying should be used carefully, since currying may seriously reduce readability of code.}

A \idx{procedure} is a generalisation of the concept of functions, and in contrast to functions procedures need not return values,
%
\fs{procedure}{A procedure is a function that has no return value, which in F\# implies\token{()} as return value.}
In F\# this is automatically given the unit type as return value. Procedural thinking is useful for \idx{encapsulation} of scripts, but is prone to \idx{side-effects} and should be minimized by being replaced by functional thinking. More on side-effects in Section~\ref{sec:mutable}.
%An example, we've already seen is the \texttt{printfn}, which is used to print text on the console, but does not return a value. Coincidentally, since the console is a state, printing to it is a side-effect. Above we examined 
%\begin{fse}
%   let updateFactor factor = 
%    factor := 2
%\end{fse}
%\fse{mutableAssignReturnSideEffectStump}{}
which also does not have a return value. Procedural thinking is useful for encapsulation, but is prone to side-effects and should be minimized by being replaced by functional thinking.

\section{User-defined operators}
\label{sec:functions}
Operators are functions, e.g., the infix multiplication operator \lstinline!+! is equivalent to the function \lstinline!(+)!, e.g.,
%
\fs{addOperatorNFunction}{}
%
All operator has this option, and you may redefine them and define your own operators, who has names specified by the following simplified EBNF:
\begin{lstlisting}[language=EBNF, caption={Grammar for infix and prefix tokens},label=list:infixOrPrefixOperators]
infixOrPrefixOp := "+" | "-" | "+. " | "-. " | "%" | "&" | "&&"
tildes = "~" | "~" tildes
prefixOp = infixOrPrefixOp | tildes | (! {opChar} - "!=")
dots = "." | "." dots
infixOp = 
  {dots} (
    infixOrPrefixOp  
    | "-" {opChar} 
    | "+" {opChar} 
    | "||" 
    | "<" {opChar} 
    | ">" {opChar} 
    | "="  
    | " |" {opChar} 
    | "&" {opChar} 
    | "^" {opChar} 
    | "*" {opChar} 
    | "/" {opChar} 
    | "%" {opChar} 
    | "!=" )
  | ":=" | "::" | "$" | "?"
\end{lstlisting}
%opChar = "!" | "%" | "&" | "*" | "+" | "-" | ". " | "/" | "<" | "=" | ">" | "@" | "^" | "|" | "~" 
%op = opChar {opChar}
%identOrOp = ident | "(" op ")"
%$
The precedence rules and associtivity of user-defined operators follows the rules for which they share prefixes with built-in rules, see Table~\ref{tab:operatorPrecedenceFull}. E.g., \lstinline!.*!, \lstinline!+++!, and \lstinline!<+! are legal operator names for inffix operators, they have precedence as ordered, and their associativity are all left. Using \lstinline!~! as the first character in the definition of an operator makes the operator unary and will not be part of the name. Examples of definitions and use of operators are,
%
\fs{operatorDefinitions}{}
%
Beware, redefining existing operators lexically redefines all future uses of operator for all types, hence \advice{it is not a good idea to redefine operators, but better to define new.}\jon{It seems there is a bug in mono: \texttt{let (~+) x = x+1 in printfn "\%A" +1;;} prints 1 and not 2.} In Chapter~/ref{chap:oop} we will discuss how to define type specific operators including prefix operators. 

Operators beginning with \lstinline!*! must use a space in its definition, \lstinline!( *! in order for it not to be confused with the beginning of a comment. \lstinline!(*!. \jon{this requires comments to be describe previously!}

\section{Printf}
\label{sec:printf}
\jon{Maybe explain the printf function, Spec-4.0 Section 6.3.16
  'printf' Formats, but also max and min comparison functions and math
  functions Section 18.2.2 and 18.2.4?}

\section{Variables (Mutable bindings)}
\label{sec:mutableValues}
The \keyword{mutable} in \keyword{let} bindings means that the identifier may be rebound to a new value using the following syntax,
%
\begin{lstlisting}[language=EBNF]
ident "<-" expr
\end{lstlisting}
\idx{Mutable data} is synonymous with the term \idx{variable}. A variable is an area in the computers working memory associated with an identifier and a type, and this area may be read from and written to during program execution. For example,
%
\fs{mutableAssignReassingShort}{A variable is defined and later reassigned a new value.}
%\fs{mutableAssignReassing}{}
%
Here a area in memory was denoted \texttt{x}, initially assigned the integer value 5, hence the type was inferred to be \lstinline|int|.  Later, this value of \texttt{x} was replaced with another integer using the \idx{\token{<-}} token. The \token{<-} token is used to distinguish the assignment from the comparison operator, i.e., if we by mistake had written,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, example of changing the content of a variable.}]
> let mutable a = 0
- a = 3;;

val mutable a : int = 0
val it : bool = false
\end{lstlisting}
%
then we instead would have obtained the default assignment of the result of the comparision of the content of \lstinline|a| with the integer 3, which is false. However, it's important to note, that when the variable is initially defined, then the '\token|=|' operator must be used, while later reassignments must use the \token|<-|  operator. 

Assignment type mismatches will result in an error, 
%
\fs{mutableAssignReassingTypeError}{Assignmetn type mismatching causes a compile time error.}
%
I.e., once the type of an identifier has been declared or infered, then it cannot be changed.

A typical variable is a counter of type integer, and a typical use of counters is to increment them, i.e., erasing a new value to be one more that its previous value. For example,
%
\fs{mutableAssignIncrement}{Variable increment is a common use of variables.}
%
which is an example we will return to many times later in this text.


*********

A function that elegantly implements the incrementation operation may be constructed as,
%
\fs{mutableAssignIncrementEncapsulation}{}
%
\jon{Explain why this works!} Here the output of \texttt{incr} is an anonymous function, that takes no argument, increments the variable of \texttt{incr} and returns the new value of the counter. This construction is called \idx{encapsulation}, since the variable \texttt{counter} is hidden by the function \texttt{incr} from the user, i.e., the user need not be concerned with how the increment operator is implemented and the variable name used by \texttt{incr} does not clutter the scope where it is used.

*******

Variables cannot be returned from functions, that is,
%
\fs{mutableAssignReturnValue}{}
%
declares a function that has no arguments and returns the value 0, while the same for a variable is illegal,
%
\fs{mutableAssignReturnVariable}{}
%
There is a workaround for this by using \idx{reference cells} by the build-in function \texttt{ref} and operators \token|!| and \token|:=|,
%
\fs{mutableAssignReturnRefCell}{}
%
That is, the \texttt{ref} function creates a reference variable, the '\token|!|' and the '\token|:=|' operators reads and writes its value. Reference cells are in some language called pointers, and their use is strongly discouraged, since they may cause \idx{side-effects}, which is the effect that one function changes the state of another, such as the following example demonstrates,
%
\fs{mutableAssignReturnSideEffect}{}
%
In the example, the function \texttt{updateFactor} changes a variable in the scope of \texttt{multiplyWithFactor}, which is prone to errors, since the style of programming does not follow the usual assignment syntax. Better style of programming is,
%
\fs{mutableAssignReturnWithoutSideEffect}{}
%
Here there can be no doubt in \texttt{multiplyWithFactor} that the value of '\texttt{a}' is changing. Side-effects do have their use, but should in general be avoided at almost all costs, and in general it is advised to refrain from using ref cells.






o




\jon{Somewhere I should talk about whitespaces and newlines Spec-4.0
  Chapter 3.1}

\jon{Somewhere I should possibly talk about Lightweight Syntax, Spec-4.0 Chapter 15.1}

\dots

%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
