\chapter{Identifiers, functions, and variables}
\label{chap:let}
An identifier is bound to an expression by the syntax,
%
\begin{lstlisting}[language=EBNF]
"let" [ "mutable" ] ident [":" type] "=" expr ["in" expr]
\end{lstlisting}
\begin{comment}
or alternatively
%
\begin{lstlisting}[language=EBNF]
"let" ["mutable"] ident [":" type] "=" expr ["in" newline indent exp]
\end{lstlisting}
\end{comment}
That is, the \idx{\keyword{let}} keyword indicates that the following is a binding of an identifier with an expression, and that the type may be specified with the \idx{\token{:}} token. An identifier must start with a letter, but can be followed by zero or more of letters, digits, and a range of special characters. For characters in the Basic Latin Block, i.e., the first 128 code points alias ASCII characters, an ident is,
%
\begin{lstlisting}[language=EBNF]
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
letter = "A" | "B" | ... |  "Z" | "a" | "b" | ... | "z"
special-char = "_"
ident = (letter | "_") {letter | digit | special-char}
\end{lstlisting}
%
Thus, examples of identifiers are \lstinline{a}, \lstinline{theCharacter9}, \lstinline{Next_Word}, \lstinline{_tok}. The for the full definition, \lstinline[language=EBNF]{letter = Lu | Ll | Lt | Lm | Lo | Nl} and \lstinline[language=EBNF]{special-char = Pc | Mn | Mc | Cf}, which referes to the Unicode general categories described in Appendix~\ref{sec:unicode}, and there are currently 19.345 possible Unicode code points in the \lstinline[language=EBNF]{letter} category and 2.245 possible Unicode code points in the \lstinline[language=EBNF]{special-char} category. An identifier must not be a keyword or a reserved-keyword, shown in Figure~\ref{fig:keywords} and~\ref{fig:reservedKeywords}.
\begin{figure}
  \mbox{\lstinline{abstract},} \mbox{\lstinline{and},} \mbox{\lstinline{as},} \mbox{\lstinline{assert},} \mbox{\lstinline{base},} \mbox{\lstinline{begin},} \mbox{\lstinline{class},} \mbox{\lstinline{default},} \mbox{\lstinline{delegate},} \mbox{\lstinline{do},} \mbox{\lstinline{done},} \mbox{\lstinline{downcast},} \mbox{\lstinline{downto},} \mbox{\lstinline{elif},} \mbox{\lstinline{else},} \mbox{\lstinline{end},} \mbox{\lstinline{exception},} \mbox{\lstinline{extern},} \mbox{\lstinline{false},} \mbox{\lstinline{finally},} \mbox{\lstinline{for},} \mbox{\lstinline{fun},} \mbox{\lstinline{function},} \mbox{\lstinline{global},} \mbox{\lstinline{if},} \mbox{\lstinline{in},} \mbox{\lstinline{inherit},} \mbox{\lstinline{inline},} \mbox{\lstinline{interface},} \mbox{\lstinline{internal},} \mbox{\lstinline{lazy},} \mbox{\lstinline{let},} \mbox{\lstinline{match},} \mbox{\lstinline{member},} \mbox{\lstinline{module},} \mbox{\lstinline{mutable},} \mbox{\lstinline{namespace},} \mbox{\lstinline{new},} \mbox{\lstinline{null},} \mbox{\lstinline{of},} \mbox{\lstinline{open},} \mbox{\lstinline{or},} \mbox{\lstinline{override},} \mbox{\lstinline{private},} \mbox{\lstinline{public},} \mbox{\lstinline{rec},} \mbox{\lstinline{return},} \mbox{\lstinline{sig},} \mbox{\lstinline{static},} \mbox{\lstinline{struct},} \mbox{\lstinline{then},} \mbox{\lstinline{to},} \mbox{\lstinline{true},} \mbox{\lstinline{try},} \mbox{\lstinline{type},} \mbox{\lstinline{upcast},} \mbox{\lstinline{use},} \mbox{\lstinline{val},} \mbox{\lstinline{void},} \mbox{\lstinline{when},} \mbox{\lstinline{while},} \mbox{\lstinline{with},} and \mbox{\lstinline{yield}.}
  \caption{List of keywords in F\#.}
  \label{fig:keywords}
\end{figure}
\begin{figure}
  \mbox{\lstinline{atomic},} \mbox{\lstinline{break},} \mbox{\lstinline{checked},} \mbox{\lstinline{component},} \mbox{\lstinline{const},} \mbox{\lstinline{constraint},} \mbox{\lstinline{constructor},} \mbox{\lstinline{continue},} \mbox{\lstinline{eager},} \mbox{\lstinline{fixed},} \mbox{\lstinline{fori},} \mbox{\lstinline{functor},} \mbox{\lstinline{include},} \mbox{\lstinline{measure},} \mbox{\lstinline{method},} \mbox{\lstinline{mixin},} \mbox{\lstinline{object},} \mbox{\lstinline{parallel},} \mbox{\lstinline{params},} \mbox{\lstinline{process},} \mbox{\lstinline{protected},} \mbox{\lstinline{pure},} \mbox{\lstinline{recursive},} \mbox{\lstinline{sealed},} \mbox{\lstinline{tailcall},} \mbox{\lstinline{trait},} \mbox{\lstinline{virtual},} and \mbox{\lstinline{volatile}.}
  \caption{List of reserved keywords for possible future use in F\#.}
  \label{fig:reservedKeywords}
\end{figure}
The binding may be mutable, which will be discussed in Section~\ref{sec:mutableValues}, and the binding may only be for the last expression as indicated by the \idx{\keyword{in}} keyword. The simplest example of an expression is a \idx{literal}, i.e., a constant such as the number 3. 


A less common notation is to define bindings for expressions using the \idx{\keyword{in}} keyword, e.g.,
%
\fs{numbersIn}{The identifier \lstinline!p! is only bound in the nested scope following the keyword \keyword{in}.}
%
Here \lstinline|p| is only bound in the \idx{scope} of the expression following the \keyword{in} keyword, in this the \lstinline|printfn| statement, and \lstinline|p| is unbound in lines that follows.
\begin{comment}
  Here the use of indentation to define a sequence of expressions
  % 
  \fs{numbersInWIndentation}{The identifier \lstinline!p! is only bound in the nested scope following the keyword \keyword{in}.}
  % 
\end{comment}


\section{Values (Constant bindings)}
When specifying the type, the type and the literal form must match, i.e., mixing types and literals gives an error,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, binding error due to type mismatch.}]
  > let a : float = 3;;

  let a : float = 3;;
  ----------------^

/Users/sporring/repositories/fsharpNotes/stdin(50,17): error FS0001: This expression was expected to have type
    float    
but here has type
    int    
\end{lstlisting}
since the left-hand-side is an identifier of type float, while the right-hand-side is a literal of type integer.

\section{Variables (Mutable bindings)}
\label{sec:mutableValues}
The \keyword{mutable} in \keyword{let} bindings means that the identifier may be rebound to a new value using the following syntax,
%
\begin{lstlisting}[language=EBNF]
ident "<-" expr
\end{lstlisting}
\idx{Mutable data} is synonymous with the term \idx{variable}. A variable is an area in the computers working memory associated with an identifier and a type, and this area may be read from and written to during program execution. For example,
%
\fs{mutableAssignReassingShort}{A variable is defined and later reassigned a new value.}
%\fs{mutableAssignReassing}{}
%
Here a area in memory was denoted \texttt{x}, initially assigned the integer value 5, hence the type was inferred to be \lstinline|int|.  Later, this value of \texttt{x} was replaced with another integer using the \idx{\token{<-}} token. The \token{<-} token is used to distinguish the assignment from the comparison operator, i.e., if we by mistake had written,
%
\begin{lstlisting}[language=fsharp,caption={fsharpi, example of changing the content of a variable.}]
> let mutable a = 0
- a = 3;;

val mutable a : int = 0
val it : bool = false
\end{lstlisting}
%
then we instead would have obtained the default assignment of the result of the comparision of the content of \lstinline|a| with the integer 3, which is false. However, it's important to note, that when the variable is initially defined, then the '\token|=|' operator must be used, while later reassignments must use the \token|<-|  operator. 

Assignment type mismatches will result in an error, 
%
\fs{mutableAssignReassingTypeError}{Assignmetn type mismatching causes a compile time error.}
%
I.e., once the type of an identifier has been declared or infered, then it cannot be changed.

A typical variable is a counter of type integer, and a typical use of counters is to increment them, i.e., erasing a new value to be one more that its previous value. For example,
%
\fs{mutableAssignIncrement}{Variable increment is a common use of variables.}
%
which is an example we will return to many times later in this text.

\jon{Somewhere I should talk about whitespaces and newlines Spec-4.0
  Chapter 3.1}

\jon{Somewhere I should possibly talk about Lightweight Syntax, Spec-4.0 Chapter 15.1}

\dots


\section{Functions and procedures (function bindings)}
\label{chap:functions}
Function definition follows the same syntax as literal binding,
%
\begin{lstlisting}[language=EBNF]
"let" ["rec"] ident valIdent {valIdent} [":" type] "=" expr ["in" expr]
valident = ident | "(" ident ":" type ")"
\end{lstlisting}

or specify the type of the function at point of definition using the notation,
\begin{lstlisting}[language=ebnf]
  "let" name argWType { argWType } [ ":" type ] "=" expr
  argWType = arg | "(" arg ":" type ")"
\end{lstlisting}
where not all types need to be declared, just sufficent for F\# to be able to infer the types for the full statement. In the example, one sufficent specification is,
\begin{lstlisting}[language=fsharp,caption=fsharpi]
> let sum (x : float) (y : float) = x + y;;

val sum : x:float -> y:float -> float

> let c = sum 357.6 863.4;;

val c : float = 1221.0
\end{lstlisting}
but alternatively we could have specified the type of the result,
\begin{lstlisting}[language=fsharp]
  let sum x y : float = x + y
\end{lstlisting}
or even just one of the arguments,
\begin{lstlisting}[language=fsharp]
  let sum (x : float) y = x + y
\end{lstlisting}
In both cases, since the \lstinline|+| \idx{operator} is only defined for \idx[operand]{operands} of the same type, then when the type of either the result, any or both operands are declared, then the type of the remaining follows directly.





A function that elegantly implements the incrementation operation may be constructed as,
%
\fs{mutableAssignIncrementEncapsulation}{}
%
\jon{Explain why this works!} Here the output of \texttt{incr} is an anonymous function, that takes no argument, increments the variable of \texttt{incr} and returns the new value of the counter. This construction is called \idx{encapsulation}, since the variable \texttt{counter} is hidden by the function \texttt{incr} from the user, i.e., the user need not be concerned with how the increment operator is implemented and the variable name used by \texttt{incr} does not clutter the scope where it is used.

Variables cannot be returned from functions, that is,
%
\fs{mutableAssignReturnValue}{}
%
declares a function that has no arguments and returns the value 0, while the same for a variable is illegal,
%
\fs{mutableAssignReturnVariable}{}
%
There is a workaround for this by using \idx{reference cells} by the build-in function \texttt{ref} and operators \token|!| and \token|:=|,
%
\fs{mutableAssignReturnRefCell}{}
%
That is, the \texttt{ref} function creates a reference variable, the '\token|!|' and the '\token|:=|' operators reads and writes its value. Reference cells are in some language called pointers, and their use is strongly discouraged, since they may cause \idx{side-effects}, which is the effect that one function changes the state of another, such as the following example demonstrates,
%
\fs{mutableAssignReturnSideEffect}{}
%
In the example, the function \texttt{updateFactor} changes a variable in the scope of \texttt{multiplyWithFactor}, which is prone to errors, since the style of programming does not follow the usual assignment syntax. Better style of programming is,
%
\fs{mutableAssignReturnWithoutSideEffect}{}
%
Here there can be no doubt in \texttt{multiplyWithFactor} that the value of '\texttt{a}' is changing. Side-effects do have their use, but should in general be avoided at almost all costs, and in general it is advised to refrain from using ref cells.














A function is a mapping between an input and output domain. F\# is a functional first programming language, and offers a number of alternative methods for specifying parameters. A simple example is,
\fs{functionDeclarationMul}{}
which declares a function of a tuple and returns their multiplication. The types are inferred from its first use in the second line, i.e., \texttt{mul} is \texttt{val mul : x:int * y:int -> int}.  An argument may be of generic type for input, which need not be inferred without sacrificing type safety, e.g.,
\fs{functionDeclarationGeneric}{}
Here the function \texttt{second} does not use the first element in the tuple, \texttt{x}, and the type of the second element, \texttt{y}, can safely be anything.

Functions may be anonymously declared using the \texttt{fun} keyword,
\fs{functionDeclarationAnonymous}{}
Anonymous functions are often used as arguments to other functions, e.g.,
\fs{functionDeclarationAnonymousAdvanced}{}
This is a powerfull concept, but can make programs hard to read, and overly use is not recommended.

Functions may be declared using pattern matching, which is a flexible method for declaring output depending on conditions on the input value. The most common pattern matching method is by use of the \texttt{match with} syntax,
\fs{functionDeclarationMatchWith}{}

A short-hand only for functions of 1 parameter is the \texttt{function} syntax,
\fs{functionDeclarationFunction}{}
Note that the name given in the match, here \texttt{n}, is not used in the first line, and is arbitrary at the line of pattern matchin, and may even be different on each line. For these reasons is this syntax discouraged.

Functions may be declared from other functions
\fs{functionDeclarationTupleCurrying}{}
For functions of more than 1 argument, there exists a short notation, which is called \idx{currying} in tribute of Haskell Curry,
\fs{functionDeclarationCurrying}{}
Here \texttt{mul 2.0} is a partial specification of the function \texttt{mul x y}, where the first argument is fixed, and hence, \texttt{double} is a function of 1 argument being the second argument of \texttt{mul}. Currying is often used in functional programming, but generally currying should be used carefully, since currying may seriously reduce readability of code.

\section{Procedures}
A \idx{procedure} is a generalisation of the concept of functions, and in contrast to functions procedures need not return values. An example, we've already seen is the \texttt{printfn}, which is used to print text on the console, but does not return a value. Coincidentally, since the console is a state, printing to it is a side-effect. Above we examined 
%\begin{fse}
%   let updateFactor factor = 
%    factor := 2
%\end{fse}
\fse{mutableAssignReturnSideEffectStump}{}
which also does not have a return value. Procedural thinking is useful for encapsulation, but is prone to side-effects and should be minimized by being replaced by functional thinking.

\section{Printf}
\label{sec:printf}
\jon{Maybe explain the printf function, Spec-4.0 Section 6.3.16
  'printf' Formats, but also max and min comparison functions and math
  functions Section 18.2.2 and 18.2.4?}
%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
