\documentclass[fsharpnotes.tex]{subfiles}
\graphicspath{ {./figures/} }

\begin{document}
\chapter{Language Details}

Minimal F\# used in \Cref{part:basics}
\begin{lstlisting}[language=ebnf]
(* Whitespace *)
whitespace = ' ' {' '}
newline = '\n' | '\r' '\n'
whitespace-or-newline = whitespace | newline
 
(* Literal *)
(* Literal: Digit *)
dDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
bDigit = "0" | "1"
oDigit  = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"
xDigit  =  
  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
  | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" 

(* Literal: Integer *)
int = dInt | xint
sbyte = (dInt | xInt) "y"
byte = ((dInt | xInt) "uy")
int32 = (dInt | xInt) ["l"]
uint32 = (dInt | xInt) ("u" | "ul")
 
dInt = dDigit {dDigit}
bitInt = "0" ("b" | "B") bDigit {bDigit}
octInt = "0" ("o" | "O") oDigit {oDigit}
hexInt = "0" ("x" | "X") xDigit {xDigit}
xint = bitInt | octInt | hexInt

(* Literal: float *)
float = dFloat | sFloat
dFloat = dInt "." {dDigit}
sFloat = (dInt | dFloat) ("e" | "E" ) ["+" | "-"] dInt
ieee64 = float | (xInt "LF")

(* Literal: char *)
char = "'" codePoint | escapeChar "'"
escapeChar = 
  "\" ("b" | "n" | "r" | "t" | "\" | '"' | "'" | "a" | "f" | "v")
  | "\u" xDigit xDigit xDigit xDigit
  | "\U" xDigit xDigit xDigit xDigit xDigit xDigit xDigit xDigit
  | "\" dDigit dDigit dDigit 

(* Literal: String *)
string = '"' { stringChar }  '"' 
stringChar = char - '"'
verbatim-string = '@"' {(char - ('"' | '\"' )) | '""'} '"' |

(* Constant *)
const :=
  byte
  | sbyte
  | int32
  | uint32 
  | int
  | ieee64 
  | char
  | string
  | verbatim-string
  | "false"
  | "true"
  | "()"

(* Operators *)
infixOrPrefixOp := "+" | "-" | "+. " | "-. " | "%" | "&" | "&&"
tildes = "~" | "~" tildes
prefixOp = infixOrPrefixOp | tildes | (! {opChar} - "!=")
dots = "." | "." dots
infixOp = 
  {dots} (
    infixOrPrefixOp  
    | "-" {opChar} 
    | "+" {opChar} 
    | "||" 
    | "<" {opChar} 
    | ">" {opChar} 
    | "="  
    | " |" {opChar} 
    | "&" {opChar} 
    | "^" {opChar} 
    | "*" {opChar} 
    | "/" {opChar} 
    | "%" {opChar} 
    | "!=" )
  | ":=" | "::" | "$" | "?" (*$*)

(* Identifier *)
ident = (letter | "_") {letter | dDigit | specialChar}
letter = 
  "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" 
  | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "X" | "Y" |  "Z" 
  | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" 
  | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "x" | "y" | "z"
specialChar = "_"

long-ident = ident | ident '.' long-ident  (* no space around '.' *)
long-ident-or-op = [long-ident '.'] ident-or-op (* no space around '.' *)
ident-or-op = 
  ident
  | "(" infixOp | prefixOp ")" 
  | "(*)"

(* Keywords *)
ident-keyword =
  "abstract" | "and" | "as" | "assert" | "base" | "begin" | "class" | "default" 
  | "delegate" | "do" | "done" | "downcast" | "downto" | "elif" | "else" | "end" 
  | "exception" | "extern" | "false" | "finally" | "for" | "fun" | "function" 
  | "global" | "if" | "in" | "inherit" | "inline" | "interface" | "internal" 
  | "lazy" | "let" | "match" | "member" | "module" | "mutable" 
  | "namespace" | "new" | "null" | "of" | "open" | "or" | "override" | "private"
  | "public" | "rec" | "return" | "sig" | "static" | "struct" | "then" | "to"
  | "true" | "try" | "type" | "upcast" | "use" | "val" | "void" | "when" 
  | "while" | "with" | "yield"

reserved-ident-keyword = 
  "atomic" | "break" | "checked" | "component" | "const" | "constraint" 
  | "constructor" | "continue" | "eager" | "fixed" | "fori" | "functor" 
  | "include" "measure" | "method" | "mixin" | "object" | "parallel" 
  | "params" | "process" | "protected" | "pure" | "recursive" | "sealed" 
  | "tailcall" | "trait" | "virtual" | "volatile"

reserved-ident-formats = ident-text ( '!' | '#')

(* Symbolic Keywords *)
symbolic-keyword = 
  "let!" | "use!" | "do!" | "yield!" | "return!" | "|" | "->" | "<-" | "." | ":" 
  | "(" | ")" | "[" | "]" | "[<" | ">]" | "[|" | "|]" | "{" | "}" | "'" | "#" 
  | ":?>" | ":?" | ":>" | ".." | "::" | ":=" | ";;" | ";" | "=" | "_" | "?" 
  | "??" | "(*)" | "<@" | "@>" | "<@@" | "@@>"
reserved-symbolic-sequence =  "~" | "'"

(* Comments *)
blockComment = "(*" {codePoint} "*)"
lineComment = "//" {codePoint - newline} newline

(* Expressions *)
expr = 
  | const (* a const value *)
  | "(" expr ")" (* block *)
  | long-ident-or-op (* identifier or operator *)
  | expr '.' long-ident-or-op (* dot lookup expression, no space around '.' *)
  | expr expr (* application *)
  | expr infix-op expr (* infix application *)
  | prefix-op expr (* prefix application *)
  | expr ".[" expr "]" (* index lookup, no space before '.' *)
  | expr ".[" slice-range "]" (* index lookup *)
  | expr "<-" expr (* assingment *)
  | exprTuple (* tuple *)
  | "[" (exprSeq | range-expr) "]" (* list *)
  | "[|" (exprSeq | range-expr) "|]" (* array *)
  | expr ":" type (* type annotation *)
  | expr; expr (* sequence of expressions *)
  | "let" valueDefn "in" expr  (* binding a value or variable *)
  | "let" ["rec"] functionDefn "in" expr (* binding a function or operator *)
  | "if" expr "then" expr {"elif" expr "then" expr} ["else" expr]  (* conditional *)
  | "while" expr "do" expr ["done"] (* while *)

exprTuple = expr | expr "," exprTuple
exprSeq =  expr | expr ";" exprSeq
range-expr = expr ".." expr [".." expr]
slice-range = 
  expr 
  | expr ".."  (* no space between expr and ".." *)
  | ".." expr  (* no space between expr and ".." *)
  | expr ".." expr  (* no space between expr and ".." *)
  | '*'

(* Types *)
type =
  | long-ident (* named such as "int" *)
  | "(" type ")" (* paranthesized *)
  | type "->" type (* function *)
  | typeTuple  (* tuple *)
  | typar (* variable *)
  | type long-ident (* named such as "int list" *)
  | type "[" typeArray "]" (* array, no spaces *)
typeTuple = type | type "*" typeTuple
typeArray = "," | "," typeArray

(* Pattern *)
pat = 
  const (* constant *)
  | "_" (* wildcard *)
  | ident (* named *)
  | pat ":" type (* type constraint *)
  | "(" pat ")" (* paranthesized *)
  | patTuple (* tuple *)
  | patList (* list *)
  | patArray (* array *)

patTuple = pat | pat "," patTuple
patList := "[" [patSeq] "]"
patArray := "[|" [patSeq] "|]"
patSeq = pat | pat ";" patSeq

(* Value binding *)
valueDefn = ["mutable "] pat "=" expr

(* Function binding *)
functionDefn = ident-or-op argument-pats [":" type] "=" expr "
argument-pats = pat | pat argument-pats
\end{lstlisting}

% \begin{lstlisting}[language=ebnf]
% (* Literal *)
% (* Literal: Digit *)
% dDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
% bDigit = "0" | "1"
% oDigit  = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"
% xDigit  =  
%   "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
%   | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" 

% (* Literal: Integer *)
% int = dInt | xInt
% dInt = dDigit {dDigit}
% bitInt = "0" ("b" | "B") bDigit {bDigit}
% octInt = "0" ("o" | "O") oDigit {oDigit}
% hexInt = "0" ("x" | "X") xDigit {xDigit}
% xInt = bitInt | octInt | hexInt

% (* Literal: Float *)
% float = dFloat | sFloat
% dFloat = dInt "." {dDigit}
% sFloat = (dInt | dFloat) ("e" | "E" ) ["+" | "-"] dInt

% (* Literal: Char *)
% char = "'" codePoint | escapeChar "'"
% escapeCodePoint = 
%   "\u" xDigit xDigit xDigit xDigit
%   | "\U" xDigit xDigit xDigit xDigit xDigit xDigit xDigit xDigit
%   | "\" dDigit dDigit dDigit 
% escapeChar = 
%   "\" ("b" | "n" | "r" | "t" | "\" | '"' | "'" | "a" | "f" | "v")
%   | escapeCodePoint

% (* Literal: String *)
% simpleString = '"' { stringChar }  '"'
% stringChar = char - '"'

% (* Identifier *)
% ident = (letter | "_") {letter | dDigit | specialChar}
% letter = "A" | "B" | ... |  "Z" | "a" | "b" | ... | "z"
% specialChar = "_"

% (* Keywords *)
% ident-keyword =
%   "abstract" | "and" | "as" | "assert" | "base" | "begin" | "class" | "default" 
%   | "delegate" | "do" | "done" | "downcast" | "downto" | "elif" | "else" | "end" 
%   | "exception" | "extern" | "false" | "finally" | "for" | "fun" | "function" 
%   | "global" | "if" | "in" | "inherit" | "inline" | "interface" | "internal" 
%   | "lazy" | "let" | "match" | "member" | "module" | "mutable" 
%   | "namespace" | "new" | "null" | "of" | "open" | "or" | "override" | "private"
%   | "public" | "rec" | "return" | "sig" | "static" | "struct" | "then" | "to"
%   | "true" | "try" | "type" | "upcast" | "use" | "val" | "void" | "when" 
%   | "while" | "with" | "yield"

% reserved-ident-keyword = 
%   "atomic" | "break" | "checked" | "component" | "const" | "constraint" 
%   | "constructor" | "continue" | "eager" | "fixed" | "fori" | "functor" 
%   | "include" "measure" | "method" | "mixin" | "object" | "parallel" 
%   | "params" | "process" | "protected" | "pure" | "recursive" | "sealed" 
%   | "tailcall" | "trait" | "virtual" | "volatile"

% reserved-ident-formats = ident-text ( '!' | '#')

% (* Symbolic Keywords *)
% symbolic-keyword = 
%   "let!" | "use!" | "do!" | "yield!" | "return!" | "|" | "->" | "<-" | "." | ":" 
%   | "(" | ")" | "[" | "]" | "[<" | ">]" | "[|" | "|]" | "{" | "}" | "'" | "#" 
%   | ":?>" | ":?" | ":>" | ".." | "::" | ":=" | ";;" | ";" | "=" | "_" | "?" 
%   | "??" | "(*)" | "<@" | "@>" | "<@@" | "@@>"
% reserved-symbolic-sequence =  "~" | "'"

% (* Pattern *)
% pat = const | "_" | ident | pat ":" type | ...

% (* Comments *)
% blockComment = "(*" {codePoint} "*)"
% lineComment = "//" {codePoint - newline} newline

% (* Expressions *)
% expr = 
%   "let" valueDefn "in" expr  (* binding a value or variable *)
%   | "let" functionDefn "in" expr (* binding a function or operator *)
%   | "fun" argumentPats "->" expr (* a function as value *)
%   | expr ":" type (* type annotation *)
%   | "begin" expr "end" (* alternative block *)
%   | expr; expr (* sequence of expressions *)
%   | expr "<-" expr (* assingment *)
%   | "for" pat "in" expr "do" expr ["done"] (* for loop *)
%   | "for" var "=" expr "to" expr "do" expr ["done"] (* simple for  loop *)
%   | "while" expr "do" expr ["done"] (* while *)
%   | "if" expr "then" expr {"elif" expr "then" expr} ["else" expr]  (* conditional *)
%   | "match" expr "with" rules (* pattern matching *)
%   | "function" rules (* matching function *)
%   | "let" rec functionOrValueDefns (* recursive bindings *)
%   | tupleList (* tupples *)
%   | "[" (listOrArrayList | comp-or-range-expr) "]" (* computation list *)
%   | "[|" (listOrArrayList | comp-or-range-expr) "|]" (* computation array *)
%   | "seq" "{" comp-or-range-expr "}" (* computation sequence *)

% (* Rules *) 
% rules = "|" rule | "|" rule rules (* first "|'' is optional' *)
% rule = pat [guard] -> expr
% guard = "when" expr

% (* Lists and ranges *)
% tupleList = expr | expr "," tupleList
% listOrArrayList =  expr | expr ";" listOrArrayList
% range-exp = expr ".." expr [".." expr]

% (* Function helpers *) 
% arg = ident | "(" ident ":" type ")"
% argList = arg | arg argList
% identOrOp = ident | ( operatorName )
% argumentPats = pat | pat argumentPats
% valueDefn = ["mutable "] pat "=" expr
% functionDefn = ident-or-op argList [":" type] "=" expr "
% functionOrValueDefnList = 
%   functionOrValueDefn 
%   | functionOrValueDefn "and" functionOrValueDefnList
% argumentPats = pat | pat argumentPats

% (* Computation Expressions *)
% comp-expr =
%   "let" pat "=" expr "in" comp-expr
%   | "use" pat = expr "in" comp-expr
%   | ("yield" | "yield!") expr
%   | "if" expr "then" comp-expr ["else" comp-expr]
%   | "match" expr "with" comp-rules
%   | "try" comp-expr "with" comp-rules
%   | "try" comp-expr "finally" expr
%   | "while" expr "do" expr ["done"]
%   | "for" ident "=" expr "to" expr "do" comp-expr ["done"]
%   | "for" pat "in" expr-or-range-expr "do" comp-expr ["done"]
%   | comp-expr ";" comp-expr
% short-comp-expr = "for" pat "in" (expr | range-expr) "->" expr
% comp-or-range-expr = comp-expr| short-comp-expr | range-expr
% comp-rule = pat pattern-guardopt "->" comp-expr
% comp-rules = comp-rule | comp-rule '|' comp-rules
% \end{lstlisting}


% \begin{lstlisting}[language=ebnf]
% (* Whitespace *)
% whitespace = ' ' {' '}
% newline = '\n' | '\r' '\n'
% whitespace-or-newline = whitespace | newline

% (* Comments *)
% block-comment-start = "(*" 
% block-comment-end = "*)" 
% end-of-line-comment = "//" {codepoint - '\n' - '\r'}

% (* Conditional compilation *)
% if-directive = "#if" whitespace ident-text else-directive : "#else"
% endif-directive = "#endif"

% (* Identifiers *)
% digit-char = [0-9]
% letter-char = '\Lu' | '\Ll' | '\Lt' | '\Lm' | '\Lo' | '\Nl'
% connecting-char = '\Pc'
% combining-char = '\Mn' | '\Mc' 
% formatting-char = '\Cf'
% ident-start-char = letter-char | '_'
% ident-char = 
%   letter-char 
%   | digit-char 
%   | connecting-char 
%   | combining-char 
%   | formatting-char 
%   | "'" 
%   | '_'
% ident-text = ident-start-char {ident-char}
% ident-char =   ["'"] (codepoint  - "'" - '\n' - '\r' - '\t') (* This rule is weird! Replace back quote with regular quote. What is meant by it? *)
% ident = ident-text

% (* Long identifiers *)
% long-ident = ident ['.' long-ident]
% long-ident-or-op = long-ident '.' ident-or-op | ident-or-op

% (* Keywords *)
% ident-keyword =
%   "abstract" | "and" | "as" | "assert" | "base" | "begin" | "class" | "default" | "delegate" | "do" | "done" | "downcast" | "downto" | "elif" | "else" | "end" | "exception" | "extern" | "false" | "finally" | "for" | "fun" | "function" | "global" | "if" | "in" | "inherit" | "inline" | "interface" | "internal" | "lazy" | "let" | "match" | "member" | "module" | "mutable" | "namespace" | "new" | "null" | "of" | "open" | "or" | "override" | "private" | "public" | "rec" | "return" | "sig" | "static" | "struct" | "then" | "to" | "true" | "try" | "type" | "upcast" | "use" | "val" | "void" | "when" | "while" | "with" | "yield"

% reserved-ident-keyword = "atomic" | "break" | "checked" | "component" | "const" | "constraint" | "constructor" | "continue" | "eager" | "fixed" | "fori" | "functor" | "include" "measure" | "method" | "mixin" | "object" | "parallel" | "params" | "process" | "protected" | "pure" | "recursive" | "sealed" | "tailcall" | "trait" | "virtual" | "volatile"

% reserved-ident-formats = ident-text ( '!' | '#')

% (* Symbolic Keywords *)
% symbolic-keyword = "let!" | "use!" | "do!" | "yield!" | "return!" | "|" | "->" | "<-" | "." | ":" | "(" | ")" | "[" | "]" | "[<" | ">]" | "[|" | "|]" | "{" | "}" | "'" | "#" | ":?>" | ":?" | ":>" | ".." | "::" | ":=" | ";;" | ";" | "=" | "_" | "?" | "??" | "(*)" | "<@" | "@>" | "<@@" | "@@>"
% reserved-symbolic-sequence =  "~" | "'"

% (* Strings and Characters *)
% escape-codes = '"' | '\' | "'" | 'n' | 't' | 'b' | 'r'
% escape-char = '\' escape-codes
% non-escape-chars : '\' (codepoint - escape-codes)
% simple-char-char : codepoint - ('\n' | '\t' | '\r' | '\b' | "'" '\' '"'

% ....
% \end{lstlisting}

\begin{table}
  \centering
  \begin{tabularx}{\linewidth}{|>{\hsize=1\hsize\raggedright\arraybackslash}X|>{\hsize=.5\hsize}X|>{\hsize=1.5\hsize}X|}
    \hline
    Operator & Associativity & Description\\
    \hline
    \lstinline[language=ebnf]|ident "<" types ">"| & Left & High-precedence type application\\
    \hline
    \lstinline[language=ebnf]|ident "(" expr ")"| & Left & High-predence application\\
    \hline
    \lstinline[language=ebnf]|"."| & Left & \\
    \hline
    \lstinline[language=ebnf]|prefixOp| & Left & All prefix operators\\
    \hline
    \lstinline[language=ebnf]|"|" rule| & Left & Pattern matching rule\\
    \hline
    \mbox{\lstinline[language=ebnf]|ident expr|,} \mbox{\lstinline[language=ebnf]|"lazy'' expr|,} \mbox{\lstinline[language=ebnf]|"assert'' epxr|} & Left & \\
    \hline
    \lstinline[language=ebnf]|"**" {opChar}| & Right & Exponent like\\
    \hline
    \mbox{\lstinline[language=ebnf]|"*"  {opChar}|,} \mbox{\lstinline[language=ebnf]|"/"  {opChar}|,} \mbox{\lstinline[language=ebnf]|"\%"  {opChar}|} & Left & Infix multiplication like\\
     \hline
    \mbox{\lstinline[language=ebnf]|"-"  {opChar}|,} \mbox{\lstinline[language=ebnf]|"+"  {opChar}|} & Left & Infix addition like\\
     \hline
     \lstinline[language=ebnf]|":?''| & None & \\
     \hline
     \lstinline[language=ebnf]|"::''| & Right & \\
     \hline
     \lstinline[language=ebnf]|"^''  {opChar}| & Right & \\
     \hline
    \mbox{\lstinline[language=ebnf]|"!="  {opChar}|,} \mbox{\lstinline[language=ebnf]|"<"  {opChar}|,} \mbox{\lstinline[language=ebnf]|">"  {opChar}|,} \mbox{\lstinline[language=ebnf]|"="|,} \mbox{\lstinline[language=ebnf]!"|"  {opChar}!,} \mbox{\lstinline[language=ebnf]|"\&"  {opChar}|,} \mbox{\lstinline[language=ebnf]|"\$"  {opChar}|} & Left & Infix addition like\\
     \hline
    \mbox{\lstinline[language=ebnf]|":>"|,} \mbox{\lstinline[language=ebnf]|":?>"|} & Right & \\
     \hline
    \mbox{\lstinline[language=ebnf]|"\&"|,} \mbox{\lstinline[language=ebnf]|"\&\&"|} & Left & Boolean and like\\
     \hline
    \mbox{\lstinline[language=ebnf]|"or"|,} \mbox{\lstinline[language=ebnf]!"||"!} & Left & Boolean or like\\
     \hline
     \lstinline[language=ebnf]|","| & None & \\
     \hline
     \lstinline[language=ebnf]|":="| & Right & \\
     \hline
     \lstinline[language=ebnf]|"->"| & Right & \\
     \hline
    \lstinline[language=ebnf]|"if"| & None & \\
     \hline
    \mbox{\lstinline[language=ebnf]|"function"|,} \mbox{\lstinline[language=ebnf]|"fun"|,} \mbox{\lstinline[language=ebnf]|"match"|,} \mbox{\lstinline[language=ebnf]|"try"|}& None & \\
     \hline
     \lstinline[language=ebnf]|"let"| & None & \\
     \hline
     \lstinline[language=ebnf]|";"| & Right & \\
     \hline
     \lstinline[language=ebnf]!"|"! & Left & \\
     \hline
     \lstinline[language=ebnf]|"when"| & Right & \\
     \hline
     \lstinline[language=ebnf]|"as"| & Right & \\
     \hline
  \end{tabularx}
  \caption{Precedence and associativity of operators. Operators in the same row has same precedence. See \Cref{list:infixOrPrefixOperators} for the definition of \lstinline!prefixOp!}
  \label{tab:operatorPrecedence}
\end{table}

\jon{Somewhere I should possibly talk about Lightweight Syntax, Spec-4.0 Chapter 15.1}
\end{document}
%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
