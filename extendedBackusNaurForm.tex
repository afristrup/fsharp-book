\documentclass[fsharpnotes.tex]{subfiles}
\graphicspath{ {./figures/} }

\begin{document}
\chapter{A brief introduction to Extended Backus-Naur Form}
\label{sec:ebnf}
\idx{Extended Backus-Naur Form} (\idx{EBNF}) is a language to specify programming languages in. The name is a tribute to John Backus who used it to describe the syntax of ALGOL58 and Peter Nauer for his work on ALGOL 60.

An EBNF consists of \idx{terminal symbols} and \idx{production rules}. Examples of typical terminal symbol are characters, numbers, punctuation marks, and whitespaces, e.g.,
\begin{lstlisting}[language=ebnf]
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
\end{lstlisting}
A production rule specifies a method of combining other production rules and terminal symbols, e.g.,
\begin{lstlisting}[language=ebnf]
number = digit { digit };
\end{lstlisting}
A proposed standard for ebnf (proposal ISO/IEC 14977, \url{http://www.cl.cam.ac.uk/~mgk25/iso-14977.pdf}) is,
\begin{description}
\item '\lstinline[language=ebnf]|=|' definition, e.g., 
  \begin{lstlisting}[language=ebnf]
zero = "0";
  \end{lstlisting}
  here \lstinline[language=ebnf]|zero| is the terminal symbol \lstinline[language=ebnf]|0|.
\item '\lstinline[language=ebnf]|,|' concatenation, e.g.,
  \begin{lstlisting}[language=ebnf]
one = "1";
eleven = one, one;
  \end{lstlisting}
  here \lstinline[language=ebnf]|eleven| is the terminal symbol \lstinline[language=ebnf]|11|.
\item '\lstinline[language=ebnf]|;|' termination of line
\item '\lstinline[language=ebnf]!|!' alternative options, e.g.,
  \begin{lstlisting}[language=ebnf]
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
  \end{lstlisting}
  here \lstinline[language=ebnf]|digit| is the single character terminal symbol, such as \lstinline[language=ebnf]|3|.
\item '\lstinline[language=ebnf]|[ ... ]|' optional, e.g.,
  \begin{lstlisting}[language=ebnf]
zero = "0";
nonZeroDigit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
nonZero = [ zero ], nonZeroDigit;
  \end{lstlisting}
  here \lstinline[language=ebnf]|nonZero| is a non-zero digit possibly preceded by zero, such as \lstinline[language=ebnf]|02|.
\item '\lstinline[language=ebnf]|{ ... }|' repetition zero or more times, e.g., 
  \begin{lstlisting}[language=ebnf]
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
number = digit, { digit };
  \end{lstlisting}
  here \lstinline[language=ebnf]|number| is a word consisting of 1 or more digits, such as \lstinline[language=ebnf]|12|.
\item '\lstinline[language=ebnf]|( ... )|' grouping, e.g.,
  \begin{lstlisting}[language=ebnf]
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
signedNumber = ( "+" | "-" ) digit, { digit };
  \end{lstlisting}
  here \lstinline[language=ebnf]|signedNumber| is a number with a mandatory sign, such as \lstinline[language=ebnf]|+5| and \lstinline[language=ebnf]|-3|.
\item '\lstinline[language=ebnf]|" ... "|' a terminal string, e.g.,
  \begin{lstlisting}[language=ebnf]
string = "abc"';
  \end{lstlisting}
\item "\lstinline[language=ebnf]|' ... '|" a terminal string, e.g.,
  \begin{lstlisting}[language=ebnf]
string = 'abc';
  \end{lstlisting}
\item '\lstinline[language=ebnf]|(* ... *)|' a comment (* ... *) 
  \begin{lstlisting}[language=ebnf]
(* a binary digit *) digit = "0" | "1"; (* from this all numbers may be constructed *)
  \end{lstlisting}
  Everything inside the comments are not part of the formal definition.
\item '\lstinline[language=ebnf]|? ... ?|' special sequence, a notation reserved for future extensions of EBNF.
  \begin{lstlisting}[language=ebnf]
codepoint = ?Any unicode codepoint?;
  \end{lstlisting}
\item '\lstinline[language=ebnf]|-|' exception, e.g.,
  \begin{lstlisting}[language=ebnf]
letter = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" 
  | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" 
  | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z";
vowel = "A" | "E" | "I" | "O" | "U"; 
consonant = letter - vowel;
  \end{lstlisting}
  here \lstinline[language=ebnf]|consonant| are all letters except vowels.
\end{description}

Rules for rewriting EBNF are:
\begin{center}
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabularx}{\linewidth}{|l|X|}
    \hline
    \rowcolor{headerRowColor} Rule & Description\\
    \hline
    \lstinline[language=ebnf]{s | t} $\leftrightarrow$ \lstinline[language=ebnf]{t | s} & \lstinline[language=ebnf]{|} is commutative \\
    \hline
    \lstinline[language=ebnf]{r | (s | t)} $\leftrightarrow$ \lstinline[language=ebnf]{(r | s) | t} $\leftrightarrow$ \lstinline[language=ebnf]{r | s | t} & \lstinline[language=ebnf]{|} is associative \\
    \hline
    \lstinline[language=ebnf]{(r, s) t} $\leftrightarrow$ \lstinline[language=ebnf]{r (s, t)} $\leftrightarrow$ \lstinline[language=ebnf]{r, s, t} & concatenation is associative \\
    \hline
    \lstinline[language=ebnf]{r, (s | t)} $\leftrightarrow$ \lstinline[language=ebnf]{r, t | r, s} & concatenation is distributive over \lstinline[language=ebnf]{|}\\
    \lstinline[language=ebnf]{(r | s), t} $\leftrightarrow$ \lstinline[language=ebnf]{r, t | r, t} &\\
    \hline
    \lstinline[language=ebnf]{[s | t]} $\leftrightarrow$ \lstinline[language=ebnf]{[t] | [s]} &\\
    \hline
    \lstinline[language=ebnf]{[[s]]} $\leftrightarrow$ \lstinline[language=ebnf]{[s]} & \lstinline[language=ebnf]{[]} is idempotent \\
    \hline
    \lstinline[language=ebnf]{\{\{s\}\}} $\leftrightarrow$ \lstinline[language=ebnf]{\{s\}} & \lstinline[language=ebnf]{\{\}} is idempotent \\
    \hline
  \end{tabularx}
\end{center}
where \lstinline[language=ebnf]{r}, \lstinline[language=ebnf]{s}, and \lstinline[language=ebnf]{t} are production rules or terminals. Precedence for the EBNF symbols are,
\begin{center}
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabular}{|l|l|}
    \hline
    \rowcolor{headerRowColor} Symbol & Description\\
    \hline
    \lstinline[language=ebnf]![]!, \ldots & Bracket and quotation mark pairs\\
    \hline
    \lstinline[language=ebnf]!-! & except\\
    \hline
    \lstinline[language=ebnf]!,! & concatenate\\
    \hline
    \lstinline[language=ebnf]!|! & option\\
    \hline
    \lstinline[language=ebnf]!=! & define\\
    \hline
    \lstinline[language=ebnf]!;! & terminator\\
    \hline
  \end{tabular}
\end{center}
in order of precedence, such that bracket and quotation mark pairs has higher precedence than \lstinline[language=ebnf]{-}. 
%These precedence rules are overridden by bracket pairs, such as \lstinline[language=ebnf]{' '}, \lstinline[language=ebnf]{" "}, \lstinline[language=ebnf]{(* *)}, \lstinline[language=ebnf]{( )}, \lstinline[language=ebnf]{[ ]}, \lstinline[language=ebnf]!{ }!, \lstinline{? ?}.

The proposal allows for identifies that includes space, but often a reduced form is used, where identifiers are single words, in which case the concatenation symbol \lstinline[language=ebnf]|,| is replaced by a space. Likewise, the termination symbol \lstinline[language=ebnf]|;| is often replaced with the new-line character, and if long lines must be broken, then indentation is used to signify continuation. In this relaxed EBNF, the EBNF syntax itself can be expressed in EBNF as,
\begin{lstlisting}[language=ebnf]
letter = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" 
  | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" 
  | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
  | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" 
  | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" 
  | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z";
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
symbol = "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">"
  | "?" | "'" | '"' | "=" | "|" | "." | "," | ";";
underscore = "_";
space = " ";
newline = ?a newline character?;
identifier = letter  { letter | digit | underscore };
character = letter | digit | symbol | underscore; 
string = character  { character };
terminal = "'"  string  "'" | '"'  string  '"';
rhs = identifier
  | terminal
  | "["  rhs  "]"
  | "{"  rhs  "}"
  | "("  rhs  ")"
  | "?"  string  "?"
  | rhs  "|"  rhs
  | rhs  ","  rhs
  | rhs  space  rhs; (*relaxed ebnf*)
rule = identifier  "="  rhs ";"
  | identifier  "="  rhs newline; (*relaxed ebnf*)
grammar = rule { rule };
\end{lstlisting}
Here the comments demonstrate, the relaxed modification. Newline does not have an explicit representation in EBNF, which is why we use \lstinline[language=ebnf]{? ?} brackets
\end{document}
%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
