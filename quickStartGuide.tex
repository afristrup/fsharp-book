\documentclass[fsharpnotes.tex]{subfiles}

\begin{document}
\chapter{Quick-start Guide}
Programming is the art of solving problems by writing a program to be executed by a computer. For example, to solve the following problem,
%
\begin{problem}
  What is the sum of 357 and 864?
  \label{probl:sumInteger}
\end{problem}
%
we have written the program shown in \Cref{quickStartSum}.
%
\fs{quickStartSum}{A script to add 2 numbers and print the result to the console.}
%
In the box the above, we see our program was saved as a script in a file called \lstinline[language=console]{quickStartSum.fsx}, and in the console we executed the program by typing the command \lstinline[language=console]|fsharpc --nologo quickStartSum.fsx && mono quickStartSum.exe|. The result is then printed in the console to be \lstinline{1221}. Here, as in the rest of this book, we have used the optional flag \lstinline[language=console]{--nologo}, which informs \lstinline|fsharpc| not to print information about its version etc., thus making the output shorter. The \lstinline[language=console]{&&} notation tells the console to first run the command on the left, and if that did not report any errors, then run the command on the right. This could also have been performed as two separate commands to the console, and throughout this book we will use the above shorthand when convenient.

To solve the problem, we made program consisting of several lines, where each line was an \idx[expression]{expressions}. The first expression, \lstinline|let a = 357|, in line~\ref{quickStartSumA} used the \idx[let@\lstinline{let}]{\keyword{let}} \idx{keyword} to \idx[binding]{bind} the value 357 to the name \lstinline|a|. This is called a \idx{let-binding} and makes the name synonymous with the value. Another notable point is that F\# identifies 357 as an \idx{integer number}, which is F\#'s preferred number type, since computations on integers are very efficient, and since integers are very easy to communicate to other programs. In line~\ref{quickStartSumB} we bound the value 864 to the name \lstinline|b|, and to the name \lstinline|c| we bound the result of evaluating the sum \lstinline|a + b| in line~\ref{quickStartSumC}. Line~\ref{quickStartSumPrintfn} is a \idx{do-binding}, as noted by the keyword \idx[do@\lstinline{do}]{\keyword{do}}. The \lstinline{do}-bindings are also sometimes called \idx[statement]{statements}, and the \keyword{do} keyword is optional in F\#. Here the value of \lstinline|c| was printed to the console followed by a newline
%(LF possibly preceded by CR, see Appendix~\ref{sec:ascii})
with the \idx[printfn@\lstinline{printfn}]{\lstinline{printfn}} \idx{function}. A function in F\# is an entity that takes zero or more arguments and returns a value. The function \lstinline|printfn| is very special, since it can take any number of arguments and returns the special value \idx[{()}@\lstinline{()}]{\lexeme{()}} which has type \idx[unit@\lstinline{unit}]{\keyword{unit}}. The \keyword{do} tells F\# to ignore this value. Here \lstinline{printfn} has been used with 2 arguments: \lstinline|"%A"| %
and \lstinline|c|. Notice that in contrast to many other languages, F\# does not use parentheses to frame the list of arguments, nor does it use commas to separate them. In general, the \lstinline|printfn| function always has 1 or more arguments, and the first is a \idx{format string}. A \idx{string} is a sequence of characters starting and ending with double quotation marks. E.g., \lstinline|let s = "this is a string of characters"| binds the string \lstinline|"this is..."| to the name \lstinline|s|. For the \lstinline|printfn| function, the format string may be any string, but if it contains format character sequences, such as \lstinline|%A|,
 then format character sequence are replaced by the arguments to \lstinline{printfn} which follows the format string. The format string must match the value \idx{type}, that is, here \lstinline|c| is of type integer, whereas the format string \lstinline|%A| %
matches many types.

Types are a central concept in F\#. In the script \ref{quickStartSum} we bound values of integer type to names. There are several different integer types in F\#, here we used the one called \lstinline|int|. The values were not \idx[type declaration]{declared} to have these types, instead the types were \idx[type inference]{inferred} by F\#. Typing these bindings line by line in an interactive session, we see the inferred types as shown in \Cref{typeInference}.
%
\fsOutput{typeInference}{Inferred types are given as part of the response from the interpreter.}
%
The interactive session displays the type using the \idx[val@\lstinline{val}]{\keyword{val}} keyword followed by the name used in the binding, its type, and its value. Since the value is also responded, the last \lstinline|printfn| statement is superfluous. However, \advice{it is ill-advised to design programs to be run in an interactive session, since the scripts need to be manually copied every time it is to be run, and since the starting state may be unclear.} Notice that \lstinline{printfn} is automatically bound to the name \idx[it@\lstinline{it}]{\lstinline{it}} of type \keyword{unit} and value \idx[{()}@\lstinline{()}]{\lexeme{()}}. F\# insists on binding all statements to values, and in lack of an explicit name, it will use \lstinline{it}. Rumor has it that \lstinline{it} is an abbreviation for "irrelevant".

The following problem,
%
\begin{problem}
  What is the sum of 357.6 and 863.4?
\end{problem}
%
uses \idx{decimal point} numbers instead of integers. These numbers are called \idx[floating point number]{floating point numbers}, and their internal representation is quite different to integer numbers used previously. Likewise, algorithms used to perform arithmetic are quite different from integers. Now the program would look like \Cref{quickStartSumFloat}.
%
\fs{quickStartSumFloat}{Floating point types and arithmetic.}
%
On the surface, this could appear as an almost negligible change, but the set of integers and the set of real numbers (floats) require quite different representations in order to be effective on a computer, and as a consequence, the implementation of their operations, such as addition, are very different. Thus, although the response is an integer, it has type \lstinline|float| which is indicated by \lstinline|1221.0| and which is not the same as \lstinline|1221|. F\# is very picky about types, and generally does not allow types to be mixed, as demonstrated in the interactive session in \Cref{typeInferenceError}.
%
\fsOutput{typeInferenceError}{Mixing types is often not allowed.}
%
We see that binding a name to a number without a decimal point is inferred to be an integer, while when binding to a number with a decimal point the type is inferred to be a float, and that our attempt of adding an integer and floating point value gives an error. The \idx{error message} contains much information. First, it states that the error is in \lstinline[language=console]{stdin(4,13)}, which means that the error was found on standard-input at line 4 and column 13. Since the program was executed using \lstinline[language=console]{fsharpi quickStartSumFloat.fsx}, here standard input means the file \lstinline[language=console]{quickStartSumFloat.fsx} shown in \Cref{quickStartSumFloat}. The corresponding line and column are also shown in \Cref{typeInferenceError}. After the file, line, and column number, F\# informs us of the error number and a description of the error. Error numbers are an underdeveloped feature in Mono and should be ignored. However, the verbal description often contains useful information for \idx{debugging}. In the example we are informed that there is a type mismatch in the expression, i.e., since \lstinline{a} is an integer, F\# expected \lstinline{b} to be one too. Debugging is the process of solving errors in programs, and here we can solve the error by either making \lstinline{a} into a float or \lstinline{b} into an int. The right solution depends on the application.

F\# is a functional first programming language, and one implication of this is that names have a \idx{lexical scope}. A scope is the lines in a program where a binding is valid, and lexical scope means that to find the value of a name, F\# looks for the value in the above lines. Furthermore, at the outermost level, rebinding is not allowed. If attempted, then F\# will return an error as shown in \Cref{quickStartRebindError}.
%
\fs{quickStartRebindError}{A name cannot be rebound.}
%
However, if the same code is executed in an interactive session, then rebinding does not cause an error, as shown in \Cref{blocksNNames}.
%
\fsOutput{blocksNNames}{Names may be reused when separated by the lexeme \lexeme{;;}.}
%
The difference is that the \idx[{;;}@\lstinline{;;}]{\lexeme{;;}} \idx{lexeme} is used to specify the end of a \idx{script-fragment}.\spec{Language change: Spec 4.0 p. 15.1 talks about blocks instead of scopes.} A lexeme is a letter or word, which F\# considers as an atomic unit. Script-fragments may be defined both in scripts and in interactive mode, and rebinding is not allowed at the outermost level in script-fragments. Even with the \lexeme{;;} lexeme, rebinding is not allowed in compile-mode. In general, \advice{avoid rebinding of names.}

In F\#, \idx[function]{functions} are also values, and we may define a function \lstinline|sum| as part of the solution to the above program, as shown in \Cref{quickStartSumFct}.
%
\fs{quickStartSumFct}{A script to add 2 numbers using a user-defined function.}
%
Functions are useful to \idx[encapsulation]{encapsulate} code, such that we can focus on the transformation of data by a function while ignoring the details on how this is done. Functions are also useful for code reuse, i.e., instead of repeating a piece of code in several places, such code can be encapsulated in a function and replaced with function calls. This makes debugging and maintenance considerably simpler. Entering the function into an interactive session will illustrate the inferred type the function \lstinline|sum| has: \lstinline{val sum : x:int -> y:int -> int}. The \lexeme{->} is the mapping operator in the sense that functions are mappings between sets. The type of the function \lstinline{sum}, should be read as \lstinline{val sum : x:int -> (y:int -> int)}, that is, \lstinline|sum| takes an integer and returns a function, which takes an integer and returns an integer. This is an example of a higher-order function. 

Type inference in F\# may cause problems, since the type of a function is inferred based on the context in which it is defined. E.g., in an interactive session, defining the sum in one scope on a single line will default the types to integers, F\#'s favorite type. Thus, if the next script-fragment uses the function with floats, then we will get an error message as shown in \Cref{typesNBlockInferenceError}.
%
\fsOutput{typesNBlockInferenceError}{Types are inferred in blocks, and F\# tends to prefer integers.}
%
A remedy is to define the function in the same script-fragment as it is used, such as shown in \Cref{typesNBlockInference}.
%
\fsOutput{typesNBlockInference}{Type inference is per script-fragment.}
%
Alternatively, the types may be explicitly stated as shown in \Cref{typesAnnotation}.
%
\fsOutput{typesAnnotation}{Function argument and return types may be stated explicitly.}
%
The function \lstinline{sum} has two arguments and a return type, and in \Cref{typesAnnotation} we have specified all three. This is done using the \lexeme{:} lexeme, and to resolve confusion, we must use parentheses around the arguments, such as \lstinline{(y : float)}, otherwise F\# would not be able to understand whether the type annotation was for the argument or the return value. Often it is sufficient to specify just some of the types, since type inference will enforce the remaining types. E.g., in this example, the \lexeme{+} operator is defined for identical types, so specifying the return value of \lstinline{sum} to be a float implies that the result of the \lexeme{+} operator is a float, and therefore that its arguments must be floats, and finally then that the arguments for \lstinline{sum} must be floats. However, in this book we advocate the following advice: \advice{specify types unless explicitly working with generic functions.}

In this chapter, we have scratched the surface of learning how to program by concentrating on a number of key programming concepts and how they are expressed in the F\# language. In the following chapters, we will expand the description of F\# with features used in all programming approaches.
\end{document}
%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:

