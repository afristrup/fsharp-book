\chapter{Quick-start guide}
Programming is the art of solving problems by writing a program to be executed by a computer. For example, to solve the following problem,
\begin{quote}
  What is the sum of 357 and 864?
\end{quote}
we could write the following program in F\#,
%
\fs{quickStartSum}{A script to add 2 numbers and print the result to the console.}
%
In box the above, we see our program was saved as a script in a file called \texttt{quickStartSum.fsx}, and in the console we executed the program by typing the command \lstinline|fsharpi quickStartSum.fsx|. The result is then printed in the console to be \texttt{1221}.

To solve the program we made program consisting of several lines, where each line was a \idx{statement}. The first statement \lstinline|let a = 357| used the \lstinline|let| \idx{keyword} to bind the value 357 to the name \lstinline|a|. Likewise, we bound the value 864 to the name \lstinline|b|, but to the name \lstinline|c| we bound the result of evaluating the \idx{expression} \lstinline|a + b|. That is, first the value \lstinline|a + b| was calculated by substituting the names of \lstinline|a| and \lstinline|b| with their values to give the expression, \lstinline|357 + 864|, then this expression was evaluated by adding the values to give, \lstinline|1221|, and this value was finally bound to the name \lstinline|c|. The last line printed the value of \lstinline|c| to the console followed by a LF (line feed, see Appendix~\ref{sec:ascii}) with the \lstinline|printfn| function. Here \lstinline|printfn| is a function of 2 arguments: \lstinline|"%A"| and \lstinline|c|. Notice, that in contrast to many other languages, F\# does not use parentheses to frame the list of arguments, nor does it use commas to separate them. In general, the \lstinline|printfn| function always has 1 or more arguments, and the first is a \idx{format string}. A \idx{string} is a sequence of characters starting and ending with double quotation marks. E.g.,  \lstinline|let s = "this is a string of characters"| binds the string \lstinline|"this is..."| to the name \lstinline|s|. For the \lstinline|printfn| function, the format string may be any string, but if it contains format character sequences, such as \lstinline|%A|, then the values following the format string are substituted. The format string must match the value \idx{type}, that is, here \lstinline|c| is of type integer, whereas the format string \lstinline|%A| matches any type.

Types are a central concept in F\#. The language contains a number of built-in types, and it designed such that it is easy to define new types. The simplest types are called \idx{primitive types}, and a table of some of the most commonly used primitive types are shown in Table~\ref{tab:primitiveTypes}.
\begin{table}
  \centering
  \begin{tabularx}{0.75\textwidth}{|l|X|}
    \hline
    Type & Description\\
    \hline
    bool & Boolean values are true and false.\\
    int & Integer values from -2,147,483,648 to 2,147,483,647.\\
    float, double & 64-bit IEEE 754 floating point value from $-\infty$ to $\infty$, see Appendix~\ref{sec:floatingPoint}.\\
    char & Unicode character values, see Appendix~\ref{sec:characterSets}.\\
    string & Unicode sequence of characters.\\
    unit & No value denoted \texttt{()}.\\
    \hline
  \end{tabularx}
  \caption{Some primitive types.}
  \label{tab:primitiveTypes}
\end{table}
\begin{comment}
  \begin{table}
    \centering
    \begin{tabularx}{0.75\textwidth}{|l|X|}
      \hline
      Type & Description\\
      \hline
      decimal &A floating point data type that has at least 28 significant digits.\\
      byte &Integer values from 0 to 255.\\
      sbyte &Integer values from -128 to 127.\\
      int16 &Integer values from -32768 to 32767.\\
      uint16 &Integer values from 0 to 65535.\\
      uint32 &Integer values from 0 to 4,294,967,295.\\
      int64 &Integer values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.\\
      uint64 &Integer values from 0 to 18,446,744,073,709,551,615.\\
      nativeint &A native pointer as a signed integer.\\
      unativeint &A native pointer as an unsigned integer.\\
      void &Indicates no type or value.\\
      float32, single &A 32-bit floating point type.\\
      \hline
    \end{tabularx}
    \caption{Other primitive types.}
    \label{tab:otherPrimitiveTypes}
  \end{table}
\end{comment}
In the script \ref{quickStartSum} we bound values of types \lstinline|int| and \lstinline|string| to names. The values were not declared to have these types, instead the types were inferred by F\#. Had we typed these statements line by line in an interactive session, then we would have seen the inferred types:
\begin{lstlisting}[language=console]
$ fsharpi

F# Interactive for F# 4.0 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

> let a = 357;;         

val a : int = 357

> let b = 864;;

val b : int = 864

> let c = a + b;;

val c : int = 1221

> printfn "%A" c;;
1221
val it : unit = ()

> #quit;;
\end{lstlisting}
The an interactive session displays the type using the \lstinline|val| keyword. Using Extended Backus-Naur form (see Appendix~\ref{sec:ebnf}), the response from the the interpreter follows the syntax: 
\begin{lstlisting}[language=ebnf]
  "val" name ":" type "=" value
\end{lstlisting}
Since the value is also responded, then the last \lstinline|printfn| statement is superfluous. However, \advice{it is ill adviced to design programs to be run in an interactive session, since the scripts needs to be manually copied every time it is to be run, and since the starting state may be unclear.}

Were we to solve a slightly different problem,
\begin{quote}
  What is the sum of 357.6 and 863.4?
\end{quote}
then we would have to use floating point arithmatic instead of integers. A subtle point here is that the above problem is stated in using base 10 numbers, while almost all computers perform their calculations in base 2 numbers. E.g., the number 357.6 in base 10 can be considere the sum,
\begin{equation}
  357.6 = 3\cdot 10^2 + 5\cdot 10^1 + 7\cdot 10^0 + 6\cdot 10^{-1},
\end{equation}
and in general any base 10 number, also known as \idx{decimal numbers}, has the representation $a_n a_{n-1} a_{n-2} \dots a_{-m}$ for $n+1$ digits to the left and $m$ digits to the right of the period, and where $0 \leq a_i \leq 9$, and which translate to the equation
\begin{equation}
  v = \sum_{i=-m}^{n} a_i10^i.
\end{equation}
Base 2 numbers, also known as \idx{binary numbers}, has the general form
\begin{equation}
  v = \sum_{i=-p}^{q} b_i2^i,
\end{equation}
where $0 \leq b_i \leq 1$ are binary digits, and where $357.6_{10} = 101100101.\overline{10011}_2$, using subscript to denote base. and where the bar notation means that the digits are repeated infinitely many times. I.e.,
\begin{equation}
  357.6 = 1\cdot 10^8  + 1\cdot 10^6 + 1\cdot 10^5 + 1\cdot 10^2 + 1\cdot 10^0 + 1\cdot 10^{-1} + 1\cdot 10^{-4} + 1\cdot 10^{-5}\dots 
\end{equation}
where alle terms with coefficient 0 have been removed for brevity. The example illustrates that while the number $357.6$ is short to write in decimal, it has infinte number of digits in binary, and since any computer only has finite memory, then we must use an approximation. Floating point numbers is a popular approximation, whose type is \lstinline|float| which is synonymous with \lstinline|double| in F\#, and which implements the IEEE 754 floating point standard for doubles. Thus the program looks like,
\fs{quickStartSumFloat}{Floating point types and arithmatic.}
Note that although the response is an integer, it has type \lstinline|float| which is indicated by \lstinline|1221.0| instead of \lstinline|1221|.

F\# is very picky about types, and generally does not allow types to be mixed. E.g., in an interactive session,
\begin{lstlisting}[language=console]
$ fsharpi

F# Interactive for F# 4.0 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

> let a = 357;;

val a : int = 357

> let b = 863.4;;

val b : float = 863.4

> let c = a + b;;

  let c = a + b;;
  ------------^

/Users/sporring/Desktop/fsharpNotes/stdin(3,13): error FS0001: The type 'float' does not match the type 'int'
> #quit;;
\end{lstlisting}
we see that binding a name to a number without a decimal point is inferred to be integer, while when binding to a number with a decimal point, then the type is inferred to be a float, and when trying to add values of integer and floating point, then we get an error. The result is floating point, so to perform the sum, we must convert the integer to floating point, and we could either write the floating point equivalent to the integer \lstinline|357|,
\begin{quote}
  \lstinline|let a = 357.0|
\end{quote}
or \idx{type cast} the integer to the float type as
\begin{quote}
  \lstinline|let a = float 357|
\end{quote}
Type casting is a potential destructive operation, e.g., type casting a float to int removes the part after the decimal point without rounding,
\fs{quickStartDownCast}{Type casting is potentially a destructive action, here the fractional part is removed.}
The type casting in the example is sometimes called \idx{down casting}, since the floating time is casted to a lesser type, in the sense that floating point numbers can represents more numbers than integers.

F\# is a functional first programming language, and one implication is that names are constant and cannot be changed. If attempted, then F\# will return an error as, e.g.,
%
\fs{quickStartRebindError}{A name cannot be rebound.}
%
However, if the same was performed in an interactive session,
\begin{lstlisting}[language=console]
$ fsharpi

F# Interactive for F# 4.0 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

> let a = 357;;

val a : int = 357

> let a = 864;;

val a : int = 864

> #quit;;
\end{lstlisting}
then apparently rebinding is legal. The difference is that the \lstinline|;;| token defines a new nested \idx{scope}. A scope is an area in a program, where a binding is valid. Scopes can be nested, and in F\# a binding may reuse names in a nested scope, in which case the previous value is overshadowed. I.e., attempting the same without \lstinline|;;| between the two let statements results in an error, e.g.,
\begin{lstlisting}[language=console]
$ fsharpi

F# Interactive for F# 4.0 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

> let a = 357
- let a = 864;;

  let a = 864;;
  ----^

/Users/sporring/Desktop/fsharpNotes/stdin(2,5): error FS0037: Duplicate definition of value 'a'
> #quit;;
\end{lstlisting}
This is yet another reason why the interactive session should be avoided except for back-of-an-envelope experiment.  Scopes can as nested squares as shown in Figure~\ref{fig:scope}.
\begin{figure}
  \centering
  \subfigure[Illegal]{
    \fbox{
      \begin{minipage}{0.2\linewidth}
        \lstinline|let a = 357|\\
        \lstinline|let a = 864;;|
      \end{minipage}
    }
  }
  \subfigure[Legal]{
    \fbox{
      \begin{minipage}{0.2\linewidth}
      \lstinline|let a = 357;;|\\
      \fbox{
      \begin{minipage}{0.85\linewidth}
        \lstinline|let a = 864;;|
      \end{minipage}
    }
  \end{minipage}
}
  }
  \caption{Binding of the the same name in the same scope is illegal in F\# 2, but legal in a different scopes. In (a) the two bindings are in the same scope, which is illegal, while in (b) the bindings are in separate scopes by the extra \lstinline|;;| token, which is legal.}
  \label{fig:scope}
\end{figure}

In F\# functions are also values, and to define a function, we use the syntax
\begin{lstlisting}[language=ebnf]
  "let" name arg { arg } "=" expr
\end{lstlisting}
where \lstinline|arg| is a list of argument names, and \lstinline|expr| is an expression. Defining a function \lstinline|sum| as part of the solution to the above program gives,
\fs{quickStartSumFct}{A script to add 2 numbers using a user defined function.}
Entering the function into an interactive session will illustrate the inferred type, the function \lstinline|sum| has: \lstinline{val sum : x:int * y:int -> int}, by which is meant that \lstinline|sum| is a mapping from the set product of the set of integers with integers into integers. Type inference in F\# may cause problems, since, e.g., the type of a function is based on the context in which it is defined. E.g., in an interactive session, defining the sum in one scope on a single line will default the types to integers, F\#'s favorite type, which will give an error, if it in a nested scope is to be used for floats. E.g.,
\begin{lstlisting}[language=console]
$ fsharpi

F# Interactive for F# 4.0 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

> let sum x y = x + y;;

val sum : x:int -> y:int -> int

> let c = sum 357.6 863.4;;

  let c = sum 357.6 863.4;;
  ------------^^^^^

/Users/sporring/Desktop/fsharpNotes/stdin(2,13): error FS0001: This expression was expected to have type
    int    
but here has type
    float    
> #quit;;
\end{lstlisting}
A remedy is to either define the function in the same scope as its use,
\begin{lstlisting}[language=console]
$ fsharpi

F# Interactive for F# 4.0 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

> let sum x y = x + y
- let c = sum 357.6 863.4;;

val sum : x:float -> y:float -> float
val c : float = 1221.0
> #quit;;
\end{lstlisting}
or specify the type of the function at point of definition using the notation,
\begin{lstlisting}[language=ebnf]
  "let" name argWType { argWType } [ ":" type ] "=" expr
  argWType = arg | "(" arg ":" type ")"
\end{lstlisting}
where not all types need to be declared, just sufficent for F\# to be able to infer the types for the full statement. In the example, one sufficent specification is,
\begin{lstlisting}[language=console]
$ fsharpi

F# Interactive for F# 4.0 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

> let sum (x : float) (y : float) = x + y;;

val sum : x:float -> y:float -> float

> let c = sum 357.6 863.4;;

val c : float = 1221.0

> #quit;;
\end{lstlisting}
but alternatively we could have specified the type of the result,
\begin{lstlisting}[language=FSharp]
  let sum x y : float = x + y
\end{lstlisting}
or even just one of the arguments,
\begin{lstlisting}[language=FSharp]
  let sum (x : float) y = x + y
\end{lstlisting}
In both cases, since the \lstinline|+| \idx{operator} is only defined for \idx{operands} of the same type, then when the type of either the result, any or both operands are declared, then the type of the remaining follows directly.

%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
