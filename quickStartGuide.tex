\chapter{Quick-start guide}
Programming is the art of solving problems by writing a program to be executed by a computer. For example, to solve the following problem,
%
\begin{problem}
  What is the sum of 357 and 864?
\end{problem}
%
we have written the following program in F\#,
%
\fs{quickStartSum}{A script to add 2 numbers and print the result to the console.}
%
In box the above, we see our program was saved as a script in a file called \texttt{quickStartSum.fsx}, and in the console we executed the program by typing the command \lstinline|fsharpi quickStartSum.fsx|. The result is then printed in the console to be \texttt{1221}.

To solve the program we made program consisting of several lines, where each line was a \idx{statement}. The first statement \lstinline|let a = 357| used the \idx{\keyword{let}} \idx{keyword} to \idx[binding]{bind} the value 357 to the name \lstinline|a|. Likewise, we bound the value 864 to the name \lstinline|b|, but to the name \lstinline|c| we bound the result of evaluating the \idx{expression} \lstinline|a + b|. That is, first the value \lstinline|a + b| was calculated by substituting the names of \lstinline|a| and \lstinline|b| with their values to give the expression, \lstinline|357 + 864|, then this expression was evaluated by adding the values to give, \lstinline|1221|, and this value was finally bound to the name \lstinline|c|. The last line printed the value of \lstinline|c| to the console followed by a newline (LF possibly preceded by CR, see Appendix~\ref{sec:ascii}) with the \lstinline|printfn| function. Here \lstinline|printfn| is a function of 2 arguments: \lstinline|"%A"| and \lstinline|c|. Notice, that in contrast to many other languages, F\# does not use parentheses to frame the list of arguments, nor does it use commas to separate them. In general, the \lstinline|printfn| function always has 1 or more arguments, and the first is a \idx{format string}. A \idx{string} is a sequence of characters starting and ending with double quotation marks. E.g., \lstinline|let s = "this is a string of characters"| binds the string \lstinline|"this is..."| to the name \lstinline|s|. For the \lstinline|printfn| function, the format string may be any string, but if it contains format character sequences, such as \lstinline|%A|, then the values following the format string are substituted. The format string must match the value \idx{type}, that is, here \lstinline|c| is of type integer, whereas the format string \lstinline|%A| matches any type.

Types are a central concept in F\#. In the script \ref{quickStartSum} we bound values of types \lstinline|int| and \lstinline|string| to names. The values were not \idx[type declaration]{declared} to have these types, instead the types were \idx[type inference]{inferred} by F\#. Had we typed these statements line by line in an interactive session, then we would have seen the inferred types:
%
\begin{comment}
$ fsharpi

F# Interactive for F# 4.0 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

\end{comment}
%
%
\begin{comment}
  $
\end{comment}
%
%
\fso{typeInference}{Inferred types are given as part of the response from the interpreter.}
% \begin{lstlisting}[language=fsharp,caption={fsharpi}]
% > let a = 357;;         

% val a : int = 357

% > let b = 864;;

% val b : int = 864

% > let c = a + b;;

% val c : int = 1221

% > printfn "%A" c;;
% 1221
% val it : unit = ()
% \end{lstlisting}
%
%
\begin{comment}

> #quit;;
\end{comment}
%
The an interactive session displays the type using the \idx{\keyword{val}} keyword. Since the value is also responded, then the last \lstinline|printfn| statement is superfluous. However, \advice{it is ill advised to design programs to be run in an interactive session, since the scripts needs to be manually copied every time it is to be run, and since the starting state may be unclear.}

Were we to solve a slightly different problem,
%
\begin{problem}
  What is the sum of 357.6 and 863.4?
\end{problem}
%
then we would have to use floating point arithmetic instead of integers, and the program would look like,
%
\fs{quickStartSumFloat}{Floating point types and arithmetic.}
%
On the surface, this could appear as an almost negligible change, but the set of integers and the set of real numbers (floats) require quite different representations, in order to be effective on a computer, and as a consequence, the implementation of their operations such as addition are very different. Thus, although the response is an integer, it has type \lstinline|float|, which is indicated by \lstinline|1221.0| which is not the same as \lstinline|1221|. F\# is very picky about types, and generally does not allow types to be mixed. E.g., in an interactive session,
%
\fso{typeInferenceError}{Mixing types is often not allowed.}
% \begin{lstlisting}[language=fsharp,caption=fsharpi]
% > let a = 357;;

% val a : int = 357

% > let b = 863.4;;

% val b : float = 863.4

% > let c = a + b;;

%   let c = a + b;;
%   ------------^

% /Users/sporring/Desktop/fsharpNotes/stdin(3,13): error FS0001: The type 'float' does not match the type 'int'
% \end{lstlisting}
%
we see that binding a name to a number without a decimal point is inferred to be integer, while when binding to a number with a decimal point, then the type is inferred to be a float, and when trying to add values of integer and floating point, then we get an error.

F\# is a functional first programming language, and one implication is that names have a \idx{lexical scope}. A scope is an area in a program, where a binding is valid, and lexical scope means that when a binding is used, then its value is substituted at the place of binding regardless of whether its value is rebound later in the text. Further, at the outer most level, rebinding is not allowed. If attempted, then F\# will return an error as, e.g., \jon{When command is omitted, then error messages have unwanted blank lines.}
%
\fs{quickStartRebindError}{A name cannot be rebound.}
%
However, if the same was performed in an interactive session,
%
\fso{blocksNNames}{Names may be reused when separated by the token \token{;;}.}
% \begin{lstlisting}[language=fsharp,caption=fsharpi]
% > let a = 357;;

% val a : int = 357

% > let a = 864;;

% val a : int = 864
% \end{lstlisting}
%
then apparently rebinding is valid. The difference is that the \idx{\token{;;}} \idx{token} defines a new nested \idx{scope}.\jon{Language change: Spec 4.0 p. 15.1 talks about blocks instead of scopes.} A token is a letter or a word, which the F\# considers as an atomic unit. Scopes can be \idx[nested scope]{nested}, and in F\# a binding may reuse names in a nested scope, in which case the previous value is \idx[overshadow]{overshadowed}. I.e., attempting the same without \token{;;} between the two let statements results in an error, e.g.,
%
\fso{blocksNNamesError}{Inside a block, names may not be reused.}
% \begin{lstlisting}[language=fsharp,caption=fsharpi]
% > let a = 357
% - let a = 864;;

%   let a = 864;;
%   ----^

% /Users/sporring/Desktop/fsharpNotes/stdin(2,5): error FS0037: Duplicate definition of value 'a'
% \end{lstlisting}
%
Scopes can be visualized as nested squares as shown in Figure~\ref{fig:scope}.
\begin{figure}
  \centering
  \subfigure[Invalid]{
    \fbox{
      \begin{minipage}{0.2\linewidth}
        \lstinline|let a = 357|\\
        \lstinline|let a = 864;;|
      \end{minipage}
    }
  }
  \subfigure[Valid]{
    \fbox{
      \begin{minipage}{0.2\linewidth}
      \lstinline|let a = 357;;|\\
      \fbox{
      \begin{minipage}{0.85\linewidth}
        \lstinline|let a = 864;;|
      \end{minipage}
    }
  \end{minipage}
}
  }
  \caption{Binding of the the same name in the same scope is invalid in F\# 2, but valid in a different scopes. In (a) the two bindings are in the same scope, which is invalid, while in (b) the bindings are in separate scopes by the extra \token{;;} token, which is valid.}
  \label{fig:scope}
\end{figure}

In F\# \idx[function]{functions} are also values, and defining a function \lstinline|sum| as part of the solution to the above program gives,
%
\fs{quickStartSumFct}{A script to add 2 numbers using a user defined function.}
%
Entering the function into an interactive session will illustrate the inferred type, the function \lstinline|sum| has: \lstinline{val sum : x:int * y:int -> int}, by which is meant that \lstinline|sum| is a mapping from the set product of integers with integers into integers. Type inference in F\# may cause problems, since the type of a function is inferred in the context, in which it is defined. E.g., in an interactive session, defining the sum in one scope on a single line will default the types to integers, F\#'s favorite type, which will give an error, if it in a nested scope is to be used for floats,
%
\fso{typesNBlockInference}{Types are inferred in blocks, and F\# tends to prefer integers.}
% \begin{lstlisting}[language=fsharp,caption=fsharpi]
% > let sum x y = x + y;;

% val sum : x:int -> y:int -> int

% > let c = sum 357.6 863.4;;

%   let c = sum 357.6 863.4;;
%   ------------^^^^^

% /Users/sporring/Desktop/fsharpNotes/stdin(2,13): error FS0001: This expression was expected to have type
%     int    
% but here has type
%     float    
% \end{lstlisting}
A remedy is to either define the function in the same scope as its use,
%
\fso{typesNBlockInference}{Defining a function together with its use, makes F\# infer the appropriate types.}
% \begin{lstlisting}[language=fsharp,caption=fsharpi]
% > let sum x y = x + y
% - let c = sum 357.6 863.4;;

% val sum : x:float -> y:float -> float
% val c : float = 1221.0
% \end{lstlisting}

In this chapter, we have scratched the surface of learning how to program by concentrating on a number of key programming concepts and how they are expressed in the F\# language. In the following chapters, we will expand the description of F\# with features used in all programming approaches.

%%% Local Variables:
%%% TeX-master: "fsharpNotes"
%%% End:
