\documentclass[fsharpNotes.tex]{subfiles}
\graphicspath{ {./figures/} }

\begin{document}
\chapter{Assemblies}
\label{chap:assemblies}

\dots

However, \advice{it is ill-advised to design programs to be run in an interactive session, since the scripts need to be manually copied every time it is to be run, and since the starting state may be unclear.} 


Both the interpreter and the compiler translates the source code into a format which can be executed by the computer. While the compiler performs this translation once and stores the result in the executable file, the interpreter translates the code every time the code is executed. Thus, to run the program again with the interpreter, it must be retranslated as "\lstinline[language=console]{$fsharpi gettingStartedStump.fsx}''. %$
In contrast, compiled code does not need to be recompiled to be run again, only re-executed using "\lstinline[language=console]{$ mono gettingStartedStump.exe}". %$
On a MacBook Pro, with a 2.9 GHz Intel Core i5, the time the various stages take for this script are:
\begin{center}
  \rowcolors{2}{oddRowColor}{evenRowColor}
  \begin{tabular}{|l|l|}
    \hline
    \rowcolor{headerRowColor} Command & Time\\
    \hline
    \lstinline[language=console]|fsharpi gettingStartedStump.fsx| & 1.88s\\
    \lstinline[language=console]|fsharpc gettingStartedStump.fsx| & 1.90s\\
    \lstinline[language=console]|mono gettingStartedStump.exe| & 0.05s\\
    \hline
\end{tabular}
\end{center}
I.e., executing the script with \lstinline[language=console]|fsharpi| is slightly faster than by first compiling it with \lstinline[language=console]|fsharpc| and then executing the result with \lstinline[language=console]|mono| ($1.88\text{s} < 0.05\text{s}+1.90\text{s}$), if the script were to be executed only once, but every future execution of the script using the compiled version requires only the use of \lstinline[language=console]|mono|, which is much faster than \lstinline[language=console]|fsharpi| ($1.88\text{s}\gg 0.05\text{s}$).

Finally, the file containing \lstinline[language=console]{gettingStartedStump.tex} may be compiled into an executable file with the program \lstinline[language=console]{fsharpc}, and run using the program \lstinline[language=console]{mono} from the console. This is demonstrated in \Cref{compiler}.
%
\begin{codeNOutput}[label=compiler,
  top=-5pt,
  bottom=-5pt,
  left=-2pt,
  right=-2pt,
]{: Compiling and executing a script.}
\begin{lstlisting}[language=console,escapechar=§]
$ §\tikzmark{lst3_1-tl}§fsharpc gettingStartedStump.fsx §\tikzmark{lst3_1-br}§
F# Compiler for F# 4.1 (Open Source Edition)
Freely distributed under the Apache 2.0 Open Source License
$ §\tikzmark{lst3_2-tl}§mono gettingStartedStump.exe§\tikzmark{lst3_2-br}§
3
\end{lstlisting}
\FrameArea{lst3_1-tl}{lst3_1-br}%
\FrameArea{lst3_2-tl}{lst3_2-br}%
\end{codeNOutput}
%
The compiler reads \lstinline[language=console]{gettingStartedStump.fsx} and makes \lstinline[language=console]{gettingStartedStump.exe}, which can be run using \lstinline[language=console]{mono}.



Executing programs with the interpreted directly from a file and compiling and executing the program is much preferred for programming complete programs, since the starting state is well defined, and since this better supports \idx{unit testing}, which is a method for debugging programs. Thus, \advice{prefer compiling over interpretation.}% This comments corrects wrongly placed margin note: https://tex.stackexchange.com/questions/147827/why-does-marginpar-sometimes-add-an-unnecessary-newline


\end{document}
